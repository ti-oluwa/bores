{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"BORES - Black-Oil REservoir Simulator","text":"<p>BORES is a 3D three-phase black-oil reservoir modelling and simulation framework written in Python. It provides a Pythonic API for constructing reservoir models, defining wells and boundary conditions, running multiphase flow simulations, and analyzing results. BORES targets petroleum engineers, researchers, and students who need a transparent, scriptable alternative to closed-source commercial simulators.</p> <p>Research and Educational Use</p> <p>BORES is currently in alpha (v0.1.0). It is designed for educational and research purposes. Do not use it for production field development planning or regulatory submissions without independent verification. Results should always be validated against analytical solutions or established commercial simulators before drawing engineering conclusions.</p>"},{"location":"#quick-example","title":"Quick Example","text":"<p>The following example sets up and runs a small 3D waterflood simulation from scratch. It defines a 10x10x3 grid, places one injector and one producer, and runs for 365 days using the default IMPES scheme.</p> <pre><code>import bores\nimport numpy as np\n\n# Set precision (32-bit is the default)\nbores.use_32bit_precision()\n\n# Grid dimensions: 10x10x3 cells, each 100 ft x 100 ft, 20 ft thick\ngrid_shape = (10, 10, 3)\ncell_dimension = (100.0, 100.0)\n\n# Build property grids\nthickness = bores.build_uniform_grid(grid_shape, value=20.0)         # ft\npressure = bores.build_uniform_grid(grid_shape, value=3000.0)        # psi\nporosity = bores.build_uniform_grid(grid_shape, value=0.20)          # fraction\ntemperature = bores.build_uniform_grid(grid_shape, value=180.0)      # deg F\noil_viscosity = bores.build_uniform_grid(grid_shape, value=1.5)      # cP\nbubble_point = bores.build_uniform_grid(grid_shape, value=2500.0)    # psi\n\n# Residual and irreducible saturations\nSorw = bores.build_uniform_grid(grid_shape, value=0.20)\nSorg = bores.build_uniform_grid(grid_shape, value=0.15)\nSgr = bores.build_uniform_grid(grid_shape, value=0.05)\nSwir = bores.build_uniform_grid(grid_shape, value=0.20)\nSwc = bores.build_uniform_grid(grid_shape, value=0.20)\n\n# Build depth grid and compute initial saturations from fluid contacts\ndepth = bores.build_depth_grid(thickness, datum=5000.0)  # Top at 5000 ft\nSw, So, Sg = bores.build_saturation_grids(\n    depth_grid=depth,\n    gas_oil_contact=4999.0,      # Above reservoir (no gas cap)\n    oil_water_contact=5100.0,    # Below reservoir (all oil zone)\n    connate_water_saturation_grid=Swc,\n    residual_oil_saturation_water_grid=Sorw,\n    residual_oil_saturation_gas_grid=Sorg,\n    residual_gas_saturation_grid=Sgr,\n    porosity_grid=porosity,\n)\n\n# Isotropic permeability: 100 mD\nperm_grid = bores.build_uniform_grid(grid_shape, value=100.0)\npermeability = bores.RockPermeability(x=perm_grid, y=perm_grid, z=perm_grid)\n\n# Build the reservoir model\nmodel = bores.reservoir_model(\n    grid_shape=grid_shape, cell_dimension=cell_dimension,\n    thickness_grid=thickness, pressure_grid=pressure,\n    rock_compressibility=3e-6, absolute_permeability=permeability,\n    porosity_grid=porosity, temperature_grid=temperature,\n    water_saturation_grid=Sw, gas_saturation_grid=Sg,\n    oil_saturation_grid=So, oil_viscosity_grid=oil_viscosity,\n    oil_bubble_point_pressure_grid=bubble_point,\n    residual_oil_saturation_water_grid=Sorw,\n    residual_oil_saturation_gas_grid=Sorg,\n    residual_gas_saturation_grid=Sgr,\n    irreducible_water_saturation_grid=Swir,\n    connate_water_saturation_grid=Swc,\n)\n\n# Define wells\ninjector = bores.injection_well(\n    well_name=\"INJ-1\",\n    perforating_intervals=[((0, 0, 0), (0, 0, 2))],\n    radius=0.25,\n    control=bores.ConstantRateControl(target_rate=500.0),\n    injected_fluid=bores.InjectedFluid(\n        name=\"Water\", phase=bores.FluidPhase.WATER,\n        specific_gravity=1.0, molecular_weight=18.015,\n    ),\n)\nproducer = bores.production_well(\n    well_name=\"PROD-1\",\n    perforating_intervals=[((9, 9, 0), (9, 9, 2))],\n    radius=0.25,\n    control=bores.PrimaryPhaseRateControl(\n        primary_phase=bores.FluidPhase.OIL,\n        primary_control=bores.AdaptiveBHPRateControl(\n            target_rate=-500.0, target_phase=\"oil\", bhp_limit=1000.0,\n        ),\n        secondary_clamp=bores.ProductionClamp(),\n    ),\n    produced_fluids=[\n        bores.ProducedFluid(name=\"Oil\", phase=bores.FluidPhase.OIL,\n                            specific_gravity=0.85, molecular_weight=200.0),\n        bores.ProducedFluid(name=\"Water\", phase=bores.FluidPhase.WATER,\n                            specific_gravity=1.0, molecular_weight=18.015),\n    ],\n)\nwells = bores.wells_(injectors=[injector], producers=[producer])\n\n# Rock-fluid tables (Brooks-Corey relative permeability + capillary pressure)\nrock_fluid = bores.RockFluidTables(\n    relative_permeability_table=bores.BrooksCoreyThreePhaseRelPermModel(\n        water_exponent=2.0, oil_exponent=2.0, gas_exponent=2.0,\n    ),\n    capillary_pressure_table=bores.BrooksCoreyCapillaryPressureModel(),\n)\n\n# Simulation configuration\nTime = bores.Timer.Time\nconfig = bores.Config(\n    timer=bores.Timer(\n        initial_step_size=Time(days=1),\n        max_step_size=Time(days=10),\n        min_step_size=Time(hours=1),\n        simulation_time=Time(days=365),\n    ),\n    rock_fluid_tables=rock_fluid,\n    wells=wells,\n    scheme=\"impes\",\n)\n\n# Run the simulation and collect states\nstates = list(bores.run(model, config))\nfinal = states[-1]\nprint(f\"Completed {final.step} steps in {final.time_in_days:.1f} days\")\nprint(f\"Final avg pressure: {final.model.fluid_properties.pressure_grid.mean():.1f} psi\")\n</code></pre>"},{"location":"#key-capabilities","title":"Key Capabilities","text":"<p>BORES covers the core elements of black-oil reservoir simulation within a single Python package.</p> <p>Three-phase flow simulation - Solves coupled pressure and saturation equations for oil, water, and gas phases using the IMPES (Implicit Pressure, Explicit Saturation) scheme. Explicit and fully implicit schemes are also available.</p> <p>PVT correlations and tables - Ships with industry-standard correlations (Standing, Vasquez-Beggs, Lee-Gonzalez, and others) for computing fluid properties from pressure and temperature. You can also supply your own PVT tables for direct lookup.</p> <p>Well modelling - Supports injection and production wells with multiple control modes: constant rate, BHP control, and adaptive BHP-rate control. Wells can have multiple perforating intervals, skin factors, and scheduled control changes.</p> <p>Flexible boundary conditions - Includes constant pressure, no-flow, flux boundaries, periodic boundaries, and Carter-Tracy aquifer models. Boundary conditions can be combined on different faces of the reservoir grid.</p> <p>Post-simulation analysis - Built-in analysis tools for computing recovery factors, production profiles, front tracking, and mobility ratios. Plotly-based visualization produces 1D series, 2D maps, and interactive 3D volume renders.</p>"},{"location":"#who-is-bores-for","title":"Who Is BORES For?","text":"<p>BORES is built for people who want to understand and experiment with reservoir simulation at the code level. If you are a petroleum engineering student working through textbook problems, BORES lets you set up models programmatically and inspect every intermediate calculation. You can trace how pressure propagates through a grid, watch saturation fronts develop, and compare numerical results against analytical solutions.</p> <p>Researchers working on new recovery methods, relative permeability models, or solver algorithms will find value in BORES as a testbed. The codebase uses immutable data models, making it straightforward to run parameter sweeps or compare different configurations without worrying about accidental state mutation. The factory-function design keeps model construction explicit and auditable.</p> <p>Practicing engineers who want a quick scripting tool for screening studies or generating initial estimates may also find BORES useful, provided they validate results against trusted tools. BORES is not a replacement for commercial simulators like Eclipse, CMG, or tNavigator, but it serves well as a complementary learning and prototyping tool.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<ul> <li> <p>Installation</p> <p>Install BORES with <code>uv</code> or <code>pip</code> and verify your setup.</p> <p> Installation</p> </li> <li> <p>Quickstart</p> <p>Build and run your first reservoir simulation in under 5 minutes.</p> <p> Quickstart</p> </li> <li> <p>Core Concepts</p> <p>Understand the simulation pipeline, data model design, and conventions.</p> <p> Concepts</p> </li> </ul>"},{"location":"api-reference/","title":"API Reference","text":""},{"location":"api-reference/#overview","title":"Overview","text":"<p>This section documents the programmatic interfaces of the BORES framework. The reference is organized into three areas: scalar PVT correlations (single-value functions for computing fluid properties), array PVT correlations (vectorized equivalents that operate on numpy grids), and the full public API surface exported from the <code>bores</code> package.</p> <p>The correlations modules are the computational foundation of the simulator. Every time BORES needs to compute an oil formation volume factor, gas compressibility, water viscosity, or any other pressure-volume-temperature property, it calls one of these functions. You can also call them directly in your own scripts for standalone PVT calculations, unit conversions, or validation against laboratory data.</p>"},{"location":"api-reference/#module-organization","title":"Module Organization","text":"Module Description <code>bores.correlations.core</code> Scalar PVT correlation functions (single float inputs and outputs) <code>bores.correlations.arrays</code> Array PVT correlation functions (numpy array inputs and outputs) <code>bores</code> Top-level package re-exporting all public classes, functions, and constants <p>The scalar correlations in <code>bores.correlations.core</code> are also accessible through <code>bores.correlations</code> directly (via a wildcard re-export). The array correlations must be imported from <code>bores.correlations.arrays</code> explicitly.</p>"},{"location":"api-reference/#how-to-use-this-reference","title":"How to Use This Reference","text":"<p>Scalar correlations are for point calculations: computing a single property value from a single set of conditions. Use them for quick checks, unit conversions, or building custom PVT tables.</p> <pre><code>from bores.correlations.core import compute_oil_formation_volume_factor_standing\n\nBo = compute_oil_formation_volume_factor_standing(\n    temperature=200.0,          # degrees F\n    oil_specific_gravity=0.85,\n    gas_gravity=0.7,\n    gas_to_oil_ratio=500.0,     # SCF/STB\n)\nprint(f\"Bo = {Bo:.4f} bbl/STB\")\n</code></pre> <p>Array correlations are for grid-level calculations: computing property grids from pressure, temperature, and composition grids. The simulator uses these internally, but you can also use them for post-processing or custom property computations.</p> <pre><code>from bores.correlations.arrays import compute_oil_formation_volume_factor\n\nBo_grid = compute_oil_formation_volume_factor(\n    pressure=pressure_grid,\n    temperature=temperature_grid,\n    bubble_point_pressure=Pb_grid,\n    oil_specific_gravity=0.85,\n    gas_gravity=0.7,\n    gas_to_oil_ratio=Rs_grid,\n    oil_compressibility=co_grid,\n)\n</code></pre> <p>Full API lists every class, function, and constant exported from the <code>bores</code> package. Use it as a lookup when you know the name of something but need to confirm the import path or check the signature.</p>"},{"location":"api-reference/#pages","title":"Pages","text":"<ul> <li>Scalar Correlations - Single-value PVT functions for point calculations</li> <li>Array Correlations - Vectorized PVT functions for grid-level calculations</li> <li>Full API - Complete listing of the public API surface</li> </ul>"},{"location":"api-reference/correlations-array/","title":"Array PVT Correlations","text":""},{"location":"api-reference/correlations-array/#overview","title":"Overview","text":"<p>The <code>bores.correlations.arrays</code> module contains vectorized versions of every scalar PVT correlation from <code>bores.correlations.core</code>. Where the scalar module operates on single float values, the array module operates on NumPy arrays of any shape and dimension. These are the functions the simulator calls internally to compute fluid properties across the entire reservoir grid in a single pass, and you can use them for post-processing, custom property computations, or building property grids from scratch.</p> <p>Every function in this module accepts <code>NDimensionalGrid</code> arrays (typed NumPy arrays parameterized by dimension) and returns arrays of the same shape. The functions use the same correlations, formulas, and valid ranges as their scalar counterparts. Many are compiled with Numba's <code>@numba.njit</code> decorator for performance-critical inner loops, while CoolProp-based functions iterate over array elements internally.</p> <p>All units are the same as the scalar module: pressure in psi, temperature in degrees Fahrenheit, density in lbm/ft3, viscosity in cP, and formation volume factors in bbl/STB or ft3/SCF.</p> <pre><code>from bores.correlations.arrays import (\n    compute_oil_formation_volume_factor,\n    compute_gas_compressibility_factor,\n    compute_oil_viscosity,\n)\n</code></pre> <p>Relationship to Scalar Correlations</p> <p>Every public function in <code>bores.correlations.arrays</code> has a corresponding scalar version in <code>bores.correlations.core</code> with the same name and the same parameters. The only difference is that array functions accept and return NumPy arrays instead of floats. See the Scalar Correlations page for detailed descriptions of each correlation's formula, valid ranges, and physical interpretation.</p>"},{"location":"api-reference/correlations-array/#how-array-functions-differ-from-scalar","title":"How Array Functions Differ from Scalar","text":"<p>The key differences between the array and scalar modules are:</p> <p>Input types. Scalar functions accept <code>float</code> parameters. Array functions accept <code>NDimensionalGrid[NDimension]</code> parameters, which are NumPy arrays of shape <code>(nx,)</code>, <code>(nx, ny)</code>, or <code>(nx, ny, nz)</code> depending on the simulation dimensionality.</p> <p>Broadcasting. Array functions follow NumPy broadcasting rules. You can pass a scalar value for a parameter that is uniform across the grid (like gas gravity) and it will be broadcast against the grid-shaped parameters (like pressure). Some parameters explicitly accept <code>FloatOrArray</code> types for this purpose.</p> <p>Validation. Scalar functions raise <code>ValidationError</code> immediately when a single invalid value is detected. Array functions use <code>min_()</code> and <code>max_()</code> helpers to check the entire grid at once, raising an error if any element violates the constraint.</p> <p>Precision. Array functions respect the global precision setting (<code>use_32bit_precision()</code> / <code>use_64bit_precision()</code>). Results are cast to the same dtype as the input arrays using the <code>get_dtype()</code> helper.</p> <p>Numba compilation. Many array functions are decorated with <code>@numba.njit(cache=True)</code> for JIT compilation. The first call triggers compilation (typically 1-5 seconds), and subsequent calls use the cached machine code. CoolProp-based functions cannot be Numba-compiled and iterate over array elements with a Python loop instead.</p>"},{"location":"api-reference/correlations-array/#quick-example","title":"Quick Example","text":"<pre><code>import numpy as np\nfrom bores.correlations.arrays import (\n    compute_oil_formation_volume_factor,\n    compute_gas_compressibility_factor,\n    compute_oil_viscosity,\n)\n\n# Grid-shaped pressure and temperature arrays\ngrid_shape = (10, 10, 3)\npressure = np.full(grid_shape, 3000.0, dtype=np.float32)\ntemperature = np.full(grid_shape, 200.0, dtype=np.float32)\nbubble_point = np.full(grid_shape, 2500.0, dtype=np.float32)\noil_sg = np.full(grid_shape, 0.85, dtype=np.float32)\ngas_gravity = np.full(grid_shape, 0.70, dtype=np.float32)\ngor = np.full(grid_shape, 500.0, dtype=np.float32)\noil_comp = np.full(grid_shape, 1e-5, dtype=np.float32)\n\n# Compute Bo for every cell at once\nBo_grid = compute_oil_formation_volume_factor(\n    pressure=pressure,\n    temperature=temperature,\n    bubble_point_pressure=bubble_point,\n    oil_specific_gravity=oil_sg,\n    gas_gravity=gas_gravity,\n    gas_to_oil_ratio=gor,\n    oil_compressibility=oil_comp,\n)\nprint(f\"Bo range: {Bo_grid.min():.4f} to {Bo_grid.max():.4f} bbl/STB\")\n</code></pre>"},{"location":"api-reference/correlations-array/#function-reference","title":"Function Reference","text":"<p>The table below lists every public function in the array module. Each function has the same name, the same parameters, and uses the same correlation as its scalar counterpart. Click through to the Scalar Correlations page for detailed descriptions of formulas, valid ranges, and physical interpretation.</p>"},{"location":"api-reference/correlations-array/#generic-fluid-properties-coolprop","title":"Generic Fluid Properties (CoolProp)","text":"Function Returns Unit <code>compute_fluid_density(pressure, temperature, fluid)</code> Fluid density grid lbm/ft3 <code>compute_fluid_viscosity(pressure, temperature, fluid)</code> Fluid viscosity grid cP <code>compute_fluid_compressibility_factor(pressure, temperature, fluid)</code> Z-factor grid dimensionless <code>compute_fluid_compressibility(pressure, temperature, fluid)</code> Compressibility grid psi-1 <p>These functions iterate over each element of the input arrays and call CoolProp for each cell individually. They are slower than the correlation-based functions below but work for any fluid supported by CoolProp (CO2, N2, Methane, n-Octane, etc.).</p>"},{"location":"api-reference/correlations-array/#gas-gravity","title":"Gas Gravity","text":"Function Returns Unit <code>compute_gas_gravity(gas)</code> Gas specific gravity dimensionless <code>compute_gas_gravity_from_density(pressure, temperature, density)</code> Gas gravity from measured density dimensionless <p>Note</p> <p><code>compute_gas_gravity(gas)</code> takes a single string and returns a scalar float, identical to the scalar version. It does not operate on arrays.</p>"},{"location":"api-reference/correlations-array/#oil-properties","title":"Oil Properties","text":"Function Returns Unit <code>compute_oil_specific_gravity(oil_density, pressure, temperature, oil_compressibility)</code> Oil specific gravity grid dimensionless <code>compute_oil_api_gravity(oil_specific_gravity)</code> API gravity grid degrees <code>compute_oil_formation_volume_factor_standing(temperature, oil_specific_gravity, gas_gravity, gas_to_oil_ratio)</code> Bo grid (Standing) bbl/STB <code>compute_oil_formation_volume_factor_vazquez_and_beggs(temperature, oil_specific_gravity, gas_gravity, gas_to_oil_ratio)</code> Bo grid (Vazquez-Beggs) bbl/STB <code>correct_oil_fvf_for_pressure(saturated_oil_fvf, oil_compressibility, bubble_point_pressure, current_pressure)</code> Corrected Bo grid bbl/STB <code>compute_oil_formation_volume_factor(pressure, temperature, bubble_point_pressure, oil_specific_gravity, gas_gravity, gas_to_oil_ratio, oil_compressibility)</code> Bo grid (unified) bbl/STB <code>compute_dead_oil_viscosity_modified_beggs(temperature, oil_specific_gravity)</code> Dead oil viscosity grid cP <code>compute_oil_viscosity(pressure, temperature, bubble_point_pressure, oil_specific_gravity, gas_to_oil_ratio, gor_at_bubble_point_pressure)</code> Oil viscosity grid cP <code>compute_oil_compressibility(pressure, temperature, bubble_point_pressure, oil_api_gravity, gas_gravity, gor_at_bubble_point_pressure, ...)</code> Oil compressibility grid psi-1 <code>compute_live_oil_density(api_gravity, gas_gravity, gas_to_oil_ratio, formation_volume_factor)</code> Live oil density grid lbm/ft3"},{"location":"api-reference/correlations-array/#gas-properties","title":"Gas Properties","text":"Function Returns Unit <code>compute_gas_molecular_weight(gas_gravity)</code> Gas molecular weight grid g/mol <code>compute_gas_pseudocritical_properties(gas_gravity, h2s_mole_fraction, co2_mole_fraction, n2_mole_fraction)</code> (Ppc, Tpc) tuple of grids psi, R <code>compute_gas_formation_volume_factor(pressure, temperature, gas_compressibility_factor)</code> Bg grid ft3/SCF <code>compute_gas_compressibility_factor_papay(pressure, temperature, gas_gravity, ...)</code> Z-factor grid (Papay) dimensionless <code>compute_gas_compressibility_factor_hall_yarborough(pressure, temperature, gas_gravity, ...)</code> Z-factor grid (Hall-Yarborough) dimensionless <code>compute_gas_compressibility_factor_dranchuk_abou_kassem(pressure, temperature, gas_gravity, ...)</code> Z-factor grid (DAK) dimensionless <code>compute_gas_compressibility_factor(pressure, temperature, gas_gravity, ..., method)</code> Z-factor grid (unified) dimensionless <code>compute_gas_density(pressure, temperature, gas_gravity, gas_compressibility_factor)</code> Gas density grid lbm/ft3 <code>compute_gas_viscosity(temperature, gas_density, gas_molecular_weight)</code> Gas viscosity grid (LGE) cP <code>compute_gas_compressibility(pressure, temperature, gas_gravity, ...)</code> Gas compressibility grid psi-1"},{"location":"api-reference/correlations-array/#water-properties","title":"Water Properties","text":"Function Returns Unit <code>compute_water_formation_volume_factor(water_density, salinity)</code> Bw grid bbl/STB <code>compute_water_formation_volume_factor_mccain(pressure, temperature, salinity, gas_solubility)</code> Bw grid (McCain) bbl/STB <code>compute_water_viscosity(temperature, salinity, pressure)</code> Water viscosity grid cP <code>compute_water_density(pressure, temperature, gas_gravity, salinity, gas_solubility_in_water, gas_free_water_formation_volume_factor)</code> Live water density grid lbm/ft3 <code>compute_water_density_mccain(pressure, temperature, salinity)</code> Water density grid (McCain) lbm/ft3 <code>compute_water_density_batzle(pressure, temperature, salinity)</code> Water density grid (Batzle-Wang) lbm/ft3 <code>compute_water_compressibility(pressure, temperature, bubble_point_pressure, gas_formation_volume_factor, gas_solubility_in_water, gas_free_water_formation_volume_factor, salinity)</code> Water compressibility grid psi-1 <code>compute_gas_free_water_formation_volume_factor(pressure, temperature)</code> Gas-free Bw grid bbl/STB"},{"location":"api-reference/correlations-array/#bubble-point-and-gor","title":"Bubble Point and GOR","text":"Function Returns Unit <code>compute_oil_bubble_point_pressure(gas_gravity, oil_api_gravity, temperature, gas_to_oil_ratio)</code> Bubble point grid psi <code>compute_water_bubble_point_pressure(temperature, gas_solubility_in_water, salinity, gas)</code> Water bubble point grid psi <code>compute_gas_to_oil_ratio(pressure, temperature, bubble_point_pressure, gas_gravity, oil_api_gravity, ...)</code> GOR grid (Vazquez-Beggs) SCF/STB <code>compute_gas_to_oil_ratio_standing(pressure, oil_api_gravity, gas_gravity)</code> GOR grid (Standing) SCF/STB <code>estimate_solution_gor(pressure, temperature, oil_api_gravity, gas_gravity)</code> Iterative GOR estimate grid SCF/STB <code>estimate_bubble_point_pressure_standing(oil_api_gravity, gas_gravity, observed_gas_to_oil_ratio)</code> Estimated Pb grid psi <code>compute_gas_solubility_in_water(pressure, temperature, salinity, gas)</code> Gas solubility in water grid SCF/STB"},{"location":"api-reference/correlations-array/#multi-phase-and-volumetrics","title":"Multi-Phase and Volumetrics","text":"Function Returns Unit <code>compute_total_fluid_compressibility(water_saturation, oil_saturation, water_compressibility, oil_compressibility, gas_saturation, gas_compressibility)</code> Total compressibility grid psi-1 <code>compute_hydrocarbon_in_place(area, thickness, porosity, phase_saturation, formation_volume_factor, net_to_gross_ratio, hydrocarbon_type)</code> HCIP grid STB or SCF <code>convert_surface_rate_to_reservoir(surface_rate, formation_volume_factor)</code> Reservoir rate grid bbl/day <code>convert_reservoir_rate_to_surface(reservoir_rate, formation_volume_factor)</code> Surface rate grid STB/day"},{"location":"api-reference/correlations-array/#miscible-flooding-todd-longstaff","title":"Miscible Flooding (Todd-Longstaff)","text":"Function Returns Unit <code>compute_miscibility_transition_factor(pressure, minimum_miscibility_pressure, transition_width)</code> Transition factor grid dimensionless <code>compute_effective_todd_longstaff_omega(pressure, base_omega, minimum_miscibility_pressure, transition_width)</code> Effective omega grid dimensionless <code>compute_todd_longstaff_effective_viscosity(oil_viscosity, solvent_viscosity, solvent_concentration, omega)</code> Effective viscosity grid cP <code>compute_todd_longstaff_effective_density(oil_density, solvent_density, oil_viscosity, solvent_viscosity, solvent_concentration, omega)</code> Effective density grid lbm/ft3"},{"location":"api-reference/correlations-array/#performance-notes","title":"Performance Notes","text":"<p>The array functions are designed for grid-level computation and are significantly faster than calling the scalar versions in a Python loop over cells. For a 100x100x20 grid (200,000 cells):</p> <ul> <li>Numba-compiled functions (most correlations): Run at near-C speed after the first compilation. Typical computation times are 1-10 ms per grid evaluation.</li> <li>CoolProp-based functions (<code>compute_fluid_density</code>, <code>compute_fluid_viscosity</code>, etc.): Iterate over elements in Python calling CoolProp for each cell. These are 10-100x slower than correlation-based functions but provide equation-of-state accuracy for non-standard fluids.</li> </ul> <p>If you need CoolProp-level accuracy for standard reservoir fluids, consider computing properties once and storing them in a PVT table using <code>bores.PVTTables</code>, then using table lookup during simulation instead of repeated CoolProp calls.</p>"},{"location":"api-reference/correlations-scalar/","title":"Scalar PVT Correlations","text":""},{"location":"api-reference/correlations-scalar/#overview","title":"Overview","text":"<p>The <code>bores.correlations.core</code> module contains scalar PVT correlation functions. Each function accepts single float values as input and returns a single float result. These are the building blocks that the simulator calls internally when computing fluid properties cell by cell, and you can also call them directly in your own scripts for point calculations, unit conversions, validation against laboratory data, or building custom PVT tables.</p> <p>All functions in this module use oilfield units: pressure in psi, temperature in degrees Fahrenheit, density in lbm/ft3, viscosity in centipoise, and volume factors in bbl/STB or ft3/SCF. The module also provides generic CoolProp-based functions that accept any fluid name supported by the CoolProp thermodynamic library, which are useful for computing properties of non-standard fluids like CO2, nitrogen, or other injection gases.</p> <p>The functions are organized by property category below. Within each category, you will find correlation-specific variants (e.g., Standing, Vazquez-Beggs) as well as unified dispatch functions that select the best correlation automatically based on conditions. Import them from <code>bores.correlations.core</code> or from <code>bores.correlations</code> directly.</p> <pre><code>from bores.correlations.core import (\n    compute_oil_formation_volume_factor_standing,\n    compute_gas_compressibility_factor,\n    compute_oil_viscosity,\n)\n\n# Or equivalently:\nfrom bores.correlations import compute_oil_formation_volume_factor_standing\n</code></pre>"},{"location":"api-reference/correlations-scalar/#temperature-and-unit-conversions","title":"Temperature and Unit Conversions","text":"<p>These utility functions convert between temperature scales. They accept both scalar floats and NumPy arrays.</p> Function Description Formula <code>kelvin_to_fahrenheit(temp_K)</code> Kelvin to Fahrenheit \\((K - 273.15) \\times 9/5 + 32\\) <code>fahrenheit_to_kelvin(temp_F)</code> Fahrenheit to Kelvin \\((F - 32) \\times 5/9 + 273.15\\) <code>fahrenheit_to_celsius(temp_F)</code> Fahrenheit to Celsius \\((F - 32) \\times 5/9\\) <code>fahrenheit_to_rankine(temp_F)</code> Fahrenheit to Rankine \\(F + 459.67\\) <pre><code>from bores.correlations.core import fahrenheit_to_kelvin, kelvin_to_fahrenheit\n\ntemp_K = fahrenheit_to_kelvin(200.0)   # 366.48 K\ntemp_F = kelvin_to_fahrenheit(366.48)  # 200.0 F\n</code></pre>"},{"location":"api-reference/correlations-scalar/#validation-and-clipping","title":"Validation and Clipping","text":"<p>These functions validate or constrain pressure and temperature inputs to physically reasonable ranges.</p> Function Parameters Description <code>validate_input_temperature(temperature)</code> <code>temperature</code>: Temperature (F) Raises <code>ValidationError</code> if temperature is outside the valid reservoir range <code>validate_input_pressure(pressure)</code> <code>pressure</code>: Pressure (psi) Raises <code>ValidationError</code> if pressure is outside the valid reservoir range <code>clip_pressure(pressure, fluid)</code> <code>pressure</code>: Pressure (psi), <code>fluid</code>: CoolProp fluid name Clips pressure to CoolProp's valid range for the given fluid <code>clip_temperature(temperature, fluid)</code> <code>temperature</code>: Temperature (K), <code>fluid</code>: CoolProp fluid name Clips temperature to CoolProp's valid range for the given fluid <code>is_CoolProp_supported_fluid(fluid)</code> <code>fluid</code>: Fluid name string Returns <code>True</code> if the fluid is supported by CoolProp (cached)"},{"location":"api-reference/correlations-scalar/#generic-fluid-properties-coolprop","title":"Generic Fluid Properties (CoolProp)","text":"<p>These functions compute fluid properties for any CoolProp-supported fluid using equation-of-state calculations. They are useful for injection gases (CO2, N2), pure hydrocarbons, and other fluids where black-oil correlations do not apply.</p>"},{"location":"api-reference/correlations-scalar/#compute_fluid_density","title":"<code>compute_fluid_density</code>","text":"<pre><code>compute_fluid_density(pressure: float, temperature: float, fluid: str) -&gt; float\n</code></pre> <p>Computes fluid density from the equation of state using CoolProp. Returns density in lbm/ft3.</p> Parameter Type Unit Description <code>pressure</code> <code>float</code> psi Reservoir pressure <code>temperature</code> <code>float</code> F Reservoir temperature <code>fluid</code> <code>str</code> - CoolProp fluid name (e.g., <code>\"CO2\"</code>, <code>\"Water\"</code>, <code>\"Methane\"</code>) <pre><code>from bores.correlations.core import compute_fluid_density\n\nco2_density = compute_fluid_density(3000.0, 200.0, \"CO2\")\nprint(f\"CO2 density: {co2_density:.2f} lbm/ft3\")\n</code></pre>"},{"location":"api-reference/correlations-scalar/#compute_fluid_viscosity","title":"<code>compute_fluid_viscosity</code>","text":"<pre><code>compute_fluid_viscosity(pressure: float, temperature: float, fluid: str) -&gt; float\n</code></pre> <p>Computes fluid dynamic viscosity from the equation of state using CoolProp. Returns viscosity in centipoise (cP).</p> Parameter Type Unit Description <code>pressure</code> <code>float</code> psi Reservoir pressure <code>temperature</code> <code>float</code> F Reservoir temperature <code>fluid</code> <code>str</code> - CoolProp fluid name"},{"location":"api-reference/correlations-scalar/#compute_fluid_compressibility_factor","title":"<code>compute_fluid_compressibility_factor</code>","text":"<pre><code>compute_fluid_compressibility_factor(pressure: float, temperature: float, fluid: str) -&gt; float\n</code></pre> <p>Computes the compressibility factor Z from equation of state. Returns a dimensionless value.</p>"},{"location":"api-reference/correlations-scalar/#compute_fluid_compressibility","title":"<code>compute_fluid_compressibility</code>","text":"<pre><code>compute_fluid_compressibility(pressure: float, temperature: float, fluid: str) -&gt; float\n</code></pre> <p>Computes isothermal compressibility \\(C_f = -(1/\\rho) \\cdot (d\\rho/dP)_T\\) using CoolProp. Returns compressibility in psi-1.</p>"},{"location":"api-reference/correlations-scalar/#gas-gravity","title":"Gas Gravity","text":""},{"location":"api-reference/correlations-scalar/#compute_gas_gravity","title":"<code>compute_gas_gravity</code>","text":"<pre><code>compute_gas_gravity(gas: str) -&gt; float\n</code></pre> <p>Computes the specific gravity of a gas relative to air at standard conditions. Accepts any CoolProp-supported gas name.</p> <pre><code>from bores.correlations.core import compute_gas_gravity\n\nmethane_gravity = compute_gas_gravity(\"Methane\")   # ~0.554\nco2_gravity = compute_gas_gravity(\"CO2\")           # ~1.52\n</code></pre>"},{"location":"api-reference/correlations-scalar/#compute_gas_gravity_from_density","title":"<code>compute_gas_gravity_from_density</code>","text":"<pre><code>compute_gas_gravity_from_density(pressure: float, temperature: float, density: float) -&gt; float\n</code></pre> <p>Computes gas gravity from a measured density at specific conditions, by comparing the density to air density at the same conditions.</p> Parameter Type Unit Description <code>pressure</code> <code>float</code> psi Pressure at which density was measured <code>temperature</code> <code>float</code> F Temperature at which density was measured <code>density</code> <code>float</code> lbm/ft3 Measured gas density"},{"location":"api-reference/correlations-scalar/#oil-specific-gravity-and-api-gravity","title":"Oil Specific Gravity and API Gravity","text":""},{"location":"api-reference/correlations-scalar/#compute_oil_specific_gravity","title":"<code>compute_oil_specific_gravity</code>","text":"<pre><code>compute_oil_specific_gravity(\n    oil_density: float, pressure: float, temperature: float, oil_compressibility: float\n) -&gt; float\n</code></pre> <p>Converts oil density at reservoir conditions to specific gravity at standard conditions using a linearized correction for pressure and temperature.</p> \\[\\rho_{stp} \\approx \\rho \\cdot \\exp\\left[C_o \\cdot (P_{stp} - P) + \\alpha \\cdot (T_{stp} - T)\\right]\\] \\[SG = \\rho_{stp} / \\rho_{water}\\]"},{"location":"api-reference/correlations-scalar/#compute_oil_api_gravity","title":"<code>compute_oil_api_gravity</code>","text":"<pre><code>compute_oil_api_gravity(oil_specific_gravity: float) -&gt; float\n</code></pre> <p>Converts oil specific gravity to API gravity in degrees.</p> \\[API = \\frac{141.5}{SG} - 131.5\\] <pre><code>from bores.correlations.core import compute_oil_api_gravity\n\napi = compute_oil_api_gravity(0.85)  # ~34.97 degrees API\n</code></pre>"},{"location":"api-reference/correlations-scalar/#rate-conversions","title":"Rate Conversions","text":""},{"location":"api-reference/correlations-scalar/#convert_surface_rate_to_reservoir","title":"<code>convert_surface_rate_to_reservoir</code>","text":"<pre><code>convert_surface_rate_to_reservoir(surface_rate: float, formation_volume_factor: float) -&gt; float\n</code></pre> <p>Converts a surface rate (STB/day) to reservoir conditions (bbl/day). For injection (positive rate), multiplies by FVF. For production (negative rate), divides by FVF.</p>"},{"location":"api-reference/correlations-scalar/#convert_reservoir_rate_to_surface","title":"<code>convert_reservoir_rate_to_surface</code>","text":"<pre><code>convert_reservoir_rate_to_surface(reservoir_rate: float, formation_volume_factor: float) -&gt; float\n</code></pre> <p>The inverse of <code>convert_surface_rate_to_reservoir</code>.</p>"},{"location":"api-reference/correlations-scalar/#oil-formation-volume-factor","title":"Oil Formation Volume Factor","text":""},{"location":"api-reference/correlations-scalar/#compute_oil_formation_volume_factor_standing","title":"<code>compute_oil_formation_volume_factor_standing</code>","text":"<pre><code>compute_oil_formation_volume_factor_standing(\n    temperature: float, oil_specific_gravity: float,\n    gas_gravity: float, gas_to_oil_ratio: float\n) -&gt; float\n</code></pre> <p>Computes \\(B_o\\) using the Standing (1947) correlation.</p> \\[B_o = 0.972 + 0.000147 \\cdot \\left[R_s \\cdot \\left(\\frac{\\gamma_g}{\\gamma_o}\\right)^{0.5} + 1.25 \\cdot T\\right]^{1.175}\\] Parameter Type Unit Description <code>temperature</code> <code>float</code> F Reservoir temperature <code>oil_specific_gravity</code> <code>float</code> - Oil specific gravity (water = 1.0) <code>gas_gravity</code> <code>float</code> - Gas specific gravity (air = 1.0) <code>gas_to_oil_ratio</code> <code>float</code> SCF/STB Solution gas-oil ratio <p>Valid range: 60-300 F, oil SG 0.5-0.95, GOR 20-2000 SCF/STB.</p> <pre><code>from bores.correlations.core import compute_oil_formation_volume_factor_standing\n\nBo = compute_oil_formation_volume_factor_standing(\n    temperature=200.0,\n    oil_specific_gravity=0.85,\n    gas_gravity=0.7,\n    gas_to_oil_ratio=500.0,\n)\nprint(f\"Bo = {Bo:.4f} bbl/STB\")\n</code></pre>"},{"location":"api-reference/correlations-scalar/#compute_oil_formation_volume_factor_vazquez_and_beggs","title":"<code>compute_oil_formation_volume_factor_vazquez_and_beggs</code>","text":"<pre><code>compute_oil_formation_volume_factor_vazquez_and_beggs(\n    temperature: float, oil_specific_gravity: float,\n    gas_gravity: float, gas_to_oil_ratio: float\n) -&gt; float\n</code></pre> <p>Computes \\(B_o\\) using the Vazquez and Beggs (1980) correlation. Uses API-gravity-dependent coefficients \\((a_1, a_2, a_3)\\) with different values for API &lt;= 30 and API &gt; 30.</p> <p>Valid range: API 16-58, temperature 100-300 F, GOR 0-2000 SCF/STB.</p>"},{"location":"api-reference/correlations-scalar/#correct_oil_fvf_for_pressure","title":"<code>correct_oil_fvf_for_pressure</code>","text":"<pre><code>correct_oil_fvf_for_pressure(\n    saturated_oil_fvf: float, oil_compressibility: float,\n    bubble_point_pressure: float, current_pressure: float\n) -&gt; float\n</code></pre> <p>Applies exponential shrinkage correction for pressures above bubble point.</p> \\[B_o(P) = B_o(P_b) \\cdot \\exp\\left[C_o \\cdot (P_b - P)\\right]\\] <p>Returns the saturated FVF unchanged if current pressure is below bubble point.</p>"},{"location":"api-reference/correlations-scalar/#compute_oil_formation_volume_factor","title":"<code>compute_oil_formation_volume_factor</code>","text":"<pre><code>compute_oil_formation_volume_factor(\n    pressure: float, temperature: float, bubble_point_pressure: float,\n    oil_specific_gravity: float, gas_gravity: float,\n    gas_to_oil_ratio: float, oil_compressibility: float\n) -&gt; float\n</code></pre> <p>Unified dispatch: uses Standing for temperatures &lt;= 100 F and Vazquez-Beggs for temperatures &gt; 100 F, then applies the above-bubble-point pressure correction. This is the function the simulator calls internally.</p>"},{"location":"api-reference/correlations-scalar/#water-formation-volume-factor","title":"Water Formation Volume Factor","text":""},{"location":"api-reference/correlations-scalar/#compute_water_formation_volume_factor","title":"<code>compute_water_formation_volume_factor</code>","text":"<pre><code>compute_water_formation_volume_factor(water_density: float, salinity: float) -&gt; float\n</code></pre> <p>Computes \\(B_w\\) as the ratio of standard water density to reservoir water density. Uses Batzle-Wang for standard conditions density.</p>"},{"location":"api-reference/correlations-scalar/#compute_water_formation_volume_factor_mccain","title":"<code>compute_water_formation_volume_factor_mccain</code>","text":"<pre><code>compute_water_formation_volume_factor_mccain(\n    pressure: float, temperature: float,\n    salinity: float = 0.0, gas_solubility: float = 0.0\n) -&gt; float\n</code></pre> <p>McCain correlation for water FVF. Accounts for temperature, pressure, salinity, and dissolved gas effects. Valid for T: 200-270 F, P: 1000-20,000 psi, salinity: 0-200,000 ppm.</p>"},{"location":"api-reference/correlations-scalar/#gas-formation-volume-factor","title":"Gas Formation Volume Factor","text":""},{"location":"api-reference/correlations-scalar/#compute_gas_formation_volume_factor","title":"<code>compute_gas_formation_volume_factor</code>","text":"<pre><code>compute_gas_formation_volume_factor(\n    pressure: float, temperature: float, gas_compressibility_factor: float\n) -&gt; float\n</code></pre> <p>Computes \\(B_g\\) in ft3/SCF using the real gas law.</p> \\[B_g = \\frac{Z \\cdot T \\cdot P_{std}}{P \\cdot T_{std}}\\] Parameter Type Unit Description <code>pressure</code> <code>float</code> psi Reservoir pressure <code>temperature</code> <code>float</code> F Reservoir temperature <code>gas_compressibility_factor</code> <code>float</code> - Z-factor (dimensionless)"},{"location":"api-reference/correlations-scalar/#gas-compressibility-factor-z-factor","title":"Gas Compressibility Factor (Z-Factor)","text":"<p>BORES provides three Z-factor correlations of increasing accuracy and computational cost. All three accept sour gas corrections via optional H2S, CO2, and N2 mole fractions using the Wichert-Aziz method.</p>"},{"location":"api-reference/correlations-scalar/#compute_gas_compressibility_factor_papay","title":"<code>compute_gas_compressibility_factor_papay</code>","text":"<pre><code>compute_gas_compressibility_factor_papay(\n    pressure: float, temperature: float, gas_gravity: float,\n    h2s_mole_fraction: float = 0.0, co2_mole_fraction: float = 0.0,\n    n2_mole_fraction: float = 0.0\n) -&gt; float\n</code></pre> <p>Papay (1985) explicit correlation. Fastest, suitable for low-pressure gas.</p> \\[Z = 1 - \\frac{3.52 \\cdot P_r \\cdot e^{-0.869 \\cdot T_r}}{T_r} + \\frac{0.274 \\cdot P_r^2}{T_r^2}\\] <p>Valid range: \\(P_r\\): 0.2-15, \\(T_r\\): 1.05-3.0, \\(\\gamma_g\\): 0.55-1.0.</p>"},{"location":"api-reference/correlations-scalar/#compute_gas_compressibility_factor_hall_yarborough","title":"<code>compute_gas_compressibility_factor_hall_yarborough</code>","text":"<pre><code>compute_gas_compressibility_factor_hall_yarborough(\n    pressure: float, temperature: float, gas_gravity: float,\n    h2s_mole_fraction: float = 0.0, co2_mole_fraction: float = 0.0,\n    n2_mole_fraction: float = 0.0,\n    max_iterations: int = 50, tolerance: float = 1e-10\n) -&gt; float\n</code></pre> <p>Hall-Yarborough (1973) implicit correlation solved with Newton-Raphson. More accurate than Papay, especially at high pressure.</p> <p>Valid range: \\(P_r\\): 0.2-30, \\(T_r\\): 1.0-3.0.</p>"},{"location":"api-reference/correlations-scalar/#compute_gas_compressibility_factor_dranchuk_abou_kassem","title":"<code>compute_gas_compressibility_factor_dranchuk_abou_kassem</code>","text":"<pre><code>compute_gas_compressibility_factor_dranchuk_abou_kassem(\n    pressure: float, temperature: float, gas_gravity: float,\n    h2s_mole_fraction: float = 0.0, co2_mole_fraction: float = 0.0,\n    n2_mole_fraction: float = 0.0,\n    max_iterations: int = 50, tolerance: float = 1e-10\n) -&gt; float\n</code></pre> <p>Dranchuk-Abou-Kassem (DAK, 1975) 11-parameter correlation. Most accurate, industry standard for high-pressure gas.</p> <p>Valid range: \\(P_r\\): 0.2-30, \\(T_r\\): 1.0-3.0.</p>"},{"location":"api-reference/correlations-scalar/#compute_gas_compressibility_factor","title":"<code>compute_gas_compressibility_factor</code>","text":"<pre><code>compute_gas_compressibility_factor(\n    pressure: float, temperature: float, gas_gravity: float,\n    h2s_mole_fraction: float = 0.0, co2_mole_fraction: float = 0.0,\n    n2_mole_fraction: float = 0.0,\n    method: GasZFactorMethod = \"dak\"\n) -&gt; float\n</code></pre> <p>Unified dispatch function. The <code>method</code> parameter accepts <code>\"papay\"</code>, <code>\"hall-yarborough\"</code>, or <code>\"dak\"</code> (default). DAK is usually sufficient for black-oil simulations.</p> <pre><code>from bores.correlations.core import compute_gas_compressibility_factor\n\nZ = compute_gas_compressibility_factor(\n    pressure=2000.0, temperature=150.0, gas_gravity=0.65, method=\"dak\"\n)\nprint(f\"Z = {Z:.4f}\")\n</code></pre>"},{"location":"api-reference/correlations-scalar/#bubble-point-pressure","title":"Bubble Point Pressure","text":""},{"location":"api-reference/correlations-scalar/#compute_oil_bubble_point_pressure","title":"<code>compute_oil_bubble_point_pressure</code>","text":"<pre><code>compute_oil_bubble_point_pressure(\n    gas_gravity: float, oil_api_gravity: float,\n    temperature: float, gas_to_oil_ratio: float\n) -&gt; float\n</code></pre> <p>Vazquez-Beggs correlation for oil bubble point pressure.</p> \\[P_b = \\left[\\frac{R_s}{C_1 \\cdot \\gamma_g \\cdot \\exp\\left(\\frac{C_3 \\cdot API}{T_R}\\right)}\\right]^{1/C_2}\\] <p>Valid for API 16-45, temperature 100-300 F, GOR up to 2000 SCF/STB.</p>"},{"location":"api-reference/correlations-scalar/#estimate_bubble_point_pressure_standing","title":"<code>estimate_bubble_point_pressure_standing</code>","text":"<pre><code>estimate_bubble_point_pressure_standing(\n    oil_api_gravity: float, gas_gravity: float, observed_gas_to_oil_ratio: float\n) -&gt; float\n</code></pre> <p>Estimates bubble point pressure by numerically inverting the Standing GOR correlation. Uses Brent's root-finding method.</p>"},{"location":"api-reference/correlations-scalar/#compute_water_bubble_point_pressure","title":"<code>compute_water_bubble_point_pressure</code>","text":"<pre><code>compute_water_bubble_point_pressure(\n    temperature: float, gas_solubility_in_water: float,\n    salinity: float = 0.0, gas: str = \"methane\"\n) -&gt; float\n</code></pre> <p>Computes the pressure at which the given gas solubility in water is reached. Uses analytical inversion for methane (McCain), numerical root-finding for other gases.</p>"},{"location":"api-reference/correlations-scalar/#compute_water_bubble_point_pressure_mccain","title":"<code>compute_water_bubble_point_pressure_mccain</code>","text":"<pre><code>compute_water_bubble_point_pressure_mccain(\n    temperature: float, gas_solubility_in_water: float, salinity: float\n) -&gt; float\n</code></pre> <p>Inverted McCain correlation for methane bubble point in water. Valid for T: 100-400 F, P: 0-14,700 psi, salinity: 0-200,000 ppm.</p>"},{"location":"api-reference/correlations-scalar/#gas-to-oil-ratio-gor","title":"Gas-to-Oil Ratio (GOR)","text":""},{"location":"api-reference/correlations-scalar/#compute_gas_to_oil_ratio","title":"<code>compute_gas_to_oil_ratio</code>","text":"<pre><code>compute_gas_to_oil_ratio(\n    pressure: float, temperature: float, bubble_point_pressure: float,\n    gas_gravity: float, oil_api_gravity: float,\n    gor_at_bubble_point_pressure: float = None\n) -&gt; float\n</code></pre> <p>Vazquez-Beggs correlation for solution GOR. Returns the GOR at bubble point for undersaturated conditions (\\(P \\geq P_b\\)) and pressure-dependent GOR for saturated conditions (\\(P &lt; P_b\\)).</p>"},{"location":"api-reference/correlations-scalar/#compute_gas_to_oil_ratio_standing","title":"<code>compute_gas_to_oil_ratio_standing</code>","text":"<pre><code>compute_gas_to_oil_ratio_standing(\n    pressure: float, oil_api_gravity: float, gas_gravity: float\n) -&gt; float\n</code></pre> <p>Standing correlation for solution GOR. Simplified form that does not require temperature.</p> \\[R_s = \\gamma_g \\cdot \\left[\\left(\\frac{P}{18.2} + 1.4\\right) \\cdot 10^{0.0125 \\cdot API}\\right]^{1/1.2048}\\]"},{"location":"api-reference/correlations-scalar/#estimate_solution_gor","title":"<code>estimate_solution_gor</code>","text":"<pre><code>estimate_solution_gor(\n    pressure: float, temperature: float, oil_api_gravity: float, gas_gravity: float,\n    max_iterations: int = 20, tolerance: float = 1e-4\n) -&gt; float\n</code></pre> <p>Iterative estimation of solution GOR that solves the coupled system where GOR depends on pressure and bubble point, and bubble point depends on GOR and temperature. Handles both saturated and undersaturated conditions automatically.</p>"},{"location":"api-reference/correlations-scalar/#oil-viscosity","title":"Oil Viscosity","text":""},{"location":"api-reference/correlations-scalar/#compute_dead_oil_viscosity_modified_beggs","title":"<code>compute_dead_oil_viscosity_modified_beggs</code>","text":"<pre><code>compute_dead_oil_viscosity_modified_beggs(\n    temperature: float, oil_specific_gravity: float\n) -&gt; float\n</code></pre> <p>Modified Beggs correlation (Labedi, 1992) for dead oil viscosity. Valid for API 5-75.</p> \\[\\log_{10}(\\mu_{od} + 1) = 1.8653 - 0.025086 \\cdot \\gamma_o - 0.5644 \\cdot \\log_{10}(T_R)\\]"},{"location":"api-reference/correlations-scalar/#compute_oil_viscosity","title":"<code>compute_oil_viscosity</code>","text":"<pre><code>compute_oil_viscosity(\n    pressure: float, temperature: float, bubble_point_pressure: float,\n    oil_specific_gravity: float, gas_to_oil_ratio: float,\n    gor_at_bubble_point_pressure: float\n) -&gt; float\n</code></pre> <p>Full oil viscosity calculation using Modified Beggs and Robinson. Computes dead oil viscosity first, then applies saturated or undersaturated corrections depending on whether the pressure is above or below the bubble point.</p> <p>Saturated (\\(P \\leq P_b\\)):</p> \\[\\mu_o = X \\cdot \\mu_{od}^Y \\qquad X = 10.715 \\cdot (R_s + 100)^{-0.515} \\qquad Y = 5.44 \\cdot (R_s + 150)^{-0.338}\\] <p>Undersaturated (\\(P &gt; P_b\\)):</p> \\[\\mu_o = \\mu_{ob} \\cdot \\left(\\frac{P}{P_b}\\right)^{X_{under}}\\]"},{"location":"api-reference/correlations-scalar/#gas-properties","title":"Gas Properties","text":""},{"location":"api-reference/correlations-scalar/#compute_gas_molecular_weight","title":"<code>compute_gas_molecular_weight</code>","text":"<pre><code>compute_gas_molecular_weight(gas_gravity: float) -&gt; float\n</code></pre> <p>Returns apparent molecular weight: \\(MW = \\gamma_g \\times 28.96\\) g/mol.</p>"},{"location":"api-reference/correlations-scalar/#compute_gas_pseudocritical_properties","title":"<code>compute_gas_pseudocritical_properties</code>","text":"<pre><code>compute_gas_pseudocritical_properties(\n    gas_gravity: float, h2s_mole_fraction: float = 0.0,\n    co2_mole_fraction: float = 0.0, n2_mole_fraction: float = 0.0\n) -&gt; tuple[float, float]\n</code></pre> <p>Sutton's correlation for pseudocritical pressure and temperature, with Wichert-Aziz correction for sour gases. Returns \\((P_{pc}, T_{pc})\\) in psi and Rankine.</p>"},{"location":"api-reference/correlations-scalar/#compute_gas_density","title":"<code>compute_gas_density</code>","text":"<pre><code>compute_gas_density(\n    pressure: float, temperature: float,\n    gas_gravity: float, gas_compressibility_factor: float\n) -&gt; float\n</code></pre> <p>Real gas equation of state density in lbm/ft3.</p>"},{"location":"api-reference/correlations-scalar/#compute_gas_viscosity","title":"<code>compute_gas_viscosity</code>","text":"<pre><code>compute_gas_viscosity(\n    temperature: float, gas_density: float, gas_molecular_weight: float\n) -&gt; float\n</code></pre> <p>Lee-Gonzalez-Eakin (LGE) correlation for gas viscosity in cP. Valid for T: 100-400 F, P up to 10,000 psi.</p> \\[\\mu_g = (k \\times 10^{-4}) \\cdot \\exp(x \\cdot \\rho_g^y)\\]"},{"location":"api-reference/correlations-scalar/#water-properties","title":"Water Properties","text":""},{"location":"api-reference/correlations-scalar/#compute_water_viscosity","title":"<code>compute_water_viscosity</code>","text":"<pre><code>compute_water_viscosity(\n    temperature: float, salinity: float = 0.0, pressure: float = 14.7\n) -&gt; float\n</code></pre> <p>McCain correlation for water viscosity in cP, corrected for salinity and pressure. Valid for T: 86-350 F, salinity up to 300,000 ppm, pressure up to 10,000 psi.</p>"},{"location":"api-reference/correlations-scalar/#compute_water_density","title":"<code>compute_water_density</code>","text":"<pre><code>compute_water_density(\n    pressure: float, temperature: float, gas_gravity: float = 0.0,\n    salinity: float = 0.0, gas_solubility_in_water: float = 0.0,\n    gas_free_water_formation_volume_factor: float = 1.0\n) -&gt; float\n</code></pre> <p>Live water density at reservoir conditions using McCain's mass balance approach. Accounts for dissolved gas and salinity.</p>"},{"location":"api-reference/correlations-scalar/#compute_water_density_mccain","title":"<code>compute_water_density_mccain</code>","text":"<pre><code>compute_water_density_mccain(\n    pressure: float, temperature: float, salinity: float = 0.0\n) -&gt; float\n</code></pre> <p>McCain correlation for brine density in lbm/ft3.</p>"},{"location":"api-reference/correlations-scalar/#compute_water_density_batzle","title":"<code>compute_water_density_batzle</code>","text":"<pre><code>compute_water_density_batzle(\n    pressure: float, temperature: float, salinity: float\n) -&gt; float\n</code></pre> <p>Batzle and Wang (1992) correlation. More accurate at high temperature and pressure conditions.</p>"},{"location":"api-reference/correlations-scalar/#compressibility","title":"Compressibility","text":""},{"location":"api-reference/correlations-scalar/#compute_oil_compressibility","title":"<code>compute_oil_compressibility</code>","text":"<pre><code>compute_oil_compressibility(\n    pressure: float, temperature: float, bubble_point_pressure: float,\n    oil_api_gravity: float, gas_gravity: float, gor_at_bubble_point_pressure: float,\n    gas_formation_volume_factor: float = 1.0, oil_formation_volume_factor: float = 1.0\n) -&gt; float\n</code></pre> <p>Vasquez and Beggs (1980) correlation for oil compressibility in psi-1. For undersaturated oil (\\(P &gt; P_b\\)), uses the standard correlation. For saturated oil (\\(P \\leq P_b\\)), adds a gas liberation correction term.</p> <p>Valid for P: 100-5,000 psi, T: 100-300 F, API: 16-58.</p>"},{"location":"api-reference/correlations-scalar/#compute_gas_compressibility","title":"<code>compute_gas_compressibility</code>","text":"<pre><code>compute_gas_compressibility(\n    pressure: float, temperature: float, gas_gravity: float,\n    gas_compressibility_factor: float = None,\n    h2s_mole_fraction: float = 0.0, co2_mole_fraction: float = 0.0,\n    n2_mole_fraction: float = 0.0\n) -&gt; float\n</code></pre> <p>Isothermal gas compressibility in psi-1 using Papay's analytical derivative.</p> \\[C_g = \\frac{1}{P} - \\frac{1}{Z \\cdot P_{pc}} \\cdot \\frac{dZ}{dP_r}\\]"},{"location":"api-reference/correlations-scalar/#compute_water_compressibility","title":"<code>compute_water_compressibility</code>","text":"<pre><code>compute_water_compressibility(\n    pressure: float, temperature: float, bubble_point_pressure: float,\n    gas_formation_volume_factor: float, gas_solubility_in_water: float,\n    gas_free_water_formation_volume_factor: float, salinity: float = 0.0\n) -&gt; float\n</code></pre> <p>McCain correlation for water compressibility in psi-1. Handles both undersaturated (\\(P \\geq P_{wb}\\)) and saturated (\\(P &lt; P_{wb}\\)) water conditions.</p>"},{"location":"api-reference/correlations-scalar/#compute_total_fluid_compressibility","title":"<code>compute_total_fluid_compressibility</code>","text":"<pre><code>compute_total_fluid_compressibility(\n    water_saturation: float, oil_saturation: float,\n    water_compressibility: float, oil_compressibility: float,\n    gas_saturation: float = None, gas_compressibility: float = None\n) -&gt; float\n</code></pre> <p>Saturation-weighted average of phase compressibilities. Optionally includes gas phase for three-phase systems.</p>"},{"location":"api-reference/correlations-scalar/#gas-solubility-in-water","title":"Gas Solubility in Water","text":""},{"location":"api-reference/correlations-scalar/#compute_gas_solubility_in_water","title":"<code>compute_gas_solubility_in_water</code>","text":"<pre><code>compute_gas_solubility_in_water(\n    pressure: float, temperature: float,\n    salinity: float = 0.0, gas: str = \"methane\"\n) -&gt; float\n</code></pre> <p>Computes gas solubility in water in SCF/STB. Automatically selects the best correlation based on gas type and temperature:</p> <ul> <li>Methane (100-400 F): McCain correlation</li> <li>CO2 (32-572 F): Duan and Sun correlation</li> <li>Other gases (N2, Ar, O2, He, H2): Henry's law with Setschenow salinity correction</li> </ul>"},{"location":"api-reference/correlations-scalar/#compute_gas_free_water_formation_volume_factor","title":"<code>compute_gas_free_water_formation_volume_factor</code>","text":"<pre><code>compute_gas_free_water_formation_volume_factor(\n    pressure: float, temperature: float\n) -&gt; float\n</code></pre> <p>McCain correlation for gas-free water FVF (\\(B_{w,gas-free}\\)) in bbl/STB. Accounts for thermal expansion and isothermal compressibility without dissolved gas effects.</p>"},{"location":"api-reference/correlations-scalar/#oil-and-water-density","title":"Oil and Water Density","text":""},{"location":"api-reference/correlations-scalar/#compute_live_oil_density","title":"<code>compute_live_oil_density</code>","text":"<pre><code>compute_live_oil_density(\n    api_gravity: float, gas_gravity: float,\n    gas_to_oil_ratio: float, formation_volume_factor: float\n) -&gt; float\n</code></pre> <p>Mass balance approach for live oil density in lbm/ft3. Accounts for stock tank oil mass, dissolved gas mass, and volume expansion via FVF.</p>"},{"location":"api-reference/correlations-scalar/#volumetrics","title":"Volumetrics","text":""},{"location":"api-reference/correlations-scalar/#compute_hydrocarbon_in_place","title":"<code>compute_hydrocarbon_in_place</code>","text":"<pre><code>compute_hydrocarbon_in_place(\n    area: float, thickness: float, porosity: float, phase_saturation: float,\n    formation_volume_factor: float, net_to_gross_ratio: float = 1.0,\n    hydrocarbon_type: str = \"oil\",\n    acre_ft_to_bbl: float = 7758.0, acre_ft_to_ft3: float = 43560.0\n) -&gt; float\n</code></pre> <p>Volumetric method for original hydrocarbons in place. For oil, returns STB. For gas, returns SCF. For water, returns STB.</p> \\[OIP = 7758 \\cdot A \\cdot h \\cdot \\phi \\cdot S_o \\cdot (N/G) / B_o\\] \\[GIP = 43560 \\cdot A \\cdot h \\cdot \\phi \\cdot S_g \\cdot (N/G) / B_g\\]"},{"location":"api-reference/correlations-scalar/#miscible-flooding-todd-longstaff","title":"Miscible Flooding (Todd-Longstaff)","text":"<p>These functions implement the Todd-Longstaff (1972) mixing model for miscible gas flooding. They compute effective viscosity and density of oil-solvent mixtures based on a mixing parameter \\(\\omega\\) that interpolates between fully segregated (immiscible) and fully mixed (miscible) flow behavior.</p>"},{"location":"api-reference/correlations-scalar/#compute_miscibility_transition_factor","title":"<code>compute_miscibility_transition_factor</code>","text":"<pre><code>compute_miscibility_transition_factor(\n    pressure: float, minimum_miscibility_pressure: float,\n    transition_width: float = 500.0\n) -&gt; float\n</code></pre> <p>Smooth pressure-dependent transition from 0 (immiscible) to 1 (fully miscible) using hyperbolic tangent.</p> \\[f(P) = 0.5 \\cdot \\left(1 + \\tanh\\left(\\frac{P - MMP}{\\Delta P}\\right)\\right)\\]"},{"location":"api-reference/correlations-scalar/#compute_effective_todd_longstaff_omega","title":"<code>compute_effective_todd_longstaff_omega</code>","text":"<pre><code>compute_effective_todd_longstaff_omega(\n    pressure: float, base_omega: float,\n    minimum_miscibility_pressure: float, transition_width: float = 500.0\n) -&gt; float\n</code></pre> <p>Combines the base mixing parameter with the pressure-dependent transition factor: \\(\\omega_{eff} = \\omega_{base} \\cdot f(P)\\).</p>"},{"location":"api-reference/correlations-scalar/#compute_todd_longstaff_effective_viscosity","title":"<code>compute_todd_longstaff_effective_viscosity</code>","text":"<pre><code>compute_todd_longstaff_effective_viscosity(\n    oil_viscosity: float, solvent_viscosity: float,\n    solvent_concentration: float, omega: float = 0.67\n) -&gt; float\n</code></pre> <p>Todd-Longstaff effective viscosity for oil-solvent mixtures.</p> \\[\\mu_{eff} = \\mu_{mix}^\\omega \\cdot \\mu_{seg}^{1-\\omega}\\] <p>where \\(\\mu_{mix}\\) is the arithmetic mean (fully mixed) and \\(\\mu_{seg}\\) is the harmonic mean (fully segregated).</p> \\(\\omega\\) Behavior Viscosity Model 0.0 Fully segregated (immiscible) Harmonic mean 0.5 Partial mixing Geometric mean 0.67 Typical for CO2 floods Todd-Longstaff interpolation 1.0 Fully mixed (miscible) Arithmetic mean"},{"location":"api-reference/correlations-scalar/#compute_todd_longstaff_effective_density","title":"<code>compute_todd_longstaff_effective_density</code>","text":"<pre><code>compute_todd_longstaff_effective_density(\n    oil_density: float, solvent_density: float,\n    oil_viscosity: float, solvent_viscosity: float,\n    solvent_concentration: float = 1.0, omega: float = 0.67\n) -&gt; float\n</code></pre> <p>Analogous to the viscosity function but for density mixing.</p>"},{"location":"api-reference/correlations-scalar/#miscellaneous","title":"Miscellaneous","text":""},{"location":"api-reference/correlations-scalar/#compute_harmonic_mean","title":"<code>compute_harmonic_mean</code>","text":"<pre><code>compute_harmonic_mean(value1: float, value2: float) -&gt; float\n</code></pre> <p>Computes the harmonic mean of two values: \\(\\frac{2 \\cdot v_1 \\cdot v_2}{v_1 + v_2}\\). Used internally for transmissibility calculations. Returns 0 if both values are zero.</p>"},{"location":"api-reference/full-api/","title":"Full API Reference","text":""},{"location":"api-reference/full-api/#overview","title":"Overview","text":"<p>This page lists every class, function, constant, and type exported from the <code>bores</code> package. Everything listed here is importable directly from <code>bores</code> (for example, <code>from bores import Config</code> or <code>import bores; bores.Config</code>). The API is organized by functional area to help you find what you need quickly.</p> <p>The <code>bores</code> package uses wildcard re-exports from its internal modules. This means you never need to import from internal paths like <code>bores.wells.controls</code> or <code>bores.diffusivity.base</code>. Everything public is available at the top level. The only exception is the array PVT correlations, which must be imported from <code>bores.correlations.arrays</code> explicitly, and the visualization submodules (<code>bores.visualization.plotly1d</code>, <code>bores.visualization.plotly2d</code>, <code>bores.visualization.plotly3d</code>) which you can import by name for direct renderer access.</p> <p>For detailed documentation of individual items, see the relevant sections in the User Guide and Tutorials. For PVT correlation functions specifically, see the Scalar Correlations and Array Correlations pages.</p>"},{"location":"api-reference/full-api/#model-construction","title":"Model Construction","text":"<p>These are the main entry points for building reservoir models and wells. The factory functions handle PVT correlation computation, grid validation, and internal object construction for you.</p>"},{"location":"api-reference/full-api/#factory-functions","title":"Factory Functions","text":"Name Type Description <code>reservoir_model()</code> function Build a <code>ReservoirModel</code> from raw grid data, fluid properties, and rock properties. Computes all derived PVT grids internally. <code>injection_well()</code> function Build an <code>InjectionWell</code> with fluid, control, perforations, and schedule. <code>production_well()</code> function Build a <code>ProductionWell</code> with fluid, control, perforations, and schedule. <code>wells_()</code> function Combine multiple wells into a <code>Wells</code> collection for use in <code>Config</code>. <pre><code>import bores\n\nmodel = bores.reservoir_model(\n    grid_dimensions=(10, 10, 3),\n    grid_sizes=(100.0, 100.0, 20.0),\n    porosity=0.20,\n    permeability_x=100.0,\n    oil_api_gravity=35.0,\n    gas_gravity=0.70,\n    initial_pressure=3000.0,\n    temperature=200.0,\n    water_saturation_grid=Sw,\n    oil_saturation_grid=So,\n    gas_saturation_grid=Sg,\n)\n</code></pre>"},{"location":"api-reference/full-api/#core-data-models","title":"Core Data Models","text":"Name Type Description <code>ReservoirModel</code> class Immutable model holding all grid data, fluid properties, rock properties, and saturation state. Generic over <code>NDimension</code>. <code>FluidProperties</code> class Oil, gas, and water PVT properties at reservoir conditions. <code>RockProperties</code> class Porosity, permeability, and compressibility. <code>RockPermeability</code> class Directional permeability (kx, ky, kz). <code>SaturationHistory</code> class Historical saturation data for hysteresis tracking. <p>All data model classes are frozen <code>attrs</code> classes. You modify them using <code>attrs.evolve()</code> to create new instances with changed fields.</p>"},{"location":"api-reference/full-api/#simulation","title":"Simulation","text":"<p>These classes and functions control how simulations are configured and executed.</p>"},{"location":"api-reference/full-api/#configuration-and-execution","title":"Configuration and Execution","text":"Name Type Description <code>Config</code> class Frozen configuration holding timer, wells, boundary conditions, solvers, convergence parameters, evolution scheme, and rock-fluid tables. <code>Run</code> class Orchestrates the simulation loop. Yields <code>StepResult</code> objects per timestep. <code>run()</code> function Convenience function to create and start a <code>Run</code>. Returns a generator of step results. <pre><code>config = bores.Config(\n    timer=bores.Timer(end=365.0, initial_time_step=1.0),\n    wells=wells,\n    evolution_scheme=bores.EvolutionScheme.IMPES,\n)\n\nsimulation = bores.run(model=model, config=config)\nfor step in simulation:\n    print(f\"Day {step.time:.1f}, Pressure: {step.pressure.mean():.1f} psi\")\n</code></pre>"},{"location":"api-reference/full-api/#time-management","title":"Time Management","text":"Name Type Description <code>Timer</code> class Simulation timer with start, end, and adaptive timestep control. <code>Time()</code> function Create a <code>Timer</code> instance (convenience constructor). <code>TimerState</code> class Current state of the timer during simulation (current time, step count, dt)."},{"location":"api-reference/full-api/#model-state","title":"Model State","text":"Name Type Description <code>ModelState</code> class Snapshot of the model at a single timestep: pressure, saturations, rates, and well data. <code>validate_state()</code> function Validate that a <code>ModelState</code> is physically consistent (saturations sum to 1, pressures positive, etc.)."},{"location":"api-reference/full-api/#wells","title":"Wells","text":"<p>Well types, fluid definitions, controls, and scheduling are all available at the top level.</p>"},{"location":"api-reference/full-api/#well-types","title":"Well Types","text":"Name Type Description <code>Well</code> class Base well class. Generic over coordinates and fluid type. <code>InjectionWell</code> type alias <code>Well</code> specialized for injection with <code>InjectedFluid</code>. <code>ProductionWell</code> type alias <code>Well</code> specialized for production with <code>ProducedFluid</code>. <code>Wells</code> type alias Collection type for multiple wells (used in <code>Config</code>). <code>well_type()</code> function Return the type of a well (\"injection\" or \"production\")."},{"location":"api-reference/full-api/#well-fluids","title":"Well Fluids","text":"Name Type Description <code>WellFluid</code> class Base class for well fluid definitions. <code>InjectedFluid</code> class Fluid being injected (phase, gravity, molecular weight, optional miscibility parameters, optional density/viscosity overrides). <code>ProducedFluid</code> class Fluid being produced (typically just the phase)."},{"location":"api-reference/full-api/#well-rate-computation","title":"Well Rate Computation","text":"Name Type Description <code>compute_well_index()</code> function Compute Peaceman well index from permeability, thickness, radii, and skin. <code>compute_oil_well_rate()</code> function Compute oil production rate from well index, pressures, and mobility. <code>compute_gas_well_rate()</code> function Compute gas production rate from well index, pressures, and mobility. <code>compute_required_bhp_for_oil_rate()</code> function Back-calculate BHP needed to achieve a target oil rate. <code>compute_required_bhp_for_gas_rate()</code> function Back-calculate BHP needed to achieve a target gas rate. <code>compute_2D_effective_drainage_radius()</code> function Effective drainage radius for 2D grids. <code>compute_3D_effective_drainage_radius()</code> function Effective drainage radius for 3D grids."},{"location":"api-reference/full-api/#well-controls","title":"Well Controls","text":"Name Type Description <code>WellControl</code> protocol Base protocol for all well control strategies. <code>BHPControl</code> class Constant bottom-hole pressure control. <code>ConstantRateControl</code> class Constant surface rate control with optional BHP limit. <code>PrimaryPhaseRateControl</code> class Rate control on the primary phase with BHP fallback. <code>MultiPhaseRateControl</code> class Control targeting total liquid or total fluid rate. <code>AdaptiveBHPRateControl</code> class Starts with rate control, switches to BHP when the rate target cannot be met. <code>well_control()</code> function Factory to create a well control from a string name and parameters."},{"location":"api-reference/full-api/#rate-clamping","title":"Rate Clamping","text":"Name Type Description <code>RateClamp</code> protocol Base protocol for rate clamping strategies. <code>ProductionClamp</code> class Clamp that limits production rate to a maximum. <code>InjectionClamp</code> class Clamp that limits injection rate to a maximum. <code>rate_clamp()</code> function Factory to create a rate clamp from parameters."},{"location":"api-reference/full-api/#well-scheduling","title":"Well Scheduling","text":"Name Type Description <code>WellSchedule</code> class Schedule of events for a single well. <code>WellSchedules</code> class Collection of schedules for multiple wells. <code>WellEvent</code> class A scheduled event (predicate + action pair). <code>EventPredicate</code> class Condition that triggers an event. <code>EventPredicates</code> class Collection of predicates (any/all logic). <code>EventAction</code> class Action to take when an event triggers. <code>EventActions</code> class Collection of actions to execute together. <code>event_predicate()</code> function Factory to create an event predicate from a callable. <code>event_action()</code> function Factory to create an event action from a callable. <code>time_predicate()</code> function Create a predicate that triggers at a specific simulation time. <code>update_well()</code> function Create an action that modifies well parameters at runtime."},{"location":"api-reference/full-api/#grid-construction","title":"Grid Construction","text":"<p>Functions for building the spatial grids that represent reservoir geometry and initial conditions.</p>"},{"location":"api-reference/full-api/#grid-builders","title":"Grid Builders","text":"Name Type Description <code>build_uniform_grid()</code> function Create a uniform-valued grid of a given shape and value. <code>build_depth_grid()</code> function Build a depth grid from layer thicknesses and a datum depth. <code>build_elevation_grid()</code> function Build an elevation grid (increasing upward, opposite of depth). <code>build_layered_grid()</code> function Build a grid with different values per layer (for heterogeneous properties). <code>build_saturation_grids()</code> function Build physically consistent three-phase saturation grids from fluid contact depths (GOC, OWC), depth grid, and residual saturations."},{"location":"api-reference/full-api/#grid-aliases","title":"Grid Aliases","text":"<p>These are aliases that call the same underlying functions. Prefer the <code>build_*</code> versions.</p> Name Type Description <code>uniform_grid()</code> function Alias for <code>build_uniform_grid()</code>. <code>depth_grid()</code> function Alias for <code>build_depth_grid()</code>. <code>elevation_grid()</code> function Alias for <code>build_elevation_grid()</code>. <code>layered_grid()</code> function Alias for <code>build_layered_grid()</code>. <code>array()</code> function Alias for creating a grid array with the current precision dtype."},{"location":"api-reference/full-api/#grid-operations","title":"Grid Operations","text":"Name Type Description <code>pad_grid()</code> function Add ghost cells around a grid for boundary condition handling. <code>unpad_grid()</code> function Remove ghost cells from a padded grid. <code>get_pad_mask()</code> function Get a boolean mask indicating which cells are ghost cells. <code>coarsen_grid()</code> function Reduce grid resolution by averaging cells. <code>coarsen_permeability_grids()</code> function Coarsen permeability grids using harmonic averaging (correct for flow). <code>flatten_multilayer_grid_to_surface()</code> function Collapse a 3D grid to a 2D surface map (e.g., for visualization). <code>apply_structural_dip()</code> function Apply a structural dip angle to a depth grid."},{"location":"api-reference/full-api/#grid-data-containers","title":"Grid Data Containers","text":"Name Type Description <code>CapillaryPressureGrids</code> class Container for oil-water and gas-oil capillary pressure grids. <code>RateGrids</code> class Container for per-cell rate grids (oil, water, gas). <code>RelativeMobilityGrids</code> class Container for relative mobility grids used in flow calculations."},{"location":"api-reference/full-api/#rock-fluid-properties","title":"Rock-Fluid Properties","text":"<p>Models for relative permeability and capillary pressure.</p>"},{"location":"api-reference/full-api/#relative-permeability-models","title":"Relative Permeability Models","text":"Name Type Description <code>BrooksCoreyThreePhaseRelPermModel</code> class Three-phase relative permeability using Brooks-Corey (Corey) exponents for oil, water, and gas. <code>TwoPhaseRelPermTable</code> class Tabular two-phase relative permeability (oil-water or gas-oil). <code>ThreePhaseRelPermTable</code> class Tabular three-phase relative permeability."},{"location":"api-reference/full-api/#relative-permeability-table-registry","title":"Relative Permeability Table Registry","text":"Name Type Description <code>relperm_table()</code> decorator Register a custom relative permeability table function. <code>get_relperm_table()</code> function Retrieve a registered relative permeability table by name. <code>list_relperm_tables()</code> function List all registered relative permeability table names."},{"location":"api-reference/full-api/#three-phase-mixing-rules","title":"Three-Phase Mixing Rules","text":"<p>These functions compute oil relative permeability in three-phase flow from two-phase (oil-water and gas-oil) curves.</p> Name Type Description <code>mixing_rule()</code> decorator Register a custom three-phase mixing rule. <code>stone_I_rule()</code> function Stone's first model. <code>stone_II_rule()</code> function Stone's second model. <code>baker_linear_rule()</code> function Baker's linear interpolation. <code>eclipse_rule()</code> function Eclipse-style modified Stone I. <code>blunt_rule()</code> function Blunt's saturation-weighted model. <code>arithmetic_mean_rule()</code> function Simple arithmetic average. <code>geometric_mean_rule()</code> function Geometric average. <code>harmonic_mean_rule()</code> function Harmonic average. <code>max_rule()</code> function Maximum of oil-water and gas-oil curves. <code>min_rule()</code> function Minimum of oil-water and gas-oil curves. <code>aziz_settari_rule()</code> function Aziz and Settari's model. <code>hustad_hansen_rule()</code> function Hustad-Hansen model. <code>linear_interpolation_rule()</code> function Linear interpolation between two-phase curves. <code>saturation_weighted_interpolation_rule()</code> function Saturation-weighted interpolation. <code>product_saturation_weighted_rule()</code> function Product of saturation-weighted curves. <code>compute_corey_three_phase_relative_permeabilities()</code> function Compute all three-phase kr values from Corey parameters directly."},{"location":"api-reference/full-api/#capillary-pressure-models","title":"Capillary Pressure Models","text":"Name Type Description <code>BrooksCoreyCapillaryPressureModel</code> class Brooks-Corey capillary pressure model with entry pressure and pore-size distribution index. <code>LeverettJCapillaryPressureModel</code> class Leverett J-function scaling for capillary pressure from dimensionless J(Sw). <code>VanGenuchtenCapillaryPressureModel</code> class Van Genuchten model for capillary pressure (common in soil science and unconventional reservoirs). <code>TwoPhaseCapillaryPressureTable</code> class Tabular two-phase capillary pressure (oil-water or gas-oil). <code>ThreePhaseCapillaryPressureTable</code> class Tabular three-phase capillary pressure. <code>capillary_pressure_table()</code> decorator Register a custom capillary pressure table function."},{"location":"api-reference/full-api/#pvt-tables","title":"PVT Tables","text":"<p>Tabular property lookup as an alternative to correlations.</p> Name Type Description <code>PVTTables</code> class Container for pressure-dependent PVT lookup tables (Bo, Bg, Bw, Rs, viscosities, densities, compressibilities). Supports linear and cubic interpolation. <code>PVTTableData</code> class Single PVT property table: pressure array and corresponding property values. <code>build_pvt_table_data()</code> function Build a <code>PVTTableData</code> from pressure and value arrays with validation. <code>RockFluidTables</code> class Container for relative permeability and capillary pressure tables, used in <code>Config</code>. <code>GasPseudoPressureTable</code> class Al-Hussainy real-gas pseudo-pressure lookup table for gas well deliverability calculations. <code>build_gas_pseudo_pressure_table()</code> function Build a pseudo-pressure table from gas properties over a pressure range."},{"location":"api-reference/full-api/#boundary-conditions","title":"Boundary Conditions","text":"<p>Types for specifying reservoir boundary behavior.</p>"},{"location":"api-reference/full-api/#boundary-classes","title":"Boundary Classes","text":"Name Type Description <code>Boundary</code> protocol Base protocol for all boundary types. <code>BoundaryCondition</code> class A boundary condition applied to a specific face or region. <code>BoundaryConditions</code> class Collection of boundary conditions for all faces of the grid. <code>GridBoundaryCondition</code> class Boundary condition applied to the grid with face and type specification. Validates periodic boundary pairing. <code>BoundaryMetadata</code> class Metadata about a boundary (face, type, parameters)."},{"location":"api-reference/full-api/#boundary-types","title":"Boundary Types","text":"Name Type Description <code>NoFlowBoundary</code> class Zero-flux boundary (default for all faces). <code>ConstantBoundary</code> class Constant value (Dirichlet) boundary. <code>DirichletBoundary</code> class Alias for constant-value boundary. <code>NeumannBoundary</code> class Constant flux boundary. <code>FluxBoundary</code> class Specified flux boundary (positive = injection, negative = production). <code>RobinBoundary</code> class Mixed boundary combining value and flux conditions. <code>PeriodicBoundary</code> class Periodic boundary connecting opposite faces. <code>LinearGradientBoundary</code> class Linearly varying boundary value across a face. <code>SpatialBoundary</code> class Spatially varying boundary specified by a function. <code>TimeDependentBoundary</code> class Time-varying boundary condition. <code>VariableBoundary</code> class Boundary that changes based on simulation state. <code>ParameterizedBoundaryFunction</code> class Boundary defined by a parameterized function."},{"location":"api-reference/full-api/#aquifer-support","title":"Aquifer Support","text":"Name Type Description <code>CarterTracyAquifer</code> class Carter-Tracy analytical aquifer model with Van Everdingen-Hurst dimensionless influx. Supports physical properties mode and calibrated constant mode. <code>boundary_function()</code> decorator Register a custom boundary function."},{"location":"api-reference/full-api/#faults-and-fractures","title":"Faults and Fractures","text":"Name Type Description <code>Fracture</code> class A fault or fracture defined by geometry and transmissibility modification. <code>FractureGeometry</code> class Geometric specification of a fracture (orientation, extent, position). <code>apply_fracture()</code> function Apply a single fracture to a transmissibility grid. <code>apply_fractures()</code> function Apply multiple fractures to a transmissibility grid. <code>vertical_sealing_fault()</code> function Factory for a vertical sealing fault (zero transmissibility). <code>inclined_sealing_fault()</code> function Factory for an inclined sealing fault. <code>damage_zone_fault()</code> function Factory for a fault with an enhanced-permeability damage zone. <code>conductive_fracture_network()</code> function Factory for a network of conductive fractures. <code>validate_fracture()</code> function Validate fracture geometry against the grid dimensions."},{"location":"api-reference/full-api/#solvers-and-preconditioners","title":"Solvers and Preconditioners","text":"<p>Linear solver and preconditioner infrastructure for the pressure equation.</p>"},{"location":"api-reference/full-api/#solvers","title":"Solvers","text":"Name Type Description <code>solve_linear_system()</code> function Solve a sparse linear system using the configured solver and preconditioner. <code>solver_func()</code> decorator Register a custom solver function. <code>get_solver_func()</code> function Retrieve a registered solver by name. <code>list_solver_funcs()</code> function List all registered solver names."},{"location":"api-reference/full-api/#preconditioners","title":"Preconditioners","text":"Name Type Description <code>CachedPreconditionerFactory</code> class Wraps a preconditioner factory with caching to avoid rebuilding every timestep. <code>preconditioner_factory()</code> decorator Register a custom preconditioner factory. <code>get_preconditioner_factory()</code> function Retrieve a registered preconditioner factory by name. <code>list_preconditioner_factories()</code> function List all registered preconditioner factory names. <code>build_ilu_preconditioner()</code> function Build an ILU(0) preconditioner. <code>build_amg_preconditioner()</code> function Build an algebraic multigrid preconditioner. <code>build_diagonal_preconditioner()</code> function Build a Jacobi (diagonal) preconditioner. <code>build_block_jacobi_preconditioner()</code> function Build a block Jacobi preconditioner. <code>build_polynomial_preconditioner()</code> function Build a polynomial preconditioner. <code>build_cpr_preconditioner()</code> function Build a constrained pressure residual (CPR) preconditioner."},{"location":"api-reference/full-api/#evolution-internals","title":"Evolution Internals","text":"Name Type Description <code>EvolutionResult</code> class Result of a single evolution step (pressure/saturation update). <code>to_1D_index_interior_only()</code> function Convert 3D grid indices to 1D indices for the interior cells (excluding ghost cells). <code>from_1D_index_interior_only()</code> function Convert 1D interior-only indices back to 3D grid indices."},{"location":"api-reference/full-api/#analysis","title":"Analysis","text":"Name Type Description <code>ModelAnalyst</code> class Post-simulation analysis engine. Computes recovery factors, production profiles, front tracking, mobility ratios, sweep efficiency, and more from stored simulation results. <p>See the Model Analysis page for detailed usage.</p>"},{"location":"api-reference/full-api/#data-streaming-and-storage","title":"Data Streaming and Storage","text":""},{"location":"api-reference/full-api/#streaming","title":"Streaming","text":"Name Type Description <code>StateStream</code> class Wraps a simulation generator and streams state snapshots to a storage backend. Supports checkpointing and resume. <code>StreamProgress</code> class Progress statistics (yield count, saved count, checkpoints)."},{"location":"api-reference/full-api/#storage-backends","title":"Storage Backends","text":"Name Type Description <code>HDF5Store</code> class HDF5 file storage backend (recommended for large simulations). <code>ZarrStore</code> class Zarr storage backend (supports cloud storage and parallel I/O). <code>JSONStore</code> class JSON file storage backend (human-readable, small simulations only). <code>YAMLStore</code> class YAML file storage backend (human-readable, small simulations only). <code>new_store()</code> function Create a new store from a file path (auto-detects backend from extension). <code>storage_backend()</code> decorator Register a custom storage backend."},{"location":"api-reference/full-api/#serialization","title":"Serialization","text":"<p>The serialization system provides dictionary-based round-tripping for all BORES objects.</p> Name Type Description <code>Serializable</code> class Base mixin that adds <code>to_dict()</code> and <code>from_dict()</code> methods to any attrs class. <code>converter</code> object The cattrs converter instance configured with all BORES type hooks. <code>dump()</code> function Serialize any <code>Serializable</code> object to a dictionary. <code>load()</code> function Deserialize a dictionary back into the original object type."},{"location":"api-reference/full-api/#visualization","title":"Visualization","text":"<p>The visualization system provides Plotly-based plotting for 1D time series, 2D maps, and 3D volume rendering.</p>"},{"location":"api-reference/full-api/#core-visualization","title":"Core Visualization","text":"Name Type Description <code>ColorScheme</code> enum Available color schemes for visualizations (includes colorblind-friendly options). <code>ColorbarConfig</code> class Configuration for colorbars (label, range, position). <code>ColorbarPresets</code> class Pre-built colorbar configurations for common reservoir properties. <code>PropertyMeta</code> class Metadata about a reservoir property (name, unit, colormap). <code>PropertyRegistry</code> class Registry of known reservoir properties and their visualization defaults. <code>property_registry</code> object The global property registry instance. <code>image_config()</code> function Configure image export settings (format, resolution). <code>merge_plots()</code> function Combine multiple Plotly figures into a single figure with subplots."},{"location":"api-reference/full-api/#1d-plotting","title":"1D Plotting","text":"Name Type Description <code>make_series_plot()</code> function Create a 1D time series plot from data dictionaries or arrays. Supports line, scatter, bar, and tornado plot types. <p>For direct renderer access, import from <code>bores.visualization.plotly1d</code>:</p> Name Type Description <code>plotly1d.DataVisualizer</code> class Main 1D visualization orchestrator. <code>plotly1d.LineRenderer</code> class Line plot renderer. <code>plotly1d.BarRenderer</code> class Bar chart renderer. <code>plotly1d.ScatterRenderer</code> class Scatter plot renderer. <code>plotly1d.TornadoRenderer</code> class Tornado (sensitivity) chart renderer."},{"location":"api-reference/full-api/#2d-plotting","title":"2D Plotting","text":"<p>Import from <code>bores.visualization.plotly2d</code>:</p> Name Type Description <code>plotly2d.DataVisualizer</code> class Main 2D visualization orchestrator. <code>plotly2d.HeatmapRenderer</code> class Heatmap renderer for areal property maps. <code>plotly2d.ContourRenderer</code> class Contour plot renderer. <code>plotly2d.ScatterRenderer</code> class 2D scatter plot renderer. <code>plotly2d.LineRenderer</code> class 2D line plot renderer. <code>plotly2d.SurfaceRenderer</code> class 3D surface from 2D data renderer."},{"location":"api-reference/full-api/#3d-plotting","title":"3D Plotting","text":"<p>Import from <code>bores.visualization.plotly3d</code>:</p> Name Type Description <code>plotly3d.DataVisualizer</code> class Main 3D visualization orchestrator. <code>plotly3d.VolumeRenderer</code> class Volume rendering for full 3D grids. <code>plotly3d.IsosurfaceRenderer</code> class Isosurface extraction and rendering. <code>plotly3d.CellBlockRenderer</code> class Individual cell block rendering. <code>plotly3d.Scatter3DRenderer</code> class 3D scatter plot renderer. <code>plotly3d.Labels</code> class Manages text labels and annotations in 3D scenes. <code>plotly3d.Label</code> class A single text label with position and formatting."},{"location":"api-reference/full-api/#precision-control","title":"Precision Control","text":"<p>Functions for controlling the floating-point precision used throughout the simulator.</p> Name Type Description <code>use_32bit_precision()</code> function Set global precision to float32 (default). Faster computation, lower memory. <code>use_64bit_precision()</code> function Set global precision to float64. Higher accuracy for ill-conditioned problems. <code>with_precision()</code> context manager Temporarily set precision within a <code>with</code> block. <code>get_dtype()</code> function Get the currently active NumPy dtype. <code>set_dtype()</code> function Set the global dtype directly. <code>get_floating_point_info()</code> function Get machine epsilon and range information for the current dtype. <pre><code>import bores\n\n# Default is 32-bit\nbores.use_64bit_precision()\n\n# Or temporarily\nwith bores.with_precision(64):\n    model = bores.reservoir_model(...)\n</code></pre>"},{"location":"api-reference/full-api/#types-and-enums","title":"Types and Enums","text":"<p>Type aliases and enumerations used throughout the API.</p>"},{"location":"api-reference/full-api/#enums","title":"Enums","text":"Name Type Description <code>FluidPhase</code> enum Fluid phase: <code>OIL</code>, <code>WATER</code>, <code>GAS</code>. <code>EvolutionScheme</code> enum Simulation scheme: <code>IMPES</code>, <code>EXPLICIT</code>, <code>IMPLICIT</code>. <code>Orientation</code> enum Spatial orientation for fractures and boundaries. <code>Wettability</code> enum Rock wettability: <code>WATER_WET</code>, <code>OIL_WET</code>, <code>MIXED_WET</code>. <code>MiscibilityModel</code> enum Miscibility model type. <code>MixingRule</code> enum Three-phase mixing rule identifier. <code>WellFluidType</code> enum Well fluid classification."},{"location":"api-reference/full-api/#dimension-types","title":"Dimension Types","text":"Name Type Description <code>NDimension</code> TypeVar Generic dimension parameter for models, wells, and grids. <code>ThreeDimensions</code> type alias <code>Tuple[int, int, int]</code> for 3D cell coordinates. <code>TwoDimensions</code> type alias <code>Tuple[int, int]</code> for 2D cell coordinates. <code>OneDimension</code> type alias <code>Tuple[int]</code> for 1D cell coordinates."},{"location":"api-reference/full-api/#grid-types","title":"Grid Types","text":"Name Type Description <code>ThreeDimensionalGrid</code> type alias NumPy array of shape <code>(nx, ny, nz)</code>. <code>TwoDimensionalGrid</code> type alias NumPy array of shape <code>(nx, ny)</code>. <code>OneDimensionalGrid</code> type alias NumPy array of shape <code>(nx,)</code>. <code>ArrayLike</code> type alias Anything that can be converted to a NumPy array."},{"location":"api-reference/full-api/#function-types","title":"Function Types","text":"Name Type Description <code>Solver</code> type alias A linear system solver callable. <code>SolverFunc</code> type alias A solver function signature. <code>Preconditioner</code> type alias A preconditioner callable. <code>Interpolator</code> type alias An interpolation function."},{"location":"api-reference/full-api/#property-types","title":"Property Types","text":"Name Type Description <code>CapillaryPressures</code> type alias Tuple of capillary pressure arrays (Pcow, Pcgo). <code>RelativePermeabilities</code> type alias Tuple of relative permeability arrays (kro, krw, krg). <code>RelativeMobilityRange</code> type alias Range of relative mobility values. <code>Range</code> type alias A <code>(min, max)</code> tuple."},{"location":"api-reference/full-api/#constants","title":"Constants","text":"<p>The constants system provides named, documented physical constants with unit information.</p> Name Type Description <code>Constants</code> class Container for all simulation constants. Access individual constants as attributes. <code>Constant</code> class A single constant with value, unit, and description. <code>ConstantsContext</code> class Context manager for temporarily modifying constant values. <code>c</code> object The global <code>Constants</code> instance. Access constants as <code>bores.c.STANDARD_PRESSURE</code>, <code>bores.c.GAS_CONSTANT</code>, etc. <code>get_constant()</code> function Retrieve a constant by name string. <pre><code>import bores\n\nprint(bores.c.STANDARD_PRESSURE)      # 14.696 psi\nprint(bores.c.STANDARD_TEMPERATURE)   # 60.0 F\nprint(bores.c.GAS_CONSTANT)           # 10.7316 psi*ft3/(lbmol*R)\n</code></pre>"},{"location":"api-reference/full-api/#errors","title":"Errors","text":"<p>All BORES exceptions inherit from <code>BORESError</code>. You can catch <code>BORESError</code> to handle any BORES-specific error, or catch specific subclasses for targeted handling.</p> Name Type Description <code>BORESError</code> exception Base class for all BORES errors. <code>ValidationError</code> exception Invalid input parameters or model configuration. <code>SimulationError</code> exception Error during simulation execution. <code>ComputationError</code> exception Numerical computation failure. <code>SolverError</code> exception Linear solver failed to converge. <code>PreconditionerError</code> exception Preconditioner construction or application failure. <code>SerializationError</code> exception Error during object serialization. <code>DeserializationError</code> exception Error during object deserialization. <code>SerializableError</code> exception General serializable protocol error. <code>StorageError</code> exception Storage backend read/write failure. <code>StreamError</code> exception Data streaming error. <code>TimingError</code> exception Timer configuration or state error. <code>StopSimulation</code> exception Raised to halt simulation early (not an error, used for control flow). <pre><code>import bores\n\ntry:\n    model = bores.reservoir_model(porosity=-0.1, ...)\nexcept bores.ValidationError as e:\n    print(f\"Invalid model: {e}\")\n\ntry:\n    for step in bores.run(model=model, config=config):\n        pass\nexcept bores.SolverError as e:\n    print(f\"Solver failed: {e}\")\nexcept bores.SimulationError as e:\n    print(f\"Simulation error: {e}\")\n</code></pre>"},{"location":"api-reference/full-api/#utility-functions","title":"Utility Functions","text":"<p>Low-level array utility functions. These are primarily used internally but are available if you need them for custom computations.</p> Name Type Description <code>apply_mask()</code> function Apply a boolean mask to an array, setting masked cells to a fill value. <code>clip()</code> function Clip array values to a range (like <code>np.clip</code> but dtype-aware). <code>clip_scalar()</code> function Clip a scalar value to a range. <code>get_mask()</code> function Get a boolean mask from a condition applied to an array. <code>is_array()</code> function Check if a value is a NumPy array. <code>max_()</code> function Maximum of an array (raises if any value exceeds a threshold). <code>min_()</code> function Minimum of an array (raises if any value is below a threshold)."},{"location":"api-reference/full-api/#pvt-correlations","title":"PVT Correlations","text":"<p>Scalar and array PVT correlation functions are documented separately due to their size:</p> <ul> <li>Scalar Correlations: 60+ single-value functions for point PVT calculations. Use these for quick checks, building custom tables, or validating against lab data.</li> <li>Array Correlations: Vectorized equivalents that operate on entire grids in a single call. The simulator uses these internally, and you can use them for post-processing or custom property computations.</li> </ul> <p>Both modules share the same function names and parameters. The only difference is that scalar functions accept <code>float</code> inputs and array functions accept <code>NDimensionalGrid</code> inputs.</p>"},{"location":"best-practices/","title":"Best Practices","text":""},{"location":"best-practices/#overview","title":"Overview","text":"<p>Building a reservoir simulation model involves dozens of decisions, from grid resolution to solver tolerances to timestep control. Each choice affects accuracy, performance, and stability in ways that are not always obvious. This section distills practical guidance from numerical simulation experience into actionable recommendations that help you make informed decisions for your specific problem.</p> <p>The advice here is organized by topic. Each page addresses a specific area of model construction or simulation execution, provides rules of thumb for common situations, and explains the reasoning behind each recommendation so you can adapt the guidance to unusual cases. The pages are self-contained, so you can read them in any order. That said, if you are setting up your first model, reading them in the order listed below will give you a natural progression from spatial discretization through solver configuration to validation.</p> <p>These are not rigid rules. Every reservoir is different, and what works well for a homogeneous sandstone waterflood may not be appropriate for a fractured carbonate under miscible gas injection. Use these recommendations as starting points, and always validate your specific model against analytical solutions or benchmark cases when possible. The Validation page covers how to do exactly that.</p>"},{"location":"best-practices/#pages","title":"Pages","text":"<ul> <li>Grid Design - Cell sizing, aspect ratios, vertical resolution, and when to refine</li> <li>Timestep Selection - Initial timestep, adaptive control, CFL limits, and stability</li> <li>Solver Selection - Choosing solvers and preconditioners for different problems</li> <li>Error Handling - Understanding and resolving common simulation errors</li> <li>Performance - Precision settings, grid size, preconditioner caching, and memory</li> <li>Validation - Material balance checks, analytical comparisons, and benchmarking</li> </ul>"},{"location":"best-practices/errors/","title":"Error Handling","text":""},{"location":"best-practices/errors/#overview","title":"Overview","text":"<p>BORES uses a structured exception hierarchy to communicate what went wrong and where. Every BORES-specific error inherits from <code>BORESError</code>, so you can catch all framework errors with a single except clause when you need broad error handling, or catch specific subclasses when you want targeted recovery logic. Understanding what each error type means and what typically causes it saves significant debugging time.</p> <p>This page covers the error hierarchy, common error scenarios you are likely to encounter, and practical strategies for diagnosing and fixing each one. The errors are organized roughly in the order you are most likely to encounter them: validation errors during model setup, solver and simulation errors during execution, and serialization errors during save/load operations.</p> <p>All BORES errors include descriptive messages that tell you what failed and often suggest corrective action. When you encounter an error, read the full message carefully before diving into debugging. In many cases, the message itself contains the fix.</p>"},{"location":"best-practices/errors/#error-hierarchy","title":"Error Hierarchy","text":"<pre><code>Exception\n\u251c\u2500\u2500 BORESError                    # Base for all BORES errors\n\u2502   \u251c\u2500\u2500 ValidationError           # Invalid inputs (also inherits ValueError)\n\u2502   \u251c\u2500\u2500 ComputationError          # Numerical computation failure\n\u2502   \u251c\u2500\u2500 SolverError               # Linear solver non-convergence\n\u2502   \u251c\u2500\u2500 PreconditionerError       # Preconditioner build/apply failure\n\u2502   \u251c\u2500\u2500 SimulationError           # Simulation execution failure\n\u2502   \u2502   \u2514\u2500\u2500 TimingError           # Timer configuration or state error\n\u2502   \u251c\u2500\u2500 StorageError              # Storage backend failure\n\u2502   \u251c\u2500\u2500 StreamError               # Data streaming failure\n\u2502   \u2514\u2500\u2500 SerializableError         # Serialization protocol error\n\u2502       \u251c\u2500\u2500 SerializationError    # Error during serialization (to dict)\n\u2502       \u2514\u2500\u2500 DeserializationError  # Error during deserialization (from dict)\n\u2514\u2500\u2500 StopSimulation                # Graceful simulation halt (not an error)\n</code></pre> <p>Note that <code>StopSimulation</code> inherits directly from <code>Exception</code>, not from <code>BORESError</code>. This is intentional: it is a control flow mechanism, not an error condition. You raise it to stop a simulation early (for example, when a recovery target is reached), and the simulation loop handles it gracefully.</p>"},{"location":"best-practices/errors/#validation-errors","title":"Validation Errors","text":"<p><code>ValidationError</code> is raised during model construction when input parameters are outside valid ranges or violate physical constraints. Because it also inherits from Python's built-in <code>ValueError</code>, you can catch it with either <code>except bores.ValidationError</code> or <code>except ValueError</code>.</p>"},{"location":"best-practices/errors/#common-causes","title":"Common Causes","text":"<p>Negative or zero physical properties. Porosity, permeability, pressure, temperature, and viscosity must all be positive. Saturation values must be between 0 and 1.</p> <pre><code># This will raise ValidationError\nmodel = bores.reservoir_model(porosity=-0.1, ...)\n</code></pre> <p>Saturations do not sum to 1. The oil, water, and gas saturations in every cell must sum to 1.0. If you build saturation grids manually, small floating-point errors can cause this check to fail. Use <code>build_saturation_grids</code> to avoid this issue, as it enforces the constraint automatically.</p> <p>Grid dimension mismatches. All property grids (porosity, permeability, saturation, etc.) must have the same shape as the grid dimensions specified in <code>reservoir_model()</code>. If you pass a (10, 10, 3) grid for porosity but a (10, 10, 5) grid for permeability, you will get a <code>ValidationError</code>.</p> <p>Well perforations outside the grid. Well perforation intervals must reference valid cell coordinates within the grid dimensions. A perforation at cell (15, 5, 2) in a 10x10x3 grid will raise a <code>ValidationError</code>.</p>"},{"location":"best-practices/errors/#how-to-fix","title":"How to Fix","text":"<p>Read the error message. It tells you which parameter failed and what the valid range is. Double-check your input data against the expected types and ranges described in the API Reference.</p>"},{"location":"best-practices/errors/#solver-errors","title":"Solver Errors","text":"<p><code>SolverError</code> is raised when the linear solver fails to converge within the maximum iteration count. This is one of the most common errors during simulation execution and usually indicates a problem with the linear system rather than a bug in the code.</p>"},{"location":"best-practices/errors/#common-causes_1","title":"Common Causes","text":"<p>Ill-conditioned matrix. Extreme contrasts in permeability (e.g., 0.001 mD next to 10,000 mD), very thin cells, or large aspect ratios create matrices that are difficult for iterative solvers. The condition number of the matrix determines how many iterations the solver needs, and badly conditioned matrices may require more iterations than the maximum.</p> <p>Timestep too large. For implicit schemes, very large timesteps make the matrix harder to solve. The adaptive timer usually prevents this, but if you override with a fixed large timestep, solver failures are likely.</p> <p>Weak preconditioner. If you are using <code>\"diagonal\"</code> preconditioning or no preconditioning (<code>None</code>), the solver may need many more iterations than the maximum. Switch to <code>\"ilu\"</code> or <code>\"amg\"</code>.</p>"},{"location":"best-practices/errors/#how-to-fix_1","title":"How to Fix","text":"<ol> <li> <p>Increase <code>max_iterations</code> in <code>Config</code> (from 250 to 500 or 1000). This is the simplest fix and often works.</p> </li> <li> <p>Use a stronger preconditioner. Switch from <code>\"ilu\"</code> to <code>\"amg\"</code>, or add a solver fallback chain (<code>pressure_solver=[\"bicgstab\", \"lgmres\"]</code>).</p> </li> <li> <p>Switch to 64-bit precision. Ill-conditioned matrices are more sensitive to floating-point precision. Call <code>bores.use_64bit_precision()</code> before building the model.</p> </li> <li> <p>Reduce the timestep. Set a smaller <code>max_step_size</code> in the timer to keep matrices better conditioned.</p> </li> <li> <p>Check the model. Extreme property contrasts may indicate a model setup error (e.g., a permeability of 0 in a cell that should be part of the flow domain).</p> </li> </ol> <p>See Solver Selection for detailed guidance.</p>"},{"location":"best-practices/errors/#simulation-errors","title":"Simulation Errors","text":"<p><code>SimulationError</code> is the base class for errors that occur during simulation execution. It covers situations where the simulation reaches a physically impossible state or cannot continue for some reason other than solver failure.</p>"},{"location":"best-practices/errors/#common-causes_2","title":"Common Causes","text":"<p>Negative pressures. If the pressure in any cell drops below zero, the simulation raises a <code>SimulationError</code>. This usually means wells are producing at a rate that exceeds the reservoir's deliverability. Check your well controls and make sure production rates are achievable at the given reservoir pressure.</p> <p>Timestep at minimum. If the adaptive timer reduces the timestep to <code>min_step_size</code> and the step still fails, a <code>SimulationError</code> is raised because the simulation cannot make progress. This typically indicates a fundamental model problem (unphysical properties, extreme boundary conditions, or a well operating far outside its capacity).</p> <p>Saturation constraint violations. If saturations go negative or exceed 1 after the explicit saturation update, this indicates that the CFL condition was violated. The timer should catch this and reduce the timestep, but if <code>min_step_size</code> is too large to maintain stability, the simulation will fail.</p>"},{"location":"best-practices/errors/#how-to-fix_2","title":"How to Fix","text":"<ol> <li> <p>Lower <code>min_step_size</code> in the timer to give the adaptive controller more room to reduce the timestep.</p> </li> <li> <p>Check well controls. Make sure production rates are reasonable for the reservoir pressure and permeability. Use <code>BHPControl</code> with a minimum BHP to prevent wells from drawing pressure below a physical limit.</p> </li> <li> <p>Check boundary conditions. Constant-pressure boundaries at very high or very low pressures can drive extreme flow rates.</p> </li> <li> <p>Verify fluid properties. Non-physical PVT values (e.g., formation volume factor less than 1.0 for live oil, or negative viscosity) will cause computation errors that propagate to simulation failure.</p> </li> </ol>"},{"location":"best-practices/errors/#timing-errors","title":"Timing Errors","text":"<p><code>TimingError</code> is a subclass of <code>SimulationError</code> raised when the timer configuration is invalid or the timer reaches an inconsistent state.</p>"},{"location":"best-practices/errors/#common-causes_3","title":"Common Causes","text":"<p>Invalid timer parameters. Setting <code>min_step_size</code> greater than <code>max_step_size</code>, or <code>initial_step_size</code> outside the min/max range, will raise a <code>TimingError</code>.</p> <p>Simulation time is zero or negative. The <code>simulation_time</code> parameter must be a positive number representing the total simulation duration in seconds.</p>"},{"location":"best-practices/errors/#how-to-fix_3","title":"How to Fix","text":"<p>Check that your timer parameters are consistent: <code>min_step_size &lt;= initial_step_size &lt;= max_step_size</code> and <code>simulation_time &gt; 0</code>. Use the <code>Time()</code> helper to convert from human-readable units:</p> <pre><code>timer = bores.Timer(\n    initial_step_size=bores.Time(days=1),\n    max_step_size=bores.Time(days=30),\n    min_step_size=bores.Time(seconds=1),\n    simulation_time=bores.Time(years=5),\n)\n</code></pre>"},{"location":"best-practices/errors/#preconditioner-errors","title":"Preconditioner Errors","text":"<p><code>PreconditionerError</code> is raised when a preconditioner cannot be constructed or applied. This is less common than solver errors but can occur with certain matrix structures.</p>"},{"location":"best-practices/errors/#common-causes_4","title":"Common Causes","text":"<p>Zero diagonal elements. ILU preconditioning requires non-zero diagonal elements. If a cell has zero transmissibility in all directions (completely isolated), the diagonal element is zero and ILU fails.</p> <p>AMG setup failure. AMG can fail if the matrix structure is degenerate or if the pyamg package encounters a numerical issue.</p>"},{"location":"best-practices/errors/#how-to-fix_4","title":"How to Fix","text":"<ol> <li> <p>Check for isolated cells. Make sure every cell in the grid has non-zero transmissibility to at least one neighbor.</p> </li> <li> <p>Fall back to diagonal preconditioning as a diagnostic: if the simulation works with <code>\"diagonal\"</code> but fails with <code>\"ilu\"</code>, the matrix has structural issues that need investigation.</p> </li> <li> <p>Use a different preconditioner. If <code>\"ilu\"</code> fails, try <code>\"block_jacobi\"</code> or <code>\"amg\"</code>.</p> </li> </ol>"},{"location":"best-practices/errors/#serialization-errors","title":"Serialization Errors","text":"<p><code>SerializationError</code> and <code>DeserializationError</code> occur during save and load operations.</p>"},{"location":"best-practices/errors/#common-causes_5","title":"Common Causes","text":"<p>Custom objects not registered. If you create custom well controls, solvers, or preconditioners using the decorator registration system, you must register them before attempting to deserialize a file that contains them. The deserializer looks up types by name, and if the name is not in the registry, it raises a <code>DeserializationError</code>.</p> <p>File format mismatch. Loading an HDF5 file with <code>JSONStore</code> or vice versa raises a <code>StorageError</code>.</p> <p>Corrupted or incomplete files. If a simulation was interrupted during a save operation, the output file may be incomplete.</p>"},{"location":"best-practices/errors/#how-to-fix_5","title":"How to Fix","text":"<ol> <li> <p>Register custom types before loading. Import the module that contains your custom decorators (<code>@well_control</code>, <code>@solver_func</code>, etc.) before calling <code>load()</code>.</p> </li> <li> <p>Use the correct store type. Match the store to the file extension: <code>.h5</code> for <code>HDF5Store</code>, <code>.zarr</code> for <code>ZarrStore</code>, <code>.json</code> for <code>JSONStore</code>.</p> </li> <li> <p>Check file integrity. If a file was corrupted, re-run the simulation from the last good checkpoint.</p> </li> </ol>"},{"location":"best-practices/errors/#using-stopsimulation","title":"Using StopSimulation","text":"<p><code>StopSimulation</code> is not an error. It is a control-flow exception you can raise to halt a simulation early. The simulation loop catches it and stops cleanly, preserving all results up to that point.</p> <pre><code>import bores\n\nconfig = bores.Config(timer=timer, wells=wells)\n\nfor step in bores.run(model=model, config=config):\n    recovery = compute_recovery_factor(step)\n    if recovery &gt;= 0.30:\n        raise bores.StopSimulation(\"Target recovery of 30% reached\")\n</code></pre> <p>This is useful for economic limit studies, parameter sensitivity runs where you only need results up to a certain point, or interactive workflows where a user wants to stop and inspect intermediate results.</p>"},{"location":"best-practices/errors/#general-debugging-strategy","title":"General Debugging Strategy","text":"<p>When a simulation fails, follow this sequence:</p> <ol> <li> <p>Read the error message. It usually tells you what went wrong and where.</p> </li> <li> <p>Check the last successful timestep. If you are using <code>StateStream</code>, the stored data up to the failure point can reveal trends (declining pressure, extreme saturations, oscillating rates) that explain the failure.</p> </li> <li> <p>Simplify the model. Remove wells, boundary conditions, or heterogeneity to isolate the cause. If the simplified model works, add complexity back one piece at a time.</p> </li> <li> <p>Try 64-bit precision. Many convergence and accuracy issues are caused by insufficient floating-point precision. This is a quick test that rules out (or confirms) precision as the cause.</p> </li> <li> <p>Reduce the timestep. Set a smaller <code>max_step_size</code> and <code>initial_step_size</code>. If the simulation works with tiny timesteps, the problem is a CFL or convergence issue that the adaptive controller cannot handle at larger steps.</p> </li> <li> <p>Check units. BORES uses oil-field units throughout: pressure in psi, temperature in degrees Fahrenheit, density in lbm/ft3, viscosity in cP, length in feet, time in seconds (internally). Mixing SI and oil-field values is a common source of non-physical results.</p> </li> </ol>"},{"location":"best-practices/grid-design/","title":"Grid Design","text":""},{"location":"best-practices/grid-design/#overview","title":"Overview","text":"<p>The computational grid is the foundation of every reservoir simulation. It defines how finely you resolve spatial variations in pressure, saturation, and fluid properties, and it directly controls both the accuracy of your results and the computational cost of running the simulation. Choosing the right grid is one of the most important decisions you will make when building a model, and getting it wrong can lead to anything from artificially smeared saturation fronts to prohibitively long run times.</p> <p>Grid design in reservoir simulation is fundamentally a trade-off between resolution and performance. Finer grids capture more physical detail but require more memory, more computation per timestep, and smaller timesteps to maintain numerical stability. Coarser grids run faster but can miss important features like thin barriers, localized coning, or sharp displacement fronts. The art of grid design is finding the resolution that captures the physics you care about without paying for detail you do not need.</p> <p>BORES uses structured Cartesian grids with uniform or layered cell dimensions. While this is simpler than unstructured or corner-point grids used in some commercial simulators, it covers the vast majority of simulation workflows and makes it straightforward to reason about cell sizes, aspect ratios, and refinement strategies. The grid construction functions in BORES (<code>build_uniform_grid</code>, <code>build_layered_grid</code>, <code>build_depth_grid</code>, <code>build_saturation_grids</code>) are designed to make it easy to experiment with different resolutions without rewriting your model setup.</p>"},{"location":"best-practices/grid-design/#cell-size-selection","title":"Cell Size Selection","text":"<p>The most fundamental grid design decision is how large to make your cells. The right cell size depends on what physical processes you are trying to resolve and how quickly you need results.</p>"},{"location":"best-practices/grid-design/#areal-dimensions-dx-dy","title":"Areal Dimensions (dx, dy)","text":"<p>For areal (horizontal) cell sizes, the key consideration is the scale of the features you need to resolve. Wells, faults, and high-permeability channels all create localized flow patterns that require smaller cells to capture accurately. Far from these features, the flow field is smoother and coarser cells are adequate.</p> <p>As a starting point, consider these ranges for different applications:</p> Application Typical Cell Size (ft) Notes Near-wellbore studies 10 - 50 Captures coning, cusping, and radial flow Pattern floods (quarter five-spot) 50 - 200 Resolves sweep patterns and breakthrough Full-field sector models 100 - 500 Balance between detail and field-scale coverage Screening studies 500 - 1000 Quick results for sensitivity analysis <p>The Peaceman well model used in BORES (and all finite-difference simulators) assumes that the well is small relative to the grid cell. If your cells are smaller than roughly 5 times the wellbore radius, the well model assumptions start to break down. In practice, this is rarely a concern because wellbore radii are typically 0.25 to 0.5 ft, making the minimum practical cell size around 2 to 5 ft.</p>"},{"location":"best-practices/grid-design/#vertical-dimension-dz","title":"Vertical Dimension (dz)","text":"<p>Vertical resolution is often more critical than horizontal resolution, especially in reservoirs with gravity-driven flow. Gravity segregation, gas coning, and water coning all require adequate vertical resolution to capture correctly. As a general rule, you need more vertical layers than you might initially expect.</p> <p>For reservoirs with significant gravity effects (gas caps, bottom water, or gravity-stable displacement), aim for at least 10 to 20 layers in the pay zone. If you are modeling gas or water coning into a well, you may need 30 or more layers near the well perforation interval. For simple depletion studies without strong gravity effects, 3 to 5 layers may be sufficient.</p> <p>The <code>build_layered_grid</code> function lets you assign different thickness values to each layer, so you can use thin layers near fluid contacts and thicker layers elsewhere:</p> <pre><code>import bores\n\n# 10 layers: thin near contacts, thick in the middle\nlayer_thicknesses = bores.build_layered_grid(\n    grid_dimensions=(20, 20, 10),\n    values=[5.0, 5.0, 10.0, 10.0, 20.0, 20.0, 10.0, 10.0, 5.0, 5.0],\n)\n</code></pre> <p>This creates a 10-layer grid with 5 ft layers at the top and bottom (near the gas-oil and oil-water contacts) and 20 ft layers in the middle of the oil column.</p>"},{"location":"best-practices/grid-design/#aspect-ratio","title":"Aspect Ratio","text":"<p>The aspect ratio of a grid cell is the ratio of its largest dimension to its smallest dimension. Extreme aspect ratios (very flat or very tall cells) can cause numerical problems because flow calculations become ill-conditioned when cells are much longer in one direction than another.</p> <p>For explicit and IMPES simulations, keep the aspect ratio below 10:1. For fully implicit simulations, you can push to 20:1 or higher, but the linear solver will work harder and may need a stronger preconditioner.</p> <p>Common problematic scenarios and how to handle them:</p> <p>Very thin reservoir, wide cells. If your pay zone is 10 ft thick but your cells are 500 ft wide, the vertical aspect ratio is 50:1. This is too extreme. Either increase the number of vertical layers (splitting the 10 ft into 5 layers of 2 ft each gives a 250:1 ratio, which is worse) or reduce the horizontal cell size. A better approach for thin reservoirs is to use 50 to 100 ft horizontal cells with 2 to 5 ft vertical cells, giving a 20:1 to 50:1 ratio.</p> <p>Tall cells near wells. If you refine vertically near a well perforation, make sure the horizontal cells are not too large relative to the refined vertical cells. A 2 ft vertical cell in a 500 ft horizontal cell creates a 250:1 ratio that will cause stability issues.</p> <p>The general rule is to keep all three dimensions within an order of magnitude of each other when possible, and never let the ratio exceed about 20:1 without testing that your solver and timestep handle it well.</p>"},{"location":"best-practices/grid-design/#grid-sizing-for-different-problems","title":"Grid Sizing for Different Problems","text":"<p>Different simulation scenarios call for different grid design strategies. Here are recommendations for common workflows.</p>"},{"location":"best-practices/grid-design/#primary-depletion","title":"Primary Depletion","text":"<p>For simple pressure depletion without water or gas injection, coarse grids are usually adequate. The pressure field varies smoothly across the reservoir, and saturation changes (if any) are driven by solution gas liberation, which is a bulk process rather than a sharp-front displacement. A 10x10x5 to 30x30x10 grid is often sufficient for engineering purposes.</p>"},{"location":"best-practices/grid-design/#waterflood","title":"Waterflood","text":"<p>Waterfloods develop sharp saturation fronts that can span only a few cells. If your cells are too large, the front will appear smeared across many cells, which underestimates sweep efficiency and delays predicted breakthrough. For quarter five-spot patterns, a 20x20 to 50x50 areal grid captures the displacement front reasonably well. Use at least 5 vertical layers to capture gravity segregation.</p> <p>Grid Orientation Effects</p> <p>In a Cartesian grid, flow along the grid axes (x and y) and flow along the diagonals are treated differently due to the stencil geometry. This can cause artificial preferential flow along one direction in a five-spot pattern. Using a finer grid reduces this effect. If grid orientation is a concern, try rotating your well pattern 45 degrees relative to the grid and compare results.</p>"},{"location":"best-practices/grid-design/#gas-injection-and-miscible-flooding","title":"Gas Injection and Miscible Flooding","text":"<p>Gas injection simulations are more demanding than waterfloods because gas is much more mobile than oil, leading to sharper displacement fronts and stronger gravity segregation. Miscible floods add concentration transport that requires adequate resolution to avoid excessive numerical diffusion. Use at least 20x20x10 grids for gas injection, and consider 30x30x20 or finer for miscible flooding studies where mixing zone resolution matters.</p>"},{"location":"best-practices/grid-design/#coning-studies","title":"Coning Studies","text":"<p>Water or gas coning near wells requires fine vertical resolution around the perforation interval. A common approach is to use a 1D or 2D radial-equivalent model with 30 to 50 vertical layers concentrated around the perforation depth. In 3D Cartesian grids, you can approximate this by using locally refined vertical layers near the well.</p>"},{"location":"best-practices/grid-design/#coarsening-and-refinement","title":"Coarsening and Refinement","text":"<p>BORES provides the <code>coarsen_grid</code> function to reduce grid resolution by averaging cell values, and <code>coarsen_permeability_grids</code> for permeability (which uses harmonic averaging to preserve flow behavior). These are useful for testing whether your grid is fine enough: run your simulation at your chosen resolution, coarsen by a factor of 2, run again, and compare. If the results are nearly identical, your original resolution is adequate. If they differ significantly, you need a finer grid.</p> <pre><code>import bores\n\n# Original fine grid\npressure_fine = bores.build_uniform_grid((40, 40, 20), 3000.0)\n\n# Coarsened 2x in each direction\npressure_coarse = bores.coarsen_grid(pressure_fine, factor=2)\n# Result shape: (20, 20, 10)\n\n# For permeability, use harmonic averaging\nkx_coarse = bores.coarsen_permeability_grids(kx_fine, factor=2)\n</code></pre> <p>Permeability Coarsening</p> <p>Never coarsen permeability using arithmetic averaging. Arithmetic averaging of permeability overpredicts flow through heterogeneous media. Always use <code>coarsen_permeability_grids</code>, which applies harmonic averaging in the flow direction. This is the physically correct approach for series-flow configurations.</p>"},{"location":"best-practices/grid-design/#practical-guidelines-summary","title":"Practical Guidelines Summary","text":"<p>Here is a quick reference for grid design decisions:</p> <ol> <li> <p>Start coarse, refine as needed. Begin with a 10x10x5 grid to get your model running, then increase resolution and check that results converge. This is faster than starting fine and trying to figure out why the simulation is slow.</p> </li> <li> <p>Prioritize vertical resolution. In most reservoir problems, vertical resolution matters more than horizontal resolution because of gravity effects and permeability contrasts between layers.</p> </li> <li> <p>Keep aspect ratios reasonable. Stay below 10:1 for IMPES, below 20:1 for implicit. Test if you need to go higher.</p> </li> <li> <p>Match cell size to the physics. Sharp fronts (waterfloods, gas injection) need finer grids than smooth processes (primary depletion).</p> </li> <li> <p>Use layered grids for heterogeneity. The <code>build_layered_grid</code> function lets you specify per-layer values, which is more efficient than uniform fine grids for vertically heterogeneous reservoirs.</p> </li> <li> <p>Validate with grid refinement. Always run a coarsened version and compare. If results differ by more than 5 to 10%, refine further.</p> </li> <li> <p>Remember the CFL constraint. Finer grids require smaller timesteps in explicit and IMPES schemes. A grid that is 2x finer in each direction is 8x more cells and typically requires 2x smaller timesteps, for a total of 16x more computation. See the Timestep Selection page for details.</p> </li> </ol>"},{"location":"best-practices/performance/","title":"Performance","text":""},{"location":"best-practices/performance/#overview","title":"Overview","text":"<p>Reservoir simulation performance is dominated by two costs: assembling the coefficient matrices from fluid properties and transmissibilities, and solving the resulting linear systems. Everything else (well calculations, saturation updates, I/O) is typically a small fraction of total runtime. Understanding where time is spent lets you focus optimization effort where it matters and avoid changes that have negligible impact.</p> <p>BORES is designed to be fast for its class of simulator. The core numerical routines use Numba JIT compilation for near-C performance, the linear algebra relies on SciPy's sparse solvers backed by optimized LAPACK/BLAS libraries, and the PVT correlations operate on entire grids in a single vectorized call. Despite this, simulation of large models over many timesteps can still take significant time, and there are several configuration choices that materially affect performance.</p> <p>This page covers the main performance levers available to you: precision settings, grid sizing, preconditioner caching, timestep optimization, and memory management. Each section explains the trade-off involved and provides concrete recommendations.</p>"},{"location":"best-practices/performance/#precision-settings","title":"Precision Settings","text":"<p>BORES defaults to 32-bit (single precision) floating-point arithmetic. This is controlled by <code>bores.use_32bit_precision()</code>, which is called automatically when the package is imported. You can switch to 64-bit with <code>bores.use_64bit_precision()</code>.</p>"},{"location":"best-practices/performance/#32-bit-vs-64-bit-performance","title":"32-bit vs 64-bit Performance","text":"<p>Single precision is faster than double precision for two reasons: it uses half the memory (meaning more data fits in CPU cache) and modern CPUs can process twice as many 32-bit operations per clock cycle as 64-bit operations. In practice, 32-bit mode is typically 30 to 50% faster than 64-bit for the same model.</p> Aspect 32-bit (float32) 64-bit (float64) Memory per cell ~50% less Baseline Computation speed 30-50% faster Baseline Accuracy ~7 significant digits ~15 significant digits Solver convergence May need more iterations Fewer iterations Numerical stability Adequate for most problems Required for ill-conditioned problems"},{"location":"best-practices/performance/#when-to-use-each","title":"When to Use Each","text":"<p>Use 32-bit (default) when:</p> <ul> <li>Grid has fewer than 500,000 cells</li> <li>Permeability contrasts are moderate (within 3 to 4 orders of magnitude)</li> <li>Solver converges comfortably within the iteration limit</li> <li>You want faster development iteration</li> </ul> <p>Use 64-bit when:</p> <ul> <li>Solver convergence is marginal (iteration count near the maximum)</li> <li>Extreme permeability contrasts (&gt; 4 orders of magnitude)</li> <li>Very tight convergence tolerances (&lt; 1e-8)</li> <li>Capillary pressure gradients are important for accuracy</li> <li>You see oscillations or non-physical results in 32-bit</li> </ul> <pre><code>import bores\n\n# Switch to 64-bit for a challenging problem\nbores.use_64bit_precision()\n\nmodel = bores.reservoir_model(...)\n\n# Or use temporarily with a context manager\nwith bores.with_precision(64):\n    model = bores.reservoir_model(...)\n    # 64-bit inside this block\n# Back to 32-bit outside\n</code></pre>"},{"location":"best-practices/performance/#grid-size-impact","title":"Grid Size Impact","text":"<p>The number of cells in your grid is the primary driver of both memory usage and computation time. The relationship is roughly linear for memory and slightly super-linear for computation (because solver convergence can degrade for larger problems).</p> Grid Cells Typical Memory Relative Speed 1,000 ~10 MB 1x (baseline, very fast) 10,000 ~50 MB ~5x slower 100,000 ~500 MB ~30-50x slower 1,000,000 ~5 GB ~300-500x slower <p>These numbers are approximate and depend on the number of phases, the evolution scheme, and the solver configuration. Fully implicit schemes use more memory per cell than IMPES because they store the full Jacobian matrix.</p>"},{"location":"best-practices/performance/#practical-recommendations","title":"Practical Recommendations","text":"<ol> <li> <p>Start with the coarsest grid that captures your physics. A 10x10x5 model runs in seconds and lets you verify that the model setup is correct before scaling up.</p> </li> <li> <p>Use <code>coarsen_grid</code> for quick sensitivity runs. Coarsen a fine model by 2x in each direction for parameter sweeps, then run the final cases at full resolution.</p> </li> <li> <p>Profile before optimizing. If a simulation is slow, check whether the bottleneck is the solver (increase preconditioner strength or cache it), the property calculations (use PVT tables instead of correlations), or the I/O (reduce save frequency).</p> </li> </ol>"},{"location":"best-practices/performance/#preconditioner-caching","title":"Preconditioner Caching","text":"<p>Building a preconditioner is expensive. ILU factorization has a cost comparable to 5 to 10 solver iterations, and AMG setup can cost as much as 50 to 100 iterations. Since the coefficient matrix changes modestly from one timestep to the next (only the values change, not the sparsity structure), reusing a previously built preconditioner for several timesteps can save substantial time.</p> <p>The <code>CachedPreconditionerFactory</code> wraps any preconditioner factory and adds caching logic:</p> <pre><code>import bores\n\n# Cache the ILU preconditioner, rebuild every 10 steps or when the matrix\n# changes by more than 30%\ncached = bores.CachedPreconditionerFactory(\n    factory=\"ilu\",\n    update_frequency=10,\n    recompute_threshold=0.3,\n)\ncached.register(override=True)\n</code></pre>"},{"location":"best-practices/performance/#tuning-cache-parameters","title":"Tuning Cache Parameters","text":"<p><code>update_frequency</code>: How many timesteps between forced rebuilds. Higher values save more time but risk using a stale preconditioner that increases solver iteration counts. Start with 10 and adjust based on whether solver iterations increase over time.</p> <p><code>recompute_threshold</code>: Relative change in matrix values that triggers a rebuild, regardless of <code>update_frequency</code>. A threshold of 0.3 means the preconditioner is rebuilt when the matrix values change by more than 30% from the last build. Lower values keep the preconditioner fresh at higher cost.</p> <p>For stable simulations (constant rate production, steady boundary conditions), you can increase <code>update_frequency</code> to 20 or even 50. For transient simulations (well shutins, rate changes, front arrivals), keep it at 5 to 10.</p> <p>AMG Caching</p> <p>AMG benefits the most from caching because its setup cost is the highest. If you use AMG preconditioning, always wrap it with <code>CachedPreconditionerFactory</code>. The setup cost for AMG is typically 5 to 10x higher than ILU, so even caching for 5 steps can cut total solver time in half.</p>"},{"location":"best-practices/performance/#timestep-optimization","title":"Timestep Optimization","text":"<p>The total number of timesteps directly affects runtime. Fewer, larger timesteps are faster, but accuracy and stability impose upper bounds. The adaptive timer in BORES handles this automatically, but you can influence its behavior:</p> <ol> <li> <p>Set a generous <code>max_step_size</code>. If you know your problem has no short-timescale transients, allow larger maximum timesteps (30 to 90 days for multi-year simulations).</p> </li> <li> <p>Use <code>ramp_up_factor</code>. Setting this to 1.1 or 1.2 lets the timer grow the timestep faster after a period of stability, reaching the maximum step size sooner.</p> </li> <li> <p>Avoid unnecessary restarts. Each time the simulation reduces the timestep (due to CFL violation or solver failure), it takes several steps to ramp back up. Reducing the frequency of these events by using a slightly smaller <code>max_step_size</code> can actually reduce total runtime compared to an aggressive setting that causes frequent backoffs.</p> </li> <li> <p>Consider fully implicit for long simulations. If your simulation runs for 20+ years with 1-day timesteps under IMPES, switching to fully implicit with 30 to 90 day timesteps can reduce the total step count by 10 to 30x, more than offsetting the higher cost per step.</p> </li> </ol>"},{"location":"best-practices/performance/#pvt-tables-vs-correlations","title":"PVT Tables vs Correlations","text":"<p>PVT property calculations are called at every timestep for every cell. Correlation functions (like Standing's Bo or the Dranchuk-Abou-Kassem Z-factor) involve floating-point arithmetic that, while fast, adds up over millions of evaluations. PVT tables replace these calculations with interpolation lookups that are typically 2 to 5x faster.</p> <pre><code>import bores\n\n# Build PVT tables at model construction time\npvt_tables = bores.PVTTables(\n    oil_fvf=bores.build_pvt_table_data(pressures, bo_values),\n    gas_fvf=bores.build_pvt_table_data(pressures, bg_values),\n    # ... other properties\n)\n\nconfig = bores.Config(\n    pvt_tables=pvt_tables,\n    # ...\n)\n</code></pre> <p>The accuracy trade-off depends on how many pressure points you include in the table. With 50 to 100 pressure points spanning the expected range, linear interpolation reproduces correlation values to within 0.1% for most properties. Cubic interpolation is available for even higher accuracy.</p> <p>For small models, the speedup from PVT tables is negligible. For models with more than 50,000 cells running for hundreds of timesteps, it can reduce total runtime by 10 to 20%.</p>"},{"location":"best-practices/performance/#memory-management","title":"Memory Management","text":"<p>For large models, memory can become a constraint. Here are strategies to reduce memory usage:</p> <ol> <li> <p>Use 32-bit precision. This halves the memory for all grid arrays. For a million-cell model, this can save 2 to 3 GB.</p> </li> <li> <p>Reduce save frequency. If you are streaming results to a <code>StateStream</code>, saving every timestep can consume significant memory and disk space. Save every 5<sup>th</sup> or 10<sup>th</sup> step for long simulations unless you need fine temporal resolution.</p> </li> <li> <p>Use HDF5 or Zarr storage. These backends compress data efficiently. HDF5 with gzip compression typically achieves 3 to 5x compression on reservoir simulation data. Zarr supports chunked storage that can reduce peak memory usage.</p> </li> <li> <p>Avoid holding all states in memory. If you are processing results programmatically, iterate over the simulation generator and process each step individually rather than collecting all steps into a list.</p> </li> </ol> <pre><code># Good: process each step as it comes\nfor step in bores.run(model=model, config=config):\n    update_metrics(step)\n\n# Avoid: collecting all steps into memory\nall_steps = list(bores.run(model=model, config=config))  # High memory\n</code></pre>"},{"location":"best-practices/performance/#numba-compilation-overhead","title":"Numba Compilation Overhead","text":"<p>Many BORES functions use Numba JIT compilation. The first call to a Numba-compiled function triggers compilation, which takes 1 to 5 seconds per function. This is a one-time cost that is cached to disk, so subsequent runs in the same environment are fast.</p> <p>If you notice slow startup times, this is likely Numba compilation. It happens once per Python environment and is cached in the <code>__pycache__</code> directories. Deleting these caches (for example, after upgrading BORES) will trigger recompilation on the next run.</p> <p>For benchmarking, always exclude the first run (which includes compilation) from your timing measurements, or run a warm-up step first.</p>"},{"location":"best-practices/performance/#quick-reference","title":"Quick Reference","text":"Optimization Impact Effort When to Use 32-bit precision 30-50% faster, 50% less memory One line of code Default, always Preconditioner caching 20-40% faster solver 3-5 lines of code Medium and large models PVT tables 10-20% faster Moderate setup Large models, many timesteps Coarser grid Proportional to cell count Model redesign Screening, sensitivity Fully implicit scheme Fewer total timesteps Configuration change Long simulations, large timesteps HDF5/Zarr compression Reduces disk and I/O One line of code All saved simulations"},{"location":"best-practices/solver-selection/","title":"Solver Selection","text":""},{"location":"best-practices/solver-selection/#overview","title":"Overview","text":"<p>Every timestep in a reservoir simulation requires solving one or more sparse linear systems of equations. The pressure equation in IMPES, the coupled pressure-saturation system in fully implicit schemes, and various auxiliary calculations all reduce to solving \\(A \\mathbf{x} = \\mathbf{b}\\) where \\(A\\) is a large sparse matrix. The choice of linear solver and preconditioner has a major impact on both the speed and reliability of your simulation.</p> <p>BORES provides several iterative Krylov solvers and preconditioners, plus a direct solver for small problems or as a fallback. The solver infrastructure uses a registry system, so you can also register custom solvers and preconditioners if the built-in options do not meet your needs. For most reservoir simulation problems, the default combination of BiCGSTAB with ILU preconditioning works well, but understanding when to use alternatives can save significant computation time or rescue a simulation that fails to converge.</p> <p>The linear system arising from reservoir simulation has specific properties that guide solver selection. The pressure equation produces a symmetric positive-definite (SPD) matrix in single-phase flow and a nearly symmetric matrix in multi-phase flow. The saturation transport matrix is non-symmetric and often better conditioned than the pressure matrix. These properties mean that different solvers may be optimal for the pressure and saturation equations, and BORES lets you configure them independently.</p>"},{"location":"best-practices/solver-selection/#available-solvers","title":"Available Solvers","text":"<p>BORES registers the following solvers by default. You can list them at runtime with <code>bores.list_solver_funcs()</code>.</p> Solver Name Best For Properties BiCGSTAB <code>\"bicgstab\"</code> General non-symmetric systems Robust, moderate convergence rate. Default for both pressure and saturation. GMRES <code>\"gmres\"</code> Non-symmetric systems with many restarts Fast convergence but uses more memory (stores Krylov basis vectors). LGMRES <code>\"lgmres\"</code> Non-symmetric systems Variant of GMRES with look-ahead restarts. Often faster than standard GMRES. CG <code>\"cg\"</code> Symmetric positive-definite systems Fastest for SPD matrices. Only works for single-phase pressure or symmetric formulations. CGS <code>\"cgs\"</code> Non-symmetric systems Conjugate gradient squared. Can be faster than BiCGSTAB but less stable. TFQMR <code>\"tfqmr\"</code> Non-symmetric systems Transpose-free quasi-minimal residual. Smooth convergence, good stability. Direct <code>\"direct\"</code> Small systems (&lt; 10,000 unknowns) Exact solution via sparse LU factorization. No convergence issues but scales poorly with size."},{"location":"best-practices/solver-selection/#choosing-a-solver","title":"Choosing a Solver","text":"<p>For most problems, start with <code>\"bicgstab\"</code> (the default). It handles non-symmetric systems well and has predictable convergence behavior. If you find that BiCGSTAB is slow to converge or stagnates, try <code>\"lgmres\"</code> or <code>\"gmres\"</code>, which often converge in fewer iterations at the cost of more memory per iteration.</p> <p>If your problem has a symmetric pressure equation (single-phase, or a well-conditioned multi-phase formulation), switching the pressure solver to <code>\"cg\"</code> can cut solve time roughly in half because CG requires less work per iteration and converges faster on SPD systems.</p> <p>For small models (fewer than about 10,000 cells), the direct solver <code>\"direct\"</code> is often the fastest option because it avoids the iteration overhead entirely. For larger models, iterative solvers are always faster.</p>"},{"location":"best-practices/solver-selection/#solver-fallback-chains","title":"Solver Fallback Chains","text":"<p>You can specify multiple solvers as a list. BORES will try them in order, falling back to the next solver if the previous one fails to converge:</p> <pre><code>config = bores.Config(\n    pressure_solver=[\"bicgstab\", \"lgmres\", \"gmres\"],\n    saturation_solver=\"bicgstab\",\n    # ...\n)\n</code></pre> <p>This configuration tries BiCGSTAB first, then LGMRES, then GMRES for the pressure equation. The fallback strategy adds robustness without the cost of always using the more expensive solver.</p> <p>You can also enable a final fallback to the direct solver:</p> <pre><code># In solve_linear_system, set fallback_to_direct=True\n# The Config doesn't expose this directly, but the solver infrastructure supports it\n</code></pre>"},{"location":"best-practices/solver-selection/#available-preconditioners","title":"Available Preconditioners","text":"<p>Preconditioners transform the linear system into one that converges faster. A good preconditioner can reduce iteration counts by 10x or more, making it the single most impactful performance choice for solver configuration. BORES registers these preconditioner factories by default:</p> Preconditioner Name Cost Effectiveness Best For ILU(0) <code>\"ilu\"</code> Moderate Good General purpose. Default choice. AMG <code>\"amg\"</code> High setup, low per-iteration Excellent Large, well-structured pressure systems Diagonal (Jacobi) <code>\"diagonal\"</code> Very low Modest Simple problems, debugging Block Jacobi <code>\"block_jacobi\"</code> Low Moderate Parallel or block-structured systems Polynomial <code>\"polynomial\"</code> Low Moderate Smooth operators CPR <code>\"cpr\"</code> High Excellent Coupled pressure-saturation systems"},{"location":"best-practices/solver-selection/#choosing-a-preconditioner","title":"Choosing a Preconditioner","text":"<p>ILU (Incomplete LU) is the default and the best starting point. It constructs an approximate LU factorization of the matrix, which captures most of the matrix structure at a fraction of the cost of a full factorization. For reservoir simulation pressure equations, ILU typically reduces iteration counts from hundreds to tens.</p> <p>AMG (Algebraic Multigrid) is the premium option for pressure equations. It works by constructing a hierarchy of progressively coarser representations of the problem and solving at multiple scales. AMG is more expensive to set up than ILU but can be dramatically faster for large problems (50,000+ cells) because its convergence rate is nearly independent of problem size. The setup cost can be amortized using <code>CachedPreconditionerFactory</code>.</p> <p>Diagonal (Jacobi) is the simplest preconditioner. It just divides each equation by its diagonal element. This is very cheap but only modestly effective. Use it when you want to isolate whether solver problems are caused by the preconditioner, or for very well-conditioned systems where preconditioning is barely needed.</p> <p>CPR (Constrained Pressure Residual) is designed specifically for coupled pressure-saturation systems in fully implicit simulations. It separates the pressure and saturation components and applies AMG to the pressure part. This is the recommended preconditioner for fully implicit schemes.</p>"},{"location":"best-practices/solver-selection/#preconditioner-caching","title":"Preconditioner Caching","text":"<p>Building a preconditioner can be expensive, especially for AMG. Since the matrix structure stays constant in reservoir simulation (only the values change), you can cache the preconditioner and reuse it across multiple timesteps:</p> <pre><code>import bores\n\ncached_ilu = bores.CachedPreconditionerFactory(\n    factory=\"ilu\",\n    update_frequency=10,        # Rebuild every 10 timesteps\n    recompute_threshold=0.3,    # Or when matrix values change by more than 30%\n)\ncached_ilu.register(override=True)\n\nconfig = bores.Config(\n    pressure_preconditioner=\"ilu\",  # Will use the cached version\n    # ...\n)\n</code></pre> <p>Preconditioner caching can reduce total solver time by 20 to 40% for large models. The <code>update_frequency</code> and <code>recompute_threshold</code> parameters control how often the preconditioner is rebuilt. More frequent rebuilds maintain better quality at higher cost. See the Preconditioners page in the User Guide for detailed configuration options.</p>"},{"location":"best-practices/solver-selection/#configuration-in-config","title":"Configuration in Config","text":"<p>The <code>Config</code> class provides four solver-related parameters:</p> <pre><code>config = bores.Config(\n    timer=timer,\n    wells=wells,\n    pressure_solver=\"bicgstab\",                  # Solver for the pressure equation\n    saturation_solver=\"bicgstab\",                 # Solver for the saturation equation\n    pressure_preconditioner=\"ilu\",                # Preconditioner for pressure\n    saturation_preconditioner=\"ilu\",              # Preconditioner for saturation\n    pressure_convergence_tolerance=1e-6,          # Relative tolerance for pressure\n    saturation_convergence_tolerance=1e-4,        # Relative tolerance for saturation\n    max_iterations=250,                           # Max iterations per solve\n)\n</code></pre> <p>The saturation equation is typically better conditioned than the pressure equation, which is why the default saturation tolerance (1e-4) is looser than the pressure tolerance (1e-6). Tightening the saturation tolerance beyond 1e-4 rarely improves solution quality but increases iteration counts.</p>"},{"location":"best-practices/solver-selection/#troubleshooting-convergence","title":"Troubleshooting Convergence","text":""},{"location":"best-practices/solver-selection/#solver-does-not-converge","title":"Solver Does Not Converge","text":"<p>If the solver fails to converge within <code>max_iterations</code>, BORES raises a <code>SolverError</code>. Common causes and fixes:</p> <ol> <li> <p>Preconditioner is too weak. Switch from <code>\"diagonal\"</code> to <code>\"ilu\"</code>, or from <code>\"ilu\"</code> to <code>\"amg\"</code>. A stronger preconditioner reduces iteration counts.</p> </li> <li> <p>Tolerance is too tight. If you set <code>pressure_convergence_tolerance</code> to 1e-10 or smaller, the solver may struggle to reach that precision, especially in 32-bit mode. Relax to 1e-6 or switch to 64-bit precision.</p> </li> <li> <p>Matrix is ill-conditioned. Extreme permeability contrasts (e.g., 0.01 mD next to 10,000 mD) or very thin cells create ill-conditioned matrices. Try AMG preconditioning, which handles these cases better than ILU.</p> </li> <li> <p>Timestep is too large. For implicit schemes, very large timesteps produce matrices that are harder to solve. Let the adaptive timer reduce the timestep.</p> </li> </ol>"},{"location":"best-practices/solver-selection/#solver-converges-but-results-look-wrong","title":"Solver Converges But Results Look Wrong","text":"<p>If the solver reports convergence but the simulation produces non-physical results (negative saturations, pressures going to zero), the tolerance may be too loose. Tighten <code>pressure_convergence_tolerance</code> to 1e-8 and check whether results improve. Also verify that the model setup is correct (boundary conditions, well locations, fluid properties).</p>"},{"location":"best-practices/solver-selection/#solver-is-slow-but-converges","title":"Solver Is Slow But Converges","text":"<p>If the solver converges but takes many iterations (50+), the preconditioner is not capturing the matrix structure well enough. Try a stronger preconditioner, or use <code>CachedPreconditionerFactory</code> to amortize setup cost. If you are solving many systems with similar matrices (as in a time-stepping loop), caching is almost always beneficial.</p>"},{"location":"best-practices/solver-selection/#recommended-configurations","title":"Recommended Configurations","text":""},{"location":"best-practices/solver-selection/#small-models-5000-cells","title":"Small Models (&lt; 5,000 cells)","text":"<pre><code>config = bores.Config(\n    pressure_solver=\"direct\",\n    saturation_solver=\"bicgstab\",\n    saturation_preconditioner=\"ilu\",\n    # ...\n)\n</code></pre> <p>Direct solvers are fast for small problems and eliminate convergence concerns.</p>"},{"location":"best-practices/solver-selection/#medium-models-5000-to-100000-cells","title":"Medium Models (5,000 to 100,000 cells)","text":"<pre><code>config = bores.Config(\n    pressure_solver=\"bicgstab\",\n    saturation_solver=\"bicgstab\",\n    pressure_preconditioner=\"ilu\",\n    saturation_preconditioner=\"ilu\",\n    # ...\n)\n</code></pre> <p>The default configuration works well. Consider adding preconditioner caching if the simulation runs for many timesteps.</p>"},{"location":"best-practices/solver-selection/#large-models-100000-cells","title":"Large Models (100,000+ cells)","text":"<pre><code>config = bores.Config(\n    pressure_solver=[\"bicgstab\", \"lgmres\"],\n    saturation_solver=\"bicgstab\",\n    pressure_preconditioner=\"amg\",\n    saturation_preconditioner=\"ilu\",\n    pressure_convergence_tolerance=1e-6,\n    max_iterations=500,\n    # ...\n)\n</code></pre> <p>AMG preconditioning for pressure and a solver fallback chain provide robustness and performance at scale. Always use <code>CachedPreconditionerFactory</code> with AMG to avoid rebuilding the multigrid hierarchy every timestep.</p>"},{"location":"best-practices/timestep-selection/","title":"Timestep Selection","text":""},{"location":"best-practices/timestep-selection/#overview","title":"Overview","text":"<p>The timestep is the discrete time interval over which the simulator advances the solution. Choosing the right timestep size is critical for balancing accuracy, stability, and performance. A timestep that is too large can cause the simulation to become unstable or produce inaccurate results. A timestep that is too small wastes computation on unnecessarily fine time resolution that does not improve the answer.</p> <p>In BORES, the <code>Timer</code> class manages timestep control. It supports both constant and adaptive timestep strategies. Adaptive control is almost always preferred for production simulations because it automatically adjusts the timestep based on how the solution is evolving, taking larger steps when conditions change slowly and smaller steps during rapid transients like well startups or saturation front arrivals.</p> <p>The behavior of the timestep controller depends heavily on the evolution scheme you are using. Explicit and IMPES schemes have a hard stability limit governed by the CFL (Courant-Friedrichs-Lewy) condition. If the timestep exceeds this limit, the simulation will produce non-physical oscillations or diverge entirely. Fully implicit schemes do not have a strict CFL limit but can lose accuracy or fail to converge at large timesteps. Understanding these constraints is essential for choosing good timestep parameters.</p>"},{"location":"best-practices/timestep-selection/#the-cfl-condition","title":"The CFL Condition","text":"<p>The CFL number is a dimensionless ratio that compares the physical wave speed (how fast information travels through the reservoir) to the numerical grid speed (how far information can travel in one grid cell per timestep). For an explicit or IMPES scheme, the CFL number must stay below 1.0 for stability. In practice, you want it comfortably below 1.0 to account for local variations that are not captured by a single global CFL estimate.</p> <p>The CFL number depends on the flow velocity, the cell size, and the timestep:</p> \\[ \\text{CFL} = \\frac{v \\cdot \\Delta t}{\\Delta x} \\] <p>where \\(v\\) is the flow velocity, \\(\\Delta t\\) is the timestep, and \\(\\Delta x\\) is the cell size. Higher velocities (near wells, in high-permeability zones) and smaller cells both push the CFL number higher for a given timestep.</p> <p>In BORES, the <code>max_cfl_number</code> parameter on the <code>Timer</code> controls the stability limit. The default is 0.9, which provides a 10% safety margin below the theoretical limit of 1.0. If the simulation detects that the CFL number has been exceeded during a step, it rejects the step and retries with a smaller timestep.</p> <pre><code>import bores\n\ntimer = bores.Timer(\n    initial_step_size=bores.Time(days=1),\n    max_step_size=bores.Time(days=30),\n    min_step_size=bores.Time(seconds=1),\n    simulation_time=bores.Time(years=5),\n    max_cfl_number=0.9,   # Default, good for most problems\n)\n</code></pre> <p>When to Lower max_cfl_number</p> <p>If you see oscillations in saturation or pressure even though the simulation is not rejecting steps, try lowering <code>max_cfl_number</code> to 0.7 or 0.5. Some problems with sharp permeability contrasts or complex well patterns have local CFL numbers that are not perfectly captured by the global estimate, and a lower target provides extra margin.</p>"},{"location":"best-practices/timestep-selection/#initial-timestep","title":"Initial Timestep","text":"<p>The initial timestep sets the size of the very first step in the simulation. Choosing it well saves time because the adaptive controller does not have to spend many steps ramping up from a tiny value, or backing off from a value that was too large.</p> <p>A good rule of thumb for the initial timestep:</p> Scenario Suggested Initial Timestep Wells starting production/injection 0.1 to 1.0 days Pressure depletion (no wells near boundaries) 1.0 to 10.0 days High-rate gas injection 0.01 to 0.1 days Miscible flooding 0.1 to 0.5 days <p>If you are unsure, start with 1 day. The adaptive controller will reduce it if needed on the first step, and you will lose at most a few seconds of computation.</p>"},{"location":"best-practices/timestep-selection/#adaptive-timestep-control","title":"Adaptive Timestep Control","text":"<p>The <code>Timer</code> in BORES uses a sophisticated adaptive algorithm that adjusts the timestep based on multiple criteria. Understanding these parameters helps you tune the controller for your specific problem.</p>"},{"location":"best-practices/timestep-selection/#growth-parameters","title":"Growth Parameters","text":"<p>After a successful timestep, the controller tries to increase the timestep for the next step. The rate of increase is governed by several parameters:</p> Parameter Default Description <code>max_growth_per_step</code> 1.3 Maximum multiplicative growth per step (1.3 = 30% increase). <code>ramp_up_factor</code> <code>None</code> Optional additional growth factor applied when the simulation has been stable for several steps. Set to 1.1 or 1.2 for faster ramp-up. <code>growth_cooldown_steps</code> 5 Number of consecutive successful steps required before <code>ramp_up_factor</code> is applied. <code>step_size_smoothing</code> 0.7 Smoothing factor (0 to 1) that blends the new timestep with the previous one to avoid jumpy behavior. Higher values give smoother transitions. <p>The <code>max_growth_per_step</code> is the most important parameter. The default of 1.3 means the timestep can grow by at most 30% from one step to the next. This prevents wild jumps after a period of small timesteps. For very stable problems (simple depletion), you can increase this to 1.5 or even 2.0. For problems with sudden events (well shutins, rate changes), keep it at 1.3 or lower.</p>"},{"location":"best-practices/timestep-selection/#backoff-parameters","title":"Backoff Parameters","text":"<p>When a timestep is rejected (CFL violation, solver non-convergence, or excessive saturation change), the controller reduces the timestep and retries. The reduction factor depends on the severity of the failure:</p> Parameter Default Description <code>backoff_factor</code> 0.5 Timestep reduction for mild failures (halves the timestep). <code>aggressive_backoff_factor</code> 0.25 Timestep reduction for severe failures (quarters the timestep). <p>The controller automatically chooses between these based on how badly the step failed. A mild CFL violation (CFL slightly above the limit) uses <code>backoff_factor</code>. A severe CFL violation (CFL more than 2x the limit) or solver divergence uses <code>aggressive_backoff_factor</code>.</p>"},{"location":"best-practices/timestep-selection/#minimum-and-maximum-timestep","title":"Minimum and Maximum Timestep","text":"<p>The <code>min_step_size</code> and <code>max_step_size</code> parameters set absolute bounds on the timestep. The minimum prevents the controller from taking infinitesimally small steps that would make the simulation crawl. The maximum prevents individual steps from being so large that accuracy is lost even when the CFL condition would allow it.</p> <p>For most simulations, set <code>min_step_size</code> to a value small enough that the solver can always converge (typically 0.1 to 10 seconds), and set <code>max_step_size</code> to a value that ensures you capture the time-scale of interest (typically 30 to 90 days for multi-year simulations).</p> <p>Minimum Timestep and Simulation Failure</p> <p>If the adaptive controller reduces the timestep to <code>min_step_size</code> and the step still fails, the simulation will raise a <code>SimulationError</code>. This usually means there is a fundamental problem with the model (extreme permeability contrasts, unphysical fluid properties, or a well operating outside its capacity). See the Error Handling page for guidance on diagnosing these failures.</p>"},{"location":"best-practices/timestep-selection/#timestep-strategies-by-evolution-scheme","title":"Timestep Strategies by Evolution Scheme","text":"<p>Different evolution schemes interact with the timestep in different ways. Here is a summary of what to expect and how to configure the timer for each scheme.</p>"},{"location":"best-practices/timestep-selection/#impes-implicit-pressure-explicit-saturation","title":"IMPES (Implicit Pressure, Explicit Saturation)","text":"<p>IMPES is the default scheme in BORES and is the most commonly used for black-oil simulation. The pressure equation is solved implicitly (unconditionally stable for pressure), but the saturation update is explicit and subject to the CFL condition. This means the timestep is limited by how fast saturation fronts move through the grid.</p> <p>Recommended timer settings for IMPES:</p> <pre><code>timer = bores.Timer(\n    initial_step_size=bores.Time(days=1),\n    max_step_size=bores.Time(days=30),\n    min_step_size=bores.Time(seconds=1),\n    simulation_time=bores.Time(years=10),\n    max_cfl_number=0.9,\n    max_growth_per_step=1.3,\n    backoff_factor=0.5,\n)\n</code></pre>"},{"location":"best-practices/timestep-selection/#explicit","title":"Explicit","text":"<p>Fully explicit schemes solve both pressure and saturation explicitly. This makes each step very cheap but imposes a stricter CFL condition (both pressure and saturation waves must satisfy the CFL limit). You will need smaller timesteps than IMPES, typically by a factor of 5 to 10.</p> <p>Recommended adjustments for explicit schemes:</p> <pre><code>timer = bores.Timer(\n    initial_step_size=bores.Time(hours=1),\n    max_step_size=bores.Time(days=5),\n    min_step_size=bores.Time(milliseconds=100),\n    simulation_time=bores.Time(years=5),\n    max_cfl_number=0.5,        # More conservative for fully explicit\n    max_growth_per_step=1.2,   # Slower growth\n)\n</code></pre>"},{"location":"best-practices/timestep-selection/#implicit","title":"Implicit","text":"<p>Fully implicit schemes solve both pressure and saturation together using Newton iteration. There is no CFL stability limit, so timesteps can be much larger. However, Newton convergence can fail at very large timesteps, and accuracy degrades as the timestep grows. The adaptive controller monitors Newton iteration counts and adjusts accordingly.</p> <p>Recommended settings for implicit schemes:</p> <pre><code>timer = bores.Timer(\n    initial_step_size=bores.Time(days=5),\n    max_step_size=bores.Time(days=90),\n    min_step_size=bores.Time(days=0.1),\n    simulation_time=bores.Time(years=20),\n    max_cfl_number=5.0,         # Much higher, not a hard limit\n    max_growth_per_step=1.5,    # Can grow faster\n    ramp_up_factor=1.2,         # Additional growth when stable\n)\n</code></pre>"},{"location":"best-practices/timestep-selection/#common-problems-and-solutions","title":"Common Problems and Solutions","text":""},{"location":"best-practices/timestep-selection/#simulation-takes-too-long","title":"Simulation Takes Too Long","text":"<p>If your simulation is running slowly, the most common cause is timesteps that are too small. Check the timer's step history to see if the adaptive controller is keeping the timestep well below <code>max_step_size</code>. If so, the CFL condition is the bottleneck, and you have two options: coarsen your grid (see Grid Design) or switch to a fully implicit scheme.</p>"},{"location":"best-practices/timestep-selection/#oscillating-timestep","title":"Oscillating Timestep","text":"<p>If the timestep rapidly increases and decreases from one step to the next, the smoothing factor may be too low. Increase <code>step_size_smoothing</code> to 0.8 or 0.9 to stabilize the timestep trajectory. Also check whether wells are cycling between rate and BHP control, which creates sudden changes in flow velocities that confuse the adaptive controller.</p>"},{"location":"best-practices/timestep-selection/#simulation-crashes-at-well-startup","title":"Simulation Crashes at Well Startup","text":"<p>Well startups create sudden, localized velocity spikes that can violate the CFL condition on the very first step. Use a small initial timestep (0.01 to 0.1 days) and let the controller ramp up naturally. If the problem persists, check that the well's initial rate or BHP is physically reasonable.</p>"},{"location":"best-practices/timestep-selection/#constant-timestep-mode","title":"Constant Timestep Mode","text":"<p>For benchmarking or debugging, you may want to disable adaptive control and use a fixed timestep. Set <code>use_constant_step_size=True</code> in the <code>TimerState</code> or simply set <code>max_step_size</code> equal to <code>initial_step_size</code> and <code>min_step_size</code> to the same value. The controller will use that fixed value for every step.</p>"},{"location":"best-practices/timestep-selection/#quick-reference","title":"Quick Reference","text":"Parameter When to Adjust Direction <code>max_cfl_number</code> Oscillations, instability Lower (0.5 to 0.7) <code>max_growth_per_step</code> Timestep jumps too fast Lower (1.1 to 1.2) <code>backoff_factor</code> Too many rejected steps Lower (0.3) for faster recovery <code>min_step_size</code> Simulation stalls at minimum Lower, but investigate root cause <code>max_step_size</code> Missing transient events Lower to capture short-lived phenomena <code>step_size_smoothing</code> Erratic timestep behavior Higher (0.8 to 0.9) <code>ramp_up_factor</code> Slow recovery after transients Set to 1.1 to 1.2"},{"location":"best-practices/validation/","title":"Validation","text":""},{"location":"best-practices/validation/#overview","title":"Overview","text":"<p>A simulation result is only useful if you can trust it. Validation is the process of verifying that your simulation produces physically meaningful results that are consistent with known solutions, material balance constraints, and expected reservoir behavior. Every model should be validated before its results are used for engineering decisions, regardless of how carefully the input data was prepared.</p> <p>Validation serves two purposes. First, it catches errors in model construction: wrong units, transposed grids, incorrect well placements, or invalid fluid properties. These errors are surprisingly common and can produce results that look plausible at first glance but are quantitatively wrong. Second, it establishes confidence in the numerical solution: verifying that the grid is fine enough, the timestep is small enough, and the solver is converging to the right answer.</p> <p>This page covers three levels of validation: internal consistency checks (material balance), comparison with analytical solutions, and benchmarking against published test cases. You should perform at least the first two for every model, and the third whenever a suitable benchmark exists for your problem type.</p>"},{"location":"best-practices/validation/#material-balance-checks","title":"Material Balance Checks","text":"<p>Material balance is the most fundamental validation check. The total amount of each fluid phase in the reservoir (oil, water, gas) must be conserved: what enters through injection wells and boundaries must either accumulate in the reservoir or leave through production wells and boundaries. Any discrepancy indicates a numerical error.</p>"},{"location":"best-practices/validation/#computing-material-balance","title":"Computing Material Balance","text":"<p>The material balance error for a phase is defined as:</p> \\[ \\text{MB Error} = \\frac{|\\Delta V_{\\text{pore}} - (Q_{\\text{in}} - Q_{\\text{out}}) \\cdot \\Delta t|}{V_{\\text{pore,initial}}} \\] <p>where \\(\\Delta V_{\\text{pore}}\\) is the change in pore volume occupied by that phase, \\(Q_{\\text{in}}\\) and \\(Q_{\\text{out}}\\) are the volumetric injection and production rates at reservoir conditions, and \\(V_{\\text{pore,initial}}\\) is the initial pore volume of that phase.</p> <p>You can compute material balance using the <code>ModelAnalyst</code> class:</p> <pre><code>import bores\n\nanalyst = bores.ModelAnalyst(store=store)\n\n# Check oil material balance\noil_balance = analyst.compute_recovery_factor(phase=bores.FluidPhase.OIL)\n</code></pre>"},{"location":"best-practices/validation/#acceptable-error-levels","title":"Acceptable Error Levels","text":"<p>For engineering purposes, material balance errors should be:</p> Error Level Interpretation &lt; 0.1% Excellent. Results are reliable. 0.1% to 1% Acceptable. Monitor for drift over time. 1% to 5% Marginal. Refine grid or reduce timestep. &gt; 5% Unacceptable. Investigate cause before using results. <p>Material balance error tends to accumulate over time. A simulation with 0.01% error per step can reach 1% total error after 100 steps. Check material balance at the end of the simulation, not just at individual timesteps.</p>"},{"location":"best-practices/validation/#common-causes-of-material-balance-error","title":"Common Causes of Material Balance Error","text":"<p>Timestep too large. The explicit saturation update in IMPES introduces truncation error proportional to the timestep size. Reducing <code>max_step_size</code> or lowering <code>max_cfl_number</code> reduces material balance error.</p> <p>Grid too coarse. Coarse grids cannot resolve sharp saturation fronts accurately, leading to numerical dispersion that manifests as material balance error. Refine the grid and compare.</p> <p>Boundary condition leakage. If boundary conditions are not properly configured (for example, a constant-pressure boundary where a no-flow boundary was intended), fluid can leak in or out of the model domain, causing apparent material balance violations.</p>"},{"location":"best-practices/validation/#comparison-with-analytical-solutions","title":"Comparison with Analytical Solutions","text":"<p>Analytical solutions exist for several simple reservoir configurations. Comparing your numerical results with these solutions verifies that the simulator is solving the governing equations correctly. If the numerical and analytical solutions agree to within the expected discretization error, you can be confident that the simulator is working properly.</p>"},{"location":"best-practices/validation/#buckley-leverett-waterflood-front","title":"Buckley-Leverett (Waterflood Front)","text":"<p>The Buckley-Leverett solution gives the position of the water front as a function of time in a 1D linear waterflood. It is the classic test for saturation transport accuracy.</p> <p>To compare with Buckley-Leverett:</p> <ol> <li>Set up a 1D model (nx cells by 1 by 1) with uniform properties</li> <li>Inject water at one end, produce oil at the other</li> <li>Use straight-line relative permeability curves (Corey exponent = 1)</li> <li>Compare the saturation profile at specific times with the analytical front position</li> </ol> <p>The front position is:</p> \\[ x_f = \\frac{q \\cdot t}{\\phi \\cdot A} \\cdot f'_w(S_{wf}) \\] <p>where \\(q\\) is the injection rate, \\(\\phi\\) is porosity, \\(A\\) is the cross-sectional area, and \\(f'_w(S_{wf})\\) is the derivative of the fractional flow curve evaluated at the front saturation.</p> <p>The numerical solution should show a sharp front at approximately the correct position, with some numerical smearing that decreases as the grid is refined. If the front position is wrong or the front does not sharpen with refinement, there is a problem with the saturation transport calculation.</p>"},{"location":"best-practices/validation/#radial-flow-steady-state","title":"Radial Flow (Steady State)","text":"<p>For a single well in an infinite-acting reservoir, the steady-state pressure distribution follows Darcy's law in radial coordinates:</p> \\[ P(r) = P_{wf} + \\frac{q \\cdot \\mu \\cdot B}{2\\pi \\cdot k \\cdot h} \\cdot \\ln\\left(\\frac{r}{r_w}\\right) \\] <p>where \\(P_{wf}\\) is the well bottom-hole pressure, \\(q\\) is the flow rate, \\(\\mu\\) is viscosity, \\(B\\) is the formation volume factor, \\(k\\) is permeability, \\(h\\) is the net pay, and \\(r_w\\) is the wellbore radius.</p> <p>To test this in BORES, set up a 2D model with a single well at the center and constant-pressure boundaries at the edges. Run to steady state and compare the pressure profile along a radial line from the well to the boundary with the analytical solution.</p>"},{"location":"best-practices/validation/#material-balance-time","title":"Material Balance Time","text":"<p>For depletion-drive reservoirs (no injection, no aquifer), the pressure decline follows the material balance equation:</p> \\[ P = P_i - \\frac{N_p \\cdot B_o}{c_t \\cdot V_p} \\] <p>where \\(P_i\\) is the initial pressure, \\(N_p\\) is cumulative oil production at surface conditions, \\(B_o\\) is the oil formation volume factor, \\(c_t\\) is total compressibility, and \\(V_p\\) is pore volume.</p> <p>This is a good first check for any depletion model. Plot pressure versus cumulative production and compare with the straight line predicted by the material balance equation.</p>"},{"location":"best-practices/validation/#grid-convergence-study","title":"Grid Convergence Study","text":"<p>A grid convergence study verifies that your results are not significantly affected by the grid resolution. The procedure is straightforward:</p> <ol> <li>Run your model at the current resolution</li> <li>Refine the grid by a factor of 2 in each direction (using more cells, not changing cell values)</li> <li>Run the refined model with the same configuration</li> <li>Compare key outputs (recovery factor, breakthrough time, pressure at a monitoring point)</li> </ol> <p>If the results change by less than 5%, your original resolution is adequate. If they change by more than 5%, refine further until convergence is achieved.</p> <pre><code>import bores\nimport numpy as np\n\n# Coarse model\nporosity_coarse = bores.build_uniform_grid((10, 10, 5), 0.20)\n# Fine model (2x refinement)\nporosity_fine = bores.build_uniform_grid((20, 20, 10), 0.20)\n</code></pre> <p>Cost of Grid Refinement</p> <p>Doubling the grid in all three dimensions creates 8x as many cells and typically requires 2x smaller timesteps (for IMPES), resulting in 16x more total computation. Plan your convergence study accordingly and use coarsening (<code>bores.coarsen_grid</code>) to quickly test multiple resolutions.</p>"},{"location":"best-practices/validation/#spe-benchmark-cases","title":"SPE Benchmark Cases","text":"<p>The Society of Petroleum Engineers (SPE) has published several benchmark comparison cases that are widely used to validate reservoir simulators. BORES includes setups for some of these cases in the <code>benchmarks/</code> directory.</p>"},{"location":"best-practices/validation/#spe-1-gas-depletion","title":"SPE 1: Gas Depletion","text":"<p>The SPE 1 problem is a simple gas reservoir under depletion. It tests basic single-phase gas flow, compressibility effects, and gas PVT calculations. This is the simplest benchmark and a good starting point for validating a new simulator installation.</p> <p>The key validation targets are:</p> <ul> <li>Pressure decline curve over the production period</li> <li>Gas production rate over time</li> <li>Cumulative gas production at the end of the simulation</li> </ul>"},{"location":"best-practices/validation/#spe-9-three-phase-flow","title":"SPE 9: Three-Phase Flow","text":"<p>The SPE 9 problem involves three-phase flow with gas injection. It tests the interaction between oil, water, and gas phases, including gravity segregation and three-phase relative permeability. This is a more demanding benchmark that exercises most of the simulator's capabilities.</p>"},{"location":"best-practices/validation/#spe-10-heterogeneous-model","title":"SPE 10: Heterogeneous Model","text":"<p>The SPE 10 problem uses a highly heterogeneous permeability field with extreme contrasts (up to 7 orders of magnitude). It tests the solver's ability to handle ill-conditioned systems and the grid's ability to capture channelized flow. This is the most challenging standard benchmark.</p>"},{"location":"best-practices/validation/#validation-checklist","title":"Validation Checklist","text":"<p>Use this checklist when validating a new model:</p> <ol> <li> <p>Material balance: Compute and verify that total material balance error is below 1% at the end of the simulation.</p> </li> <li> <p>Pressure reasonableness: Check that pressures stay positive, are below the initial pressure for depletion, and are above the initial pressure for injection. Pressures outside these bounds indicate a model error.</p> </li> <li> <p>Saturation bounds: Verify that saturations remain between their residual values and 1.0 in every cell at every timestep. Saturations outside these bounds indicate a numerical stability issue.</p> </li> <li> <p>Production rates: Check that production rates are positive for production wells and negative for injection wells (or vice versa, depending on sign convention). A production well that switches to injection indicates a pressure configuration error.</p> </li> <li> <p>Grid convergence: Run at least one coarsened and one refined version to verify that results are grid-independent.</p> </li> <li> <p>Analytical comparison: If an analytical solution exists for your problem configuration, compare against it.</p> </li> <li> <p>Conservation of volume: The total pore volume times the sum of saturations should equal the total pore volume in every cell (saturations sum to 1.0).</p> </li> <li> <p>Physical plausibility: Do the results make physical sense? Does water move downward under gravity? Does gas rise? Does the displacement front move at roughly the expected velocity? Does pressure stabilize at the expected value?</p> </li> </ol>"},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#overview","title":"Overview","text":"<p>This section provides complete, runnable simulation examples that demonstrate BORES in realistic workflows. Each example includes the full model setup, simulation execution, results analysis, and visualization, with explanations of the physical reasoning behind each step.</p> <p>The examples are designed to be self-contained. You can copy any example into a Python script and run it directly. All examples use the BORES public API with correct imports, and produce output that you can inspect, modify, and build upon for your own work.</p> <p>If you are new to BORES, start with the Tutorials section, which introduces concepts progressively. The examples here assume you are comfortable with the basics (model construction, well placement, running simulations) and focus on complete end-to-end workflows that illustrate how all the pieces fit together.</p>"},{"location":"examples/#running-examples","title":"Running Examples","text":"<p>All examples use standard BORES imports and produce results using the simulation API. To run any example, make sure you have BORES installed:</p> <pre><code>uv add bores-framework\n</code></pre> <p>Then copy the code into a Python script or Jupyter notebook and execute it. Most examples complete in under a minute on a modern laptop. Examples that produce visualizations use the BORES visualization API (<code>bores.make_series_plot</code>, <code>bores.visualization.plotly2d</code>, <code>bores.visualization.plotly3d</code>), which requires Plotly to be installed (included as a BORES dependency).</p>"},{"location":"examples/#available-examples","title":"Available Examples","text":"<p>The <code>benchmarks/</code> directory in the BORES repository contains complete simulation setups, including the SPE benchmark cases:</p> Example Description Physics SPE 1 Gas reservoir depletion Single-phase gas, compressibility, PVT <p>Additional examples are available in the <code>scenarios/</code> directory as marimo notebooks that you can run interactively.</p>"},{"location":"examples/#example-structure","title":"Example Structure","text":"<p>Each complete example follows a consistent structure that mirrors a real simulation workflow:</p> <ol> <li>Model initialization: Define the grid, rock properties, and fluid properties using <code>bores.reservoir_model()</code>.</li> <li>Well configuration: Place wells, assign controls, and optionally define schedules using <code>bores.injection_well()</code>, <code>bores.production_well()</code>, and <code>bores.wells_()</code>.</li> <li>Simulation setup: Create a <code>Config</code> with timer, wells, solver, and other parameters.</li> <li>Execution: Run the simulation and collect results using <code>bores.run()</code> or <code>StateStream</code>.</li> <li>Analysis: Compute recovery factors, plot production profiles, and visualize spatial distributions.</li> </ol>"},{"location":"examples/#building-your-own-examples","title":"Building Your Own Examples","text":"<p>When building your own simulation cases, refer to the following documentation:</p> <ul> <li>Building Reservoir Models for detailed model construction guidance</li> <li>User Guide for comprehensive coverage of every component</li> <li>Best Practices for grid design, timestep, and solver recommendations</li> <li>API Reference for function signatures and parameter details</li> </ul> <p>If you create an interesting simulation case that demonstrates BORES capabilities, consider contributing it to the project.</p>"},{"location":"fundamentals/","title":"Fundamentals","text":"<p>Before you start building reservoir models and running simulations, it helps to understand the core concepts that BORES is built on. This section provides background knowledge for users who may be new to reservoir simulation, new to Python-based scientific computing, or both.</p> <p>If you are a petroleum engineer, you will find explanations of how BORES translates familiar reservoir engineering concepts into Python code - how grids are stored as NumPy arrays, how the simulation loop works as a Python generator, and how the IMPES method is implemented under the hood.</p> <p>If you are a Python developer, you will find approachable explanations of the petroleum engineering fundamentals - what reservoir simulation actually models, why we care about fluid properties at different pressures, and what the black-oil model assumes about the physics of underground flow.</p> <p>Either way, spending 20 minutes here will save you hours of confusion later.</p>"},{"location":"fundamentals/#what-you-will-learn","title":"What You Will Learn","text":"Page Description What is Reservoir Simulation? The big picture - why we simulate reservoirs, what physics are involved, and where BORES fits in the landscape of simulation tools. The Black-Oil Model The fluid model at the heart of BORES - three phases, solution gas, formation volume factors, and PVT relationships. Grid Systems How BORES divides a reservoir into discrete cells, stores properties on those cells, and handles boundaries with ghost-cell padding. How BORES Runs a Simulation A step-by-step walkthrough of the IMPES method - from pressure solve to saturation update to convergence checking. <p>Tip</p> <p>You do not need to read these pages in order, but if you are brand new to reservoir simulation, starting with What is Reservoir Simulation? and working through sequentially will give you the smoothest experience.</p>"},{"location":"fundamentals/black-oil-model/","title":"The Black-Oil Model","text":""},{"location":"fundamentals/black-oil-model/#what-is-the-black-oil-model","title":"What Is the Black-Oil Model?","text":"<p>The black-oil model is the most widely used fluid description in reservoir simulation, and for good reason. It strikes a balance between physical accuracy and computational efficiency that makes it suitable for the vast majority of conventional oil and gas reservoirs worldwide. If you have worked with or studied reservoir engineering, the black-oil model is almost certainly the first framework you encountered for describing how oil, water, and gas behave underground.</p> <p>At its core, the black-oil model treats the hydrocarbon system as two surface components - stock-tank oil and surface gas - that can distribute themselves across three phases: an oil phase, a water phase, and a gas phase. The key simplification is that the composition of each component is fixed. Stock-tank oil is always the same oil, and surface gas is always the same gas. What changes with pressure and temperature is how much gas dissolves in the oil, not the chemical makeup of either component. This is in contrast to compositional models, which track individual hydrocarbon species (methane, ethane, propane, and heavier fractions) and allow the composition to vary throughout the reservoir.</p> <p>The term \"black oil\" has historical roots. Early reservoir engineers observed that many crude oils appeared dark (nearly black) and had relatively simple phase behavior that could be described without detailed compositional analysis. The name stuck, even though the model applies equally well to light oils and some volatile systems. What makes a fluid system \"black-oil compatible\" is not its color but whether its phase behavior can be adequately described using pressure-dependent properties like formation volume factor and solution gas-oil ratio, rather than requiring a full equation-of-state calculation.</p> <p>BORES is fundamentally a black-oil simulator. Every fluid property calculation, every PVT correlation, and every conservation equation in the framework is built on the black-oil assumptions. Understanding this model is therefore essential for using BORES effectively and interpreting its results correctly.</p>"},{"location":"fundamentals/black-oil-model/#three-phases-oil-water-and-gas","title":"Three Phases: Oil, Water, and Gas","text":"<p>In the black-oil formulation, the pore space of a reservoir rock is shared among three immiscible fluid phases. Each phase plays a distinct role in the physics of fluid flow and recovery, and each comes with its own set of properties that the simulator must track.</p> <p>Oil is the target hydrocarbon - the fluid you are trying to recover and sell. Under reservoir conditions, oil is a compressed liquid that may contain a significant amount of dissolved natural gas. The amount of dissolved gas depends on pressure: at high pressure, the oil holds more gas in solution, and at low pressure, gas comes out of solution and forms a separate free gas phase. Oil properties like density, viscosity, and formation volume factor all depend on how much gas is dissolved, which in turn depends on pressure. This coupling between pressure and oil properties is one of the central features of the black-oil model.</p> <p>Water is present in two forms. Connate water (also called irreducible water) is the water that was trapped in the pore spaces when the reservoir formed - it has been there for millions of years and typically cannot be mobilized. Injected water is the water you pump into the reservoir through injection wells to maintain pressure and sweep oil toward producers. In the black-oil model, water is treated as a slightly compressible liquid with properties that depend weakly on pressure and temperature. Gas can dissolve in water too, though typically in much smaller quantities than in oil.</p> <p>Gas can exist as free gas (a separate phase in the pore space) or as dissolved gas (within the oil phase or, to a lesser extent, the water phase). Free gas appears when reservoir pressure drops below the bubble point - the pressure at which dissolved gas begins to come out of solution. In an undersaturated reservoir (pressure above bubble point), there is no free gas; all gas is dissolved in the oil. In a saturated reservoir (pressure at or below bubble point), gas has liberated from the oil and exists as its own phase. The gas phase is highly compressible, and its properties change dramatically with pressure.</p> <p>Saturation Constraint</p> <p>The three phase saturations must always sum to unity: \\(S_o + S_w + S_g = 1.0\\). This is a fundamental constraint in the black-oil formulation. Pore space is always 100% filled with fluid - there are no voids or partially filled pores. Even during pressure depletion, the saturations still sum to one; what changes is the pressure, not the total occupancy of the pore space.</p>"},{"location":"fundamentals/black-oil-model/#solution-gas-and-the-gas-oil-ratio","title":"Solution Gas and the Gas-Oil Ratio","text":"<p>The solution gas-oil ratio \\(R_s\\) is one of the most important parameters in the black-oil model. It describes how much gas is dissolved in the oil phase at a given pressure, expressed as standard cubic feet of gas per stock-tank barrel of oil (scf/STB). You can think of it as a measure of how \"gassy\" the oil is at a particular pressure.</p> <p>The relationship between \\(R_s\\) and pressure is straightforward in concept but critically important in practice:</p> \\[R_s = R_s(p)\\] <p>When reservoir pressure is above the bubble point pressure \\(p_b\\), all of the gas that was originally dissolved in the oil remains in solution. In this undersaturated regime, \\(R_s\\) stays constant at its initial value \\(R_{si}\\) regardless of how much higher the pressure goes. The oil is not \"full\" of gas in any absolute sense, but there is no additional free gas available to dissolve, so \\(R_s\\) does not increase.</p> <p>When pressure drops below the bubble point, the oil can no longer hold all of its dissolved gas. Gas begins to come out of solution, forming a free gas phase. In this saturated regime, \\(R_s\\) decreases with decreasing pressure. The released gas reduces the oil volume, increases oil viscosity (because the light dissolved gas was acting as a viscosity reducer), and creates a gas phase that competes with oil for flow through the pore space. This gas liberation process is one of the primary drive mechanisms in many oil reservoirs.</p> \\[R_s(p) = \\begin{cases} R_{si} &amp; \\text{if } p \\geq p_b \\\\ R_s(p) &lt; R_{si} &amp; \\text{if } p &lt; p_b \\end{cases}\\] <p>Why the Bubble Point Matters</p> <p>The bubble point pressure \\(p_b\\) is the single most important threshold in the black-oil model. Above it, the reservoir behaves as a single-phase (undersaturated) system with relatively simple physics. Below it, gas liberation creates a two-phase (saturated) system with more complex flow behavior, including gas-oil relative permeability effects and potentially gas coning or gas cap expansion. Getting \\(p_b\\) right is critical for accurate simulation results.</p> <p>In BORES, the solution GOR is computed from correlations (such as Standing or Vasquez-Beggs) or looked up from PVT tables that you provide. When you construct a model using <code>bores.reservoir_model()</code>, you can supply either <code>oil_bubble_point_pressure_grid</code> or <code>solution_gas_to_oil_ratio_grid</code> (or both), and the factory function will derive the missing quantity using the appropriate correlation.</p>"},{"location":"fundamentals/black-oil-model/#formation-volume-factors","title":"Formation Volume Factors","text":"<p>Formation volume factors (FVFs) are the conversion factors between reservoir conditions and surface (standard) conditions. They are essential because the volumes you measure at the surface - stock-tank barrels of oil, standard cubic feet of gas - are not the same as the volumes those fluids occupy in the reservoir at elevated pressure and temperature.</p> <p>The oil formation volume factor \\(B_o\\) converts reservoir oil volume to surface oil volume:</p> \\[B_o = \\frac{V_{o,\\text{reservoir}}}{V_{o,\\text{surface}}}\\] <p>\\(B_o\\) is always greater than 1.0 for live oil (oil containing dissolved gas). At reservoir conditions, the dissolved gas expands the oil, making each barrel of stock-tank oil occupy more than one barrel of space in the reservoir. A typical value might be 1.2 to 1.5 rb/STB. Above the bubble point, \\(B_o\\) decreases slightly with increasing pressure due to liquid compression. Below the bubble point, \\(B_o\\) decreases as gas comes out of solution and the oil shrinks.</p> <p>The gas formation volume factor \\(B_g\\) converts reservoir gas volume to surface gas volume:</p> \\[B_g = \\frac{V_{g,\\text{reservoir}}}{V_{g,\\text{surface}}}\\] <p>\\(B_g\\) is much less than 1.0 because gas at reservoir conditions is compressed into a much smaller volume than it occupies at the surface. Typical values range from 0.002 to 0.02 rb/scf. As pressure increases, gas compresses further, and \\(B_g\\) decreases.</p> <p>The water formation volume factor \\(B_w\\) is close to 1.0 because water is nearly incompressible. Typical values are 1.0 to 1.07 rb/STB. It accounts for the slight thermal expansion and dissolved gas effects on water volume.</p> <p>Surface vs. Reservoir Volumes</p> <p>When you see production rates reported in \"STB/day\" or \"Mscf/day,\" those are surface volumes. When working with flow equations inside the simulator, you need reservoir volumes. The formation volume factors bridge these two worlds. BORES handles the conversions internally, but understanding FVFs will help you make sense of production reports and material balance calculations.</p>"},{"location":"fundamentals/black-oil-model/#viscosity","title":"Viscosity","text":"<p>Fluid viscosity - the resistance to flow - is another pressure-dependent property that the black-oil model must track for each phase. Viscosity directly controls how fast each phase moves through the rock via Darcy's law, where flow rate is inversely proportional to viscosity.</p> <p>Oil viscosity is the most complex of the three because it depends on pressure, temperature, and the amount of dissolved gas. There are two distinct regimes. Dead oil is oil with no dissolved gas. Its viscosity depends only on temperature and API gravity, and it is typically high - several centipoise to thousands of centipoise for heavy oils. Live oil is oil containing dissolved gas. The dissolved gas acts as a solvent, reducing viscosity significantly. A dead oil viscosity of 5 cP might drop to 1 cP with gas in solution.</p> <p>Above the bubble point, oil viscosity increases with pressure because the liquid is being compressed. Below the bubble point, oil viscosity increases as gas comes out of solution - the oil loses its internal \"solvent\" and becomes more viscous. This creates a viscosity minimum at the bubble point, which is a distinctive feature of black-oil systems.</p> <p>Gas viscosity is typically much lower than oil viscosity - on the order of 0.01 to 0.03 cP at reservoir conditions. It increases with pressure (unlike liquids) because gas molecules interact more at higher densities. BORES computes gas viscosity using the Lee-Gonzalez-Eakin correlation or CoolProp thermodynamic calculations.</p> <p>Water viscosity is on the order of 0.3 to 1.0 cP at reservoir conditions, decreasing with temperature and increasing slightly with pressure and salinity. It is the most predictable of the three phase viscosities.</p>"},{"location":"fundamentals/black-oil-model/#black-oil-assumptions","title":"Black-Oil Assumptions","text":"<p>The black-oil model rests on several key assumptions that define its domain of applicability. Understanding these assumptions helps you know when the model is appropriate and when you might need a different approach.</p> <ol> <li> <p>Three components, three phases. The hydrocarbon system is described by two components (stock-tank oil and surface gas) plus water. These distribute across three phases (oil, water, gas). No other components are tracked.</p> </li> <li> <p>Gas dissolves in oil (and optionally in water). The only inter-phase mass transfer allowed is gas dissolving in or liberating from the oil phase (and a small amount in water). Oil does not evaporate into the gas phase, and oil and water do not mix.</p> </li> <li> <p>Oil and water are immiscible. Under normal black-oil conditions, oil and water form separate, distinct phases with a clear interface at the pore scale. They do not dissolve into each other.</p> </li> <li> <p>Isothermal conditions. Temperature is assumed constant throughout the simulation. There is no energy equation - heat conduction and convection are not modeled. Temperature may vary spatially (as an initial condition), but it does not change over time.</p> </li> <li> <p>Local thermodynamic equilibrium. At every point in the reservoir, the fluid phases are assumed to be in thermodynamic equilibrium. Gas dissolves in oil instantly - there are no kinetic effects or time delays in mass transfer.</p> </li> <li> <p>Pressure-dependent properties. All fluid properties (\\(B_o\\), \\(B_g\\), \\(R_s\\), \\(\\mu_o\\), \\(\\mu_g\\), etc.) are functions of pressure only (at a given temperature). They do not depend on composition because composition is implicitly fixed by the two-component assumption.</p> </li> </ol> <p>Assumption Violations</p> <p>Violating these assumptions does not always mean the black-oil model is useless - it means the results become less accurate. For moderately volatile oils or lean gas injection, the black-oil model may still give reasonable results with appropriate tuning. But for near-critical fluids, rich gas condensate, or thermal processes, you should use a compositional or thermal simulator instead.</p>"},{"location":"fundamentals/black-oil-model/#when-to-use-black-oil-vs-compositional","title":"When to Use Black-Oil vs. Compositional","text":"<p>Choosing between a black-oil and a compositional simulator is one of the first decisions in any simulation study. The choice depends on the reservoir fluid, the recovery process, and the accuracy requirements.</p> <p>Use a black-oil model (like BORES) when you are working with conventional oil reservoirs under primary depletion, waterflooding, or simple immiscible gas injection. The black-oil model is also appropriate for dry gas reservoirs and for screening studies where speed matters more than compositional accuracy. Most field development planning for conventional reservoirs worldwide is done with black-oil simulators.</p> <p>Use a compositional model when the fluid phase behavior depends on composition - not just pressure. This includes gas condensate reservoirs (where liquid drops out of gas below the dewpoint), volatile oil reservoirs (where the oil contains so much dissolved gas that the black-oil two-component assumption breaks down), and rich gas injection processes (where the injected gas mixes with reservoir oil and creates intermediate-composition phases). CO2 flooding for enhanced oil recovery (EOR) also generally requires compositional modeling, though BORES offers a miscible extension using the Todd-Longstaff model that can capture first-order miscibility effects within the black-oil framework.</p> <p>The computational cost difference is substantial. A compositional model with 6-10 components can be 5-20x slower than an equivalent black-oil model for the same grid size, because it must solve additional conservation equations for each component and perform flash calculations at every cell and every timestep. For large field-scale models with millions of cells, this cost difference can be the deciding factor.</p>"},{"location":"fundamentals/black-oil-model/#how-bores-implements-black-oil-physics","title":"How BORES Implements Black-Oil Physics","text":"<p>BORES provides two pathways for computing black-oil PVT properties: correlations and tables. Both are first-class options, and you can choose whichever fits your workflow.</p> <p>PVT correlations are empirical equations that compute fluid properties from pressure, temperature, and basic fluid characterization parameters (API gravity, gas gravity, GOR). BORES ships with industry-standard correlations including Standing (solution GOR, bubble point), Vasquez-Beggs (oil FVF, oil viscosity), Lee-Gonzalez-Eakin (gas viscosity), and several z-factor methods (Papay, Dranchuk-Abou-Kassem, Hall-Yarborough). When you build a model using <code>bores.reservoir_model()</code> and omit optional property grids, the factory function automatically fills them in using the appropriate correlations. This makes it easy to get started - you only need to provide the minimum set of inputs.</p> <p>PVT tables (<code>bores.PVTTables</code>) let you supply tabulated property data from laboratory measurements or external PVT software. The tables are passed to <code>bores.reservoir_model()</code> via the <code>pvt_tables</code> parameter, and BORES will use table interpolation instead of correlations for any property that the tables cover. This gives you maximum control and accuracy when you have high-quality lab data.</p> <pre><code>import bores\n\n# The reservoir_model factory automatically computes PVT properties\n# from correlations when they are not explicitly provided.\n# For example, if you omit gas_viscosity_grid, BORES uses the\n# Lee-Gonzalez-Eakin correlation internally.\nmodel = bores.reservoir_model(\n    grid_shape=(20, 20, 5),\n    cell_dimension=(100.0, 100.0),\n    thickness_grid=thickness,\n    pressure_grid=pressure,\n    temperature_grid=temperature,\n    oil_viscosity_grid=oil_viscosity,\n    oil_bubble_point_pressure_grid=bubble_point,\n    oil_specific_gravity_grid=oil_sg,\n    # ... other required grids ...\n    # gas_viscosity_grid is omitted - computed from correlations\n    # water_viscosity_grid is omitted - computed from correlations\n    # oil_formation_volume_factor_grid is omitted - computed from correlations\n)\n</code></pre> <p>During a simulation run, PVT properties are updated at each timestep as pressure changes. BORES recomputes formation volume factors, viscosities, solution GOR, and compressibilities using either the correlations or the tables you provided. This ensures that the fluid description remains physically consistent throughout the simulation, even as pressure evolves substantially from its initial value.</p> <p>Providing vs. Computing Properties</p> <p>You generally want to provide the properties you have high confidence in (from lab data or calibrated correlations) and let BORES compute the rest. The <code>bores.reservoir_model()</code> factory function is designed for exactly this workflow - it accepts dozens of optional property grids and fills in anything you leave out. See the Fluid Properties guide for a detailed walkthrough.</p>"},{"location":"fundamentals/grid-systems/","title":"Grid Systems","text":""},{"location":"fundamentals/grid-systems/#why-divide-the-reservoir-into-cells","title":"Why Divide the Reservoir into Cells?","text":"<p>A real petroleum reservoir is a continuous body of porous rock extending over thousands of acres and hundreds of feet of thickness. The fluid properties, rock properties, and flow conditions vary continuously across this volume. But continuous systems cannot be solved analytically for realistic geometries - you need to discretize them. This means dividing the reservoir into a finite number of small blocks (cells), assigning properties to each block, and solving the governing equations on this discrete representation.</p> <p>Each cell in the grid acts as a tiny control volume. Within each cell, properties like porosity, permeability, pressure, and saturation are assumed to be uniform - they are represented by a single value at the cell center. Flow between adjacent cells is computed from the pressure difference between their centers, using Darcy's law and the properties at the shared interface. The finer you make the grid (more cells, smaller cells), the better you approximate the continuous reality - but the more equations you have to solve and the longer the simulation takes.</p> <p>BORES uses a structured Cartesian grid, which is the simplest and most common grid type in reservoir simulation. \"Structured\" means cells are arranged in a regular pattern indexed by integers \\((i, j, k)\\). \"Cartesian\" means the cells are rectangular blocks aligned with the coordinate axes. This makes the data structures simple (3D NumPy arrays), the neighbor relationships trivial (cell \\((i,j,k)\\) neighbors \\((i \\pm 1, j, k)\\), \\((i, j \\pm 1, k)\\), \\((i, j, k \\pm 1)\\)), and the finite difference stencils straightforward to implement.</p> <p>The trade-off is geometric flexibility. Structured Cartesian grids cannot conform to curved reservoir boundaries, faults at arbitrary angles, or complex geological features without staircase approximations. For most practical simulations - especially educational, research, and screening studies - this limitation is acceptable. When you need complex geometry, you can use BORES in combination with external grid generation tools, or rely on the fracture and fault features that modify transmissibility at cell interfaces.</p>"},{"location":"fundamentals/grid-systems/#cartesian-grid-convention","title":"Cartesian Grid Convention","text":"<p>BORES uses a specific coordinate convention that you should internalize before building models, because it affects how you specify well locations, interpret results, and visualize output.</p> <p>The grid is indexed by three integers: \\(i\\) (x-direction, columns), \\(j\\) (y-direction, rows), and \\(k\\) (z-direction, layers/depth). These correspond to the first, second, and third axes of a 3D NumPy array, respectively.</p> <pre><code>Grid Coordinate System:\n\n         j (y) increases\n            \u2191\n            |\n            |  k (z) increases downward (into the page/screen)\n            |  /\n            | /\n            |/________\u2192 i (x) increases\n          (0,0,0)\n</code></pre> <p>Several important conventions to note:</p> <ul> <li>Cell \\((0, 0, 0)\\) is the top-left-shallow corner - the cell at the minimum x, minimum y, and shallowest depth.</li> <li>The z-axis points downward. \\(k = 0\\) is the shallowest (topmost) layer, and \\(k\\) increases with depth. This is the standard depth-positive convention used throughout the petroleum industry.</li> <li>Indices are zero-based, following Python and NumPy conventions. The first cell is \\((0, 0, 0)\\), not \\((1, 1, 1)\\).</li> </ul> <p>Depth-Positive Convention</p> <p>The z-axis in BORES increases downward, which means that a depth grid has larger values for deeper cells. This matches the petroleum engineering convention where depth is measured from the surface downward. If you are coming from a physics or mathematics background where z typically points upward, keep this in mind when interpreting elevation and depth grids.</p> <p>When you access a property grid like <code>pressure_grid[i, j, k]</code>, you are reading the pressure at cell \\((i, j, k)\\). When you specify a well location as <code>(5, 3, 0)</code>, you are placing it in the cell at \\(i=5\\), \\(j=3\\), \\(k=0\\) (the shallowest layer).</p>"},{"location":"fundamentals/grid-systems/#grid-shape","title":"Grid Shape","text":"<p>The shape of a BORES grid is always expressed as a tuple of three integers: <code>(nx, ny, nz)</code>, where <code>nx</code> is the number of cells in the x-direction, <code>ny</code> in the y-direction, and <code>nz</code> in the z-direction (depth). Even for lower-dimensional models, you still use a 3D tuple - you simply set the unused dimensions to 1.</p> <p>Here are common configurations:</p> Model Type Grid Shape Total Cells Description 1D (horizontal) <code>(100, 1, 1)</code> 100 One row of 100 cells along x 1D (vertical) <code>(1, 1, 50)</code> 50 One column of 50 cells along z 2D (areal) <code>(50, 50, 1)</code> 2,500 A single-layer 50x50 areal model 2D (cross-section) <code>(100, 1, 20)</code> 2,000 A vertical cross-section along x 3D (typical) <code>(30, 30, 10)</code> 9,000 Standard 3D model with 10 layers 3D (fine) <code>(100, 100, 50)</code> 500,000 Fine-grid 3D model <p>The cell dimensions (the physical size of each cell) are specified separately via the <code>cell_dimension</code> parameter, which is a tuple of <code>(dx, dy)</code> in feet. Cell thickness in the z-direction is specified per-cell using the <code>thickness_grid</code>, allowing layers of varying thickness.</p> <p>Grid Size and Performance</p> <p>Simulation time scales roughly with the number of cells. A 100x100x50 grid (500,000 cells) will take significantly longer than a 20x20x5 grid (2,000 cells). When developing and testing your model, start with a coarse grid to verify that the setup is correct, then refine once you are confident in the configuration. You can use <code>bores.coarsen_grid()</code> to downsample an existing fine grid for testing.</p>"},{"location":"fundamentals/grid-systems/#cell-properties","title":"Cell Properties","text":"<p>In a finite difference simulator like BORES, all intensive properties are stored at cell centers. Each cell carries its own values for:</p> <ul> <li>Pressure (psi) - the oil-phase pressure at the cell center</li> <li>Saturations - oil, water, and gas saturations (fractions that sum to 1.0)</li> <li>Porosity (fraction) - the fraction of the cell volume that is pore space</li> <li>Permeability (mD) - how easily fluid flows through the rock, which can be different in x, y, and z directions (anisotropic)</li> <li>Temperature (degrees F) - the reservoir temperature at the cell</li> <li>Fluid properties - viscosity, density, compressibility, formation volume factor, etc.</li> </ul> <p>All of these are stored as 3D NumPy arrays with shape <code>(nx, ny, nz)</code>. For example, if your grid shape is <code>(30, 30, 10)</code>, then <code>pressure_grid</code> is a NumPy array of shape <code>(30, 30, 10)</code> containing 9,000 pressure values.</p> <p>Transmissibility - the quantity that controls flow between two adjacent cells - is a face property, not a cell-center property. BORES computes transmissibility at each cell interface from the permeabilities and geometries of the two cells sharing that face, using a harmonic mean to properly handle permeability contrasts. This calculation happens internally during the simulation and is not something you typically need to set up manually.</p> <p>Harmonic Mean for Transmissibility</p> <p>When computing flow between two cells with different permeabilities, BORES uses the harmonic mean rather than the arithmetic mean. The harmonic mean ensures that a low-permeability cell acts as a flow barrier, which is physically correct. If cell A has permeability 1000 mD and cell B has 1 mD, the effective interface permeability is about 2 mD (dominated by the low-perm cell), not 500.5 mD (the arithmetic average).</p>"},{"location":"fundamentals/grid-systems/#grid-construction-in-bores","title":"Grid Construction in BORES","text":"<p>BORES provides several utility functions for building property grids. These are designed to be composed together - you build each property grid independently and pass them all to <code>bores.reservoir_model()</code>.</p>"},{"location":"fundamentals/grid-systems/#uniform-grids","title":"Uniform Grids","text":"<p>The simplest grid type fills every cell with the same value. This is useful for homogeneous models and for initial conditions.</p> <pre><code>import bores\n\ngrid_shape = (30, 30, 10)\n\n# Uniform pressure of 3000 psi everywhere\npressure = bores.build_uniform_grid(grid_shape, value=3000.0)\n\n# Uniform porosity of 20%\nporosity = bores.build_uniform_grid(grid_shape, value=0.20)\n\n# Uniform thickness of 15 ft per layer\nthickness = bores.build_uniform_grid(grid_shape, value=15.0)\n</code></pre> <p>The <code>bores.build_uniform_grid()</code> function returns a NumPy array of the specified shape, filled with the given value and cast to the active precision (32-bit by default).</p>"},{"location":"fundamentals/grid-systems/#layered-grids","title":"Layered Grids","text":"<p>Real reservoirs often have properties that vary by layer - each geological formation has its own porosity, permeability, and thickness. <code>bores.build_layered_grid()</code> lets you specify a value for each layer along any axis.</p> <pre><code>import bores\n\ngrid_shape = (30, 30, 5)\n\n# Porosity varies by depth layer (z-direction):\n# Layer 0 (shallowest): 0.22, Layer 1: 0.18, ..., Layer 4 (deepest): 0.12\nporosity = bores.build_layered_grid(\n    grid_shape=grid_shape,\n    layer_values=[0.22, 0.18, 0.15, 0.14, 0.12],\n    orientation=bores.Orientation.Z,\n)\n\n# Permeability varies in the x-direction (e.g., facies change):\n# 30 values, one for each column along x\nimport numpy as np\nperm_values = np.linspace(200.0, 50.0, 30)  # Decreasing from left to right\nperm_x = bores.build_layered_grid(\n    grid_shape=grid_shape,\n    layer_values=perm_values,\n    orientation=bores.Orientation.X,\n)\n</code></pre> <p>The <code>orientation</code> parameter accepts <code>bores.Orientation.X</code>, <code>bores.Orientation.Y</code>, or <code>bores.Orientation.Z</code>, and the number of layer values must match the number of cells in that direction.</p>"},{"location":"fundamentals/grid-systems/#depth-and-elevation-grids","title":"Depth and Elevation Grids","text":"<p>BORES can compute depth or elevation grids from a thickness grid. These are needed for gravity calculations (hydrostatic pressure gradients) and structural dip.</p> <pre><code>import bores\n\ngrid_shape = (30, 30, 10)\nthickness = bores.build_uniform_grid(grid_shape, value=15.0)\n\n# Depth grid: measured from top downward (depth-positive)\n# Cell centers are placed based on cumulative thickness\ndepth = bores.build_depth_grid(thickness)\n# depth[0, 0, 0] = 7.5 (center of first 15-ft layer)\n# depth[0, 0, 1] = 22.5 (center of second layer)\n# depth[0, 0, 9] = 142.5 (center of tenth layer)\n\n# Elevation grid: measured from bottom upward\nelevation = bores.build_elevation_grid(thickness)\n</code></pre> <p>The depth grid is used internally by the simulator to compute gravity terms in the pressure equation. The <code>build_depth_grid()</code> function places cell centers at the midpoint of each layer's cumulative thickness.</p>"},{"location":"fundamentals/grid-systems/#structural-dip","title":"Structural Dip","text":"<p>Real reservoirs are rarely perfectly flat. The <code>bores.apply_structural_dip()</code> function tilts an elevation or depth grid by a specified angle and azimuth, simulating a dipping reservoir structure.</p> <pre><code>import bores\n\ngrid_shape = (30, 30, 10)\ncell_dimension = (100.0, 100.0)\nthickness = bores.build_uniform_grid(grid_shape, value=15.0)\ndepth = bores.build_depth_grid(thickness)\n\n# Apply a 5-degree dip toward the east (azimuth = 90 degrees)\ndipped_depth = bores.apply_structural_dip(\n    elevation_grid=depth,\n    cell_dimension=cell_dimension,\n    elevation_direction=\"downward\",\n    dip_angle=5.0,\n    dip_azimuth=90.0,\n)\n</code></pre> <p>The dip azimuth follows the compass convention: 0 degrees is North, 90 degrees is East, 180 degrees is South, and 270 degrees is West. The surface tilts downward in the azimuth direction, meaning cells in that direction become deeper.</p> <p>Start Without Dip</p> <p>When building a new model, set <code>dip_angle=0.0</code> initially and add structural dip only after you have verified that the flat model works correctly. Gravity effects from dip can complicate debugging, especially for new users. You can also disable dip effects during simulation by setting <code>disable_structural_dip=True</code> in the <code>Config</code>.</p>"},{"location":"fundamentals/grid-systems/#grid-coarsening","title":"Grid Coarsening","text":"<p>When you have a fine-grid model and want a coarser version for faster testing, <code>bores.coarsen_grid()</code> aggregates blocks of cells:</p> <pre><code>import bores\nimport numpy as np\n\n# Start with a fine grid\nfine_porosity = np.random.uniform(0.15, 0.25, size=(100, 100, 50))\n\n# Coarsen by a factor of 2 in all directions: (100,100,50) -&gt; (50,50,25)\ncoarse_porosity = bores.coarsen_grid(\n    fine_porosity,\n    batch_size=(2, 2, 2),\n    method=\"mean\",  # Use arithmetic average for porosity\n)\n\n# Coarsen permeability using harmonic mean (more physically correct)\nfine_perm = np.random.uniform(10.0, 500.0, size=(100, 100, 50))\ncoarse_perm = bores.coarsen_grid(\n    fine_perm,\n    batch_size=(2, 2, 2),\n    method=\"mean\",  # For permeability, harmonic mean is ideal but \"mean\" is a quick approximation\n)\n</code></pre> <p>The <code>method</code> parameter supports <code>\"mean\"</code>, <code>\"sum\"</code>, <code>\"max\"</code>, and <code>\"min\"</code>. Choose the aggregation method that is physically appropriate for each property: arithmetic mean for porosity, harmonic mean (or cautious arithmetic as an approximation) for permeability, and sum for pore volume-weighted quantities.</p>"},{"location":"fundamentals/grid-systems/#grid-visualization","title":"Grid Visualization","text":"<p>BORES includes Plotly-based visualization tools for inspecting your grid. The <code>bores.visualization.plotly3d</code> module provides interactive 3D volume rendering that lets you rotate, zoom, and slice through your model to verify that properties are assigned correctly before running a simulation.</p> <pre><code>import bores\nfrom bores.visualization import plotly3d\n\n# Assuming you have built a model\n# Visualize the initial pressure distribution\nviz = plotly3d.DataVisualizer()\nplot = viz.make_plot(\n    data=model.fluid_properties.pressure_grid,\n    title=\"Initial Pressure (psi)\",\n    plot_type=\"volume\",\n)\nplot.show()\n</code></pre> <p>For 2D maps of a single layer, use <code>bores.visualization.plotly2d</code>, and for 1D property profiles along a line, use <code>bores.visualization.plotly1d</code>. These tools are particularly useful during model construction to catch setup errors - a misplaced well, an inverted permeability layer, or a saturation that does not sum to one will often be immediately obvious in a visualization.</p> <p>Verifying Your Grid</p> <p>Before running any simulation, visualize at least your pressure, porosity, and permeability grids. Common mistakes include:</p> <ul> <li>Accidentally transposing grid dimensions (e.g., assigning a <code>(ny, nx, nz)</code> array to a <code>(nx, ny, nz)</code> model)</li> <li>Setting thickness to zero in some cells (creates inactive cells with undefined behavior)</li> <li>Placing wells outside the grid bounds (BORES would normally warn on this)</li> </ul> <p>Five minutes of visual inspection can save hours of debugging cryptic simulation failures.</p>"},{"location":"fundamentals/reservoir-simulation/","title":"What is Reservoir Simulation?","text":""},{"location":"fundamentals/reservoir-simulation/#the-big-picture","title":"The Big Picture","text":"<p>Think of reservoir simulation as weather forecasting, but underground. Instead of predicting wind patterns and rainfall across the atmosphere, you are predicting how oil, water, and gas flow through rock thousands of feet below the surface. Just as meteorologists divide the atmosphere into a 3D grid of cells and solve physics equations in each one, reservoir engineers divide a petroleum reservoir into a grid of cells and solve fluid flow equations to predict how pressure and saturation change over time.</p> <p>The analogy goes deeper than you might expect. Weather models solve the Navier-Stokes equations on a grid. Reservoir simulators solve Darcy's law and mass conservation on a grid. Both are initial-boundary value problems: you start with known conditions (today's weather, or the reservoir state at discovery) and march forward in time, computing the state at each future moment from the state at the previous moment. Both struggle with the same fundamental tension between accuracy and computational cost - finer grids and smaller timesteps give better answers but take longer to run.</p> <p>Where the analogy breaks down is in what you can observe. Meteorologists have satellites, weather stations, and radiosondes feeding them data in real time. Reservoir engineers have a handful of wells - tiny pinpricks in a formation that might span hundreds of square miles. Everything between those wells is uncertain. This is why reservoir simulation is as much about managing uncertainty as it is about solving equations. You build a model, calibrate it against the data you have (a process called \"history matching\"), and then use it to forecast the future under different development plans.</p> <p>In practical terms, a reservoir simulator takes a description of the reservoir (rock properties, fluid properties, geometry, wells) and a development plan (which wells to drill, what rates to produce at, whether to inject water or gas) and predicts how the reservoir will respond over months, years, or decades. The output tells you how much oil you will recover, how quickly production will decline, when water will break through to your producers, and whether that expensive infill well is worth drilling.</p>"},{"location":"fundamentals/reservoir-simulation/#why-model-reservoirs","title":"Why Model Reservoirs?","text":"<p>The most immediate reason to run reservoir simulations is money. A single offshore well can cost $50-100 million to drill. A full field development plan might involve billions of dollars in infrastructure. Making these investment decisions based on gut feeling or simple decline curve analysis leaves enormous value on the table - or worse, leads to catastrophic mistakes like drilling dry holes or building facilities that are either too large or too small.</p> <p>Reservoir simulation lets you run \"what-if\" experiments that would be impossible or prohibitively expensive in the real world. What if you placed your injection wells in a line drive pattern instead of a five-spot? What if you converted that underperforming producer to a water injector? What if you delayed gas injection by two years until gas prices recover? Each of these scenarios can be modeled in hours on a computer, compared against alternatives, and ranked by net present value before a single dollar is committed.</p> <p>Beyond economics, simulation is essential for regulatory compliance. Governments that grant petroleum licenses require operators to demonstrate that they are developing reservoirs responsibly and maximizing recovery. Environmental regulations may require modeling of CO2 storage behavior, aquifer contamination risk, or subsidence due to pressure depletion. In all these cases, a calibrated simulation model is the standard tool for making and defending technical arguments.</p> <p>Finally, reservoir simulation serves as an integration platform. It forces you to combine data from geology (structure maps, facies models), petrophysics (porosity, permeability from logs and cores), PVT analysis (fluid properties from lab measurements), and production engineering (well completions, artificial lift) into a single consistent framework. The act of building a simulation model often reveals inconsistencies in the data that would otherwise go unnoticed.</p>"},{"location":"fundamentals/reservoir-simulation/#types-of-simulators","title":"Types of Simulators","text":"<p>Not all reservoir simulators solve the same equations. The choice of simulator depends on the physics that dominate the recovery process you are modeling. There are three major families, and understanding where BORES fits will help you know when it is the right tool and when you need something else.</p> <p>Black-oil simulators are the workhorse of the industry. They model three phases (oil, water, gas) and assume that the hydrocarbon system can be described by two components: a \"stock-tank oil\" component and a \"surface gas\" component. Gas can dissolve in oil (solution gas) and come out of solution when pressure drops below the bubble point, but the composition of each component is fixed. This simplification makes the math tractable and the simulations fast. Black-oil models are appropriate for the vast majority of conventional oil and gas reservoirs, waterflooding, and simple gas injection. BORES is a black-oil simulator.</p> <p>Compositional simulators track the full hydrocarbon composition - methane, ethane, propane, and heavier fractions - as individual components. This is necessary when the phase behavior depends on composition, not just pressure and temperature. Common use cases include gas condensate reservoirs (where liquid drops out of gas as pressure declines), miscible gas injection (where injected gas mixes with reservoir oil to create a single phase), and volatile oil reservoirs (where the oil contains so much dissolved gas that the black-oil assumption breaks down). Compositional simulation is significantly more expensive than black-oil, often 5-20x slower for the same grid size.</p> <p>Thermal simulators add energy balance equations to the flow equations, tracking temperature changes throughout the reservoir. These are essential for heavy oil and bitumen recovery processes like steam-assisted gravity drainage (SAGD), cyclic steam stimulation (CSS), and in-situ combustion. When you inject steam at 300 degrees Celsius into a reservoir containing oil with the viscosity of peanut butter, the temperature distribution controls everything - and a black-oil or compositional model that assumes isothermal conditions will give you nonsense.</p> <p>There are also specialized simulators for chemical flooding (polymer, surfactant, alkaline), geomechanical coupling (compaction, subsidence, fracture propagation), and dual-porosity/dual-permeability models for naturally fractured reservoirs. In practice, many commercial simulators blur these boundaries by offering optional modules that extend a base black-oil engine.</p>"},{"location":"fundamentals/reservoir-simulation/#basic-physics-darcys-law-and-conservation","title":"Basic Physics: Darcy's Law and Conservation","text":"<p>The physics of reservoir simulation rests on two pillars: Darcy's law, which describes how fluids move through porous rock, and conservation of mass, which ensures that fluid is neither created nor destroyed. Everything else - PVT correlations, relative permeability curves, well models - is supporting detail that feeds into these two fundamental principles.</p> <p>Darcy's law states that the flow rate of a fluid through a porous medium is proportional to the pressure gradient and inversely proportional to the fluid's viscosity:</p> \\[q = -\\frac{kA}{\\mu}\\frac{\\partial P}{\\partial x}\\] <p>where \\(q\\) is the volumetric flow rate, \\(k\\) is the permeability of the rock (a measure of how easily fluid can flow through it), \\(A\\) is the cross-sectional area perpendicular to flow, \\(\\mu\\) is the dynamic viscosity of the fluid, and \\(\\partial P / \\partial x\\) is the pressure gradient in the flow direction. The negative sign indicates that fluid flows from high pressure to low pressure - down the pressure gradient.</p> <p>If you have a programming background, you can think of Darcy's law as the \"flux function\" - it tells you how much stuff moves through each face of a grid cell per unit time, given the pressure difference between neighboring cells. Permeability \\(k\\) is like the conductance of a wire in an electrical circuit: higher permeability means less resistance to flow. Viscosity \\(\\mu\\) acts like additional resistance - thick, viscous oil flows more slowly than thin, watery fluid under the same pressure gradient.</p> <p>For multiphase flow (oil, water, and gas flowing simultaneously), Darcy's law is extended with relative permeability, which accounts for the fact that each phase interferes with the others:</p> \\[q_\\alpha = -\\frac{k \\cdot k_{r\\alpha}}{\\mu_\\alpha} A \\frac{\\partial P_\\alpha}{\\partial x}\\] <p>Here \\(\\alpha\\) denotes the phase (oil, water, or gas), \\(k_{r\\alpha}\\) is the relative permeability of phase \\(\\alpha\\) (a dimensionless number between 0 and 1 that depends on saturation), and \\(P_\\alpha\\) is the phase pressure (which may differ between phases due to capillary pressure). When oil saturation is high and water saturation is low, \\(k_{ro}\\) is large and \\(k_{rw}\\) is small, so oil flows easily and water barely moves. As water injection increases water saturation, the situation reverses.</p> <p>Conservation of mass is the other half of the puzzle. For each phase, the rate of mass accumulation in a cell must equal the net inflow minus the net outflow, plus any source/sink terms (wells). In differential form:</p> \\[\\frac{\\partial}{\\partial t}(\\phi \\rho_\\alpha S_\\alpha) + \\nabla \\cdot (\\rho_\\alpha \\vec{q}_\\alpha) = Q_\\alpha\\] <p>where \\(\\phi\\) is porosity (the fraction of rock volume that is pore space), \\(\\rho_\\alpha\\) is the density of phase \\(\\alpha\\), \\(S_\\alpha\\) is the saturation (fraction of pore space occupied by that phase), and \\(Q_\\alpha\\) represents source/sink terms from wells. The saturations must always sum to one: \\(S_o + S_w + S_g = 1\\).</p>"},{"location":"fundamentals/reservoir-simulation/#grid-based-discretization","title":"Grid-Based Discretization","text":"<p>You cannot solve Darcy's law and the conservation equations analytically for a real reservoir - the geometry is too complex, the properties vary spatially, and there is no closed-form solution. Instead, you discretize the reservoir into a grid of cells and solve a system of algebraic equations that approximate the continuous differential equations.</p> <p>The basic idea is to divide the reservoir into a large number of small rectangular blocks (cells). Each cell has its own rock properties (porosity, permeability), fluid properties (saturation, pressure, viscosity), and geometry (dimensions, depth). At each timestep, you compute the flow between neighboring cells using Darcy's law and update the pressure and saturation in each cell based on the net inflow and outflow. The finer your grid, the more accurately you capture spatial variations - but the more equations you have to solve and the slower the simulation runs.</p> <p>BORES uses a finite difference approach on structured Cartesian grids. \"Structured\" means the cells are arranged in a regular i-j-k pattern (think of a 3D spreadsheet), and \"Cartesian\" means the cells are rectangular blocks aligned with the coordinate axes. This is the simplest and most common grid type in reservoir simulation. The alternative - unstructured grids with tetrahedral or polyhedral cells - can conform better to complex geology but are much harder to implement and debug.</p> <p>The spacing between cell centers is where the numerical approximation enters. BORES computes the flow between cell \\((i,j,k)\\) and cell \\((i+1,j,k)\\) using the pressure difference between those two cells, divided by the distance between their centers, multiplied by a \"transmissibility\" that encodes the geometric and rock property information at that interface. This transmissibility calculation is done once at the start (and updated when properties change) so that the inner loop of the solver only needs to multiply transmissibility by pressure difference.</p> <p>For Python developers, the grid is stored as 3D NumPy arrays where each element corresponds to a cell. Pressure, saturation, porosity, permeability - these are all arrays of shape <code>(nx, ny, nz)</code>. Operations on these arrays are vectorized, meaning you can update all cells simultaneously rather than looping through them one at a time. This is essential for performance, especially when combined with Numba JIT compilation for the most critical numerical kernels.</p>"},{"location":"fundamentals/reservoir-simulation/#time-stepping","title":"Time-Stepping","text":"<p>Reservoir simulation advances through time in discrete steps. At each step, the simulator computes the pressure and saturation distributions at the new time level from the known state at the current time level. The choice of how to do this - how large the timestep is, and whether to treat the equations implicitly or explicitly - has profound implications for accuracy, stability, and speed.</p> <p>Explicit methods compute the new state entirely from the old state. They are simple and cheap per step, but they are conditionally stable: if your timestep is too large relative to your grid spacing and flow velocities, the solution will oscillate wildly and blow up. The stability limit is governed by the CFL condition (Courant-Friedrichs-Lewy), which essentially says that information should not travel more than one cell width per timestep.</p> <p>Implicit methods compute the new state by solving a system of equations that couples the old state and the new state together. They are unconditionally stable - you can take arbitrarily large timesteps without blowing up - but each step requires solving a large sparse linear system, which is expensive. The trade-off is fewer, more expensive steps versus many cheap steps.</p> <p>IMPES (Implicit Pressure, Explicit Saturation), which is the scheme BORES uses, is a compromise. The pressure equation is solved implicitly, giving unconditional stability for the pressure field. The saturation equation is then updated explicitly using the newly computed pressure field. This means pressure can change dramatically in a single step without instability, but the saturation update is still subject to CFL-like constraints. BORES handles this by monitoring the saturation change per step and reducing the timestep if it gets too large.</p> <p>The IMPES approach is well-suited for problems where pressure changes are large and fast (like near wells) but saturation fronts move relatively slowly (like a waterflood advancing through a reservoir). This covers the majority of practical reservoir simulation scenarios. For problems where saturation changes are very sharp - like gas coning near a well - IMPES may require very small timesteps, and a fully implicit method might be more efficient. But for the typical field-scale simulation, IMPES offers an excellent balance of speed and robustness.</p>"},{"location":"fundamentals/reservoir-simulation/#where-bores-fits","title":"Where BORES Fits","text":"<p>BORES is a 3D three-phase black-oil simulator that uses the IMPES scheme on structured Cartesian grids. In the taxonomy of reservoir simulators, this places it firmly in the \"general-purpose black-oil\" category - the most commonly used type of simulator in the petroleum industry.</p> <p>What makes BORES different from commercial simulators like Eclipse, CMG IMEX, or tNavigator is not the physics (which are standard) but the interface. BORES is a Python library, not a standalone application with a proprietary input format. You define your reservoir model, configure your simulation, and analyze results using Python code - the same language you use for data science, machine learning, and automation. This means you can integrate reservoir simulation into larger workflows, parametrize models programmatically, and leverage the entire Python scientific ecosystem.</p> <p>BORES is appropriate for conventional oil and gas reservoirs under primary depletion, waterflooding, and immiscible or miscible gas injection. It supports features like faults, fractures, aquifer models (Carter-Tracy), multiple well types, well schedules, and various boundary conditions. It is not the right tool for thermal recovery, compositional gas condensate modeling, or chemical flooding - those require specialized physics that are outside the black-oil framework.</p> <p>For Python developers coming to reservoir simulation for the first time, BORES is designed to be the tool where you learn by doing. The API is designed to be readable, the error messages are informative, and you can inspect every intermediate result as a NumPy array. For reservoir engineers who want to move beyond the limitations of commercial GUI-based tools, BORES gives you full programmatic control over every aspect of the simulation.</p>"},{"location":"fundamentals/simulation-workflow/","title":"Simulation Workflow","text":""},{"location":"fundamentals/simulation-workflow/#from-model-to-results","title":"From Model to Results","text":"<p>Running a reservoir simulation in BORES follows a clear pipeline: you build a reservoir model, configure the simulation parameters, call <code>bores.run()</code>, and iterate over the results. Under the hood, the simulator marches forward in time, solving for pressure and saturation at each timestep, checking convergence, and yielding snapshots of the model state at intervals you control.</p> <p>This page walks you through what happens inside that loop - how BORES solves the pressure equation, updates fluid properties, computes phase velocities, evolves saturations, and manages timestep size. Understanding this workflow will help you interpret simulation results, diagnose convergence issues, and choose appropriate solver settings for your problem.</p> <p>BORES supports three evolution schemes: IMPES (Implicit Pressure, Explicit Saturation), explicit (both pressure and saturation explicit), and implicit (fully implicit, currently in development). IMPES is the default and recommended scheme for most problems. The explicit scheme is available as an alternative for problems where you want simpler numerics at the cost of smaller timesteps.</p>"},{"location":"fundamentals/simulation-workflow/#the-impes-method","title":"The IMPES Method","text":"<p>IMPES (Implicit Pressure, Explicit Saturation) is the primary solution scheme in BORES and the one you should use unless you have a specific reason not to. It splits the coupled pressure-saturation system into two sequential steps: first solve pressure implicitly (by assembling and solving a linear system), then update saturations explicitly (by computing fluxes from the new pressure field). This splitting is the key design choice that makes IMPES both efficient and practical.</p> <p>The implicit pressure step means that pressure changes of any magnitude can be handled stably in a single timestep - there is no CFL-like stability limit on the pressure update. The explicit saturation step means that saturation updates are cheap (no linear system to solve), but the timestep size must be kept small enough that saturation fronts do not jump more than one cell per step. In practice, this is rarely a binding constraint for field-scale simulations where fronts move slowly relative to the grid spacing.</p> <p>Here is the sequence of operations that BORES executes at each IMPES timestep:</p> <ol> <li> <p>Solve pressure implicitly - Assemble the pressure coefficient matrix and right-hand side from current fluid properties, transmissibilities, compressibilities, and well terms. Solve the resulting sparse linear system using an iterative solver (BiCGSTAB by default) with a preconditioner (ILU by default).</p> </li> <li> <p>Update PVT properties - Recompute all pressure-dependent fluid properties (formation volume factors, viscosities, solution GOR, compressibilities, densities) at the new pressure. This is critical because the saturation update that follows needs accurate fluid properties at the new pressure.</p> </li> <li> <p>Recompute relative mobilities - Rebuild phase mobilities (\\(\\lambda_\\alpha = k_{r\\alpha} / \\mu_\\alpha\\)) using the updated viscosities from step 2 and the current relative permeabilities.</p> </li> <li> <p>Update saturations explicitly - Compute inter-cell fluxes using Darcy's law with the new pressure gradient and current mobilities. Update oil, water, and gas saturations in each cell based on the net flux balance and well source/sink terms. Enforce the saturation constraint \\(S_o + S_w + S_g = 1\\).</p> </li> <li> <p>Check convergence and adjust timestep - Verify that saturation changes and pressure changes are within configured limits. If they are, accept the step and advance time. If not, reject the step, reduce the timestep, and retry.</p> </li> </ol> <p>The following diagram illustrates this loop:</p> <pre><code>flowchart TD\n    A[\"Initialize Model\"] --&gt; B[\"Start Timestep\"]\n    B --&gt; C[\"Solve Pressure Implicitly\"]\n    C --&gt; D[\"Update PVT Properties\"]\n    D --&gt; E[\"Recompute Relative Mobilities\"]\n    E --&gt; F[\"Update Saturations Explicitly\"]\n    F --&gt; G{\"Convergence Check\"}\n    G -- Pass --&gt; H[\"Accept Step &amp; Advance Time\"]\n    G -- Fail --&gt; I[\"Reduce Timestep\"]\n    I --&gt; B\n    H --&gt; J{\"End Time?\"}\n    J -- No --&gt; B\n    J -- Yes --&gt; K[\"End Simulation\"]</code></pre> <p>Why PVT Updates Happen Between Pressure and Saturation</p> <p>In the IMPES scheme, PVT properties are updated after the implicit pressure solve but before the explicit saturation update. This is intentional: pressure changes affect viscosity, density, and compressibility, which in turn affect phase mobility and transport. By updating PVT between the two steps, the saturation transport uses fluid properties that are consistent with the new pressure field. In contrast, the explicit scheme updates PVT after both pressure and saturation have been evolved, using old-time values for transport coefficients. This difference is one reason IMPES is generally more accurate at larger timesteps.</p>"},{"location":"fundamentals/simulation-workflow/#the-explicit-scheme","title":"The Explicit Scheme","text":"<p>The explicit scheme solves both pressure and saturation using explicit (forward-in-time) finite difference updates. No linear system is assembled or solved - each cell's new pressure and saturation are computed directly from the old-time values and the fluxes through its faces.</p> <p>The main advantage of the explicit scheme is simplicity and per-step speed. There is no matrix assembly, no iterative solver, and no preconditioner. Each timestep is just a sequence of array operations. The main disadvantage is stability: the CFL condition constrains the timestep to be small enough that information does not travel more than one cell width per step. For fine grids or high-permeability zones, this can force very small timesteps, making the overall simulation slower than IMPES despite the cheaper per-step cost.</p> <p>You select the explicit scheme by setting <code>scheme=\"explicit\"</code> in your <code>Config</code>:</p> <pre><code>import bores\n\nconfig = bores.Config(\n    timer=bores.Timer(\n        initial_step_size=bores.Time(hours=1),\n        max_step_size=bores.Time(days=1),\n        min_step_size=bores.Time(seconds=10),\n        simulation_time=bores.Time(days=365),\n    ),\n    rock_fluid_tables=rock_fluid,\n    wells=wells,\n    scheme=\"explicit\",  # Use explicit scheme instead of IMPES\n)\n</code></pre> <p>Stability with the Explicit Scheme</p> <p>The explicit scheme requires smaller timesteps than IMPES to remain stable. BORES monitors the CFL number at each step and will reject steps that exceed the configured <code>pressure_cfl_threshold</code> (default 0.9) or <code>saturation_cfl_threshold</code> (default 0.6). If your simulation is rejecting many steps, try reducing <code>max_step_size</code> in the <code>Timer</code> or switching to <code>scheme=\"impes\"</code>.</p>"},{"location":"fundamentals/simulation-workflow/#timestep-control","title":"Timestep Control","text":"<p>Choosing the right timestep size is critical for balancing accuracy, stability, and computational speed. Too large a timestep causes convergence failures and inaccurate results. Too small a timestep wastes computation on unnecessarily fine time resolution. BORES uses an adaptive timestep controller (the <code>Timer</code> class) that automatically adjusts the step size based on what is happening in the simulation.</p> <p>The <code>Timer</code> manages timestep size through several mechanisms working together:</p> <p>Ramp-up at simulation start. The initial timestep is typically small (specified by <code>initial_step_size</code>) and grows gradually over the first several steps. This protects against the pressure transient that often occurs at the very start of a simulation when wells first begin operating.</p> <p>Growth on success. After each successful timestep, the <code>Timer</code> may increase the next step size, subject to <code>max_growth_per_step</code> (default 1.3, meaning at most 30% growth per step) and <code>max_step_size</code>. Growth is also controlled by a cooldown period (<code>growth_cooldown_steps</code>) that prevents aggressive growth immediately after a failure.</p> <p>Backoff on failure. When a timestep is rejected (because pressure or saturation changes exceeded their limits, or the solver failed to converge), the <code>Timer</code> reduces the step size by <code>backoff_factor</code> (default 0.5) and retries. If multiple consecutive failures occur, it uses <code>aggressive_backoff_factor</code> (default 0.25) for a more dramatic reduction.</p> <p>CFL-based adjustment. For the explicit scheme, the <code>Timer</code> monitors the CFL number and adjusts the step size to keep it below the safety margin. This is the primary stability control for explicit simulations.</p> <p>Change-based limits. The <code>Config</code> specifies maximum allowable changes per timestep for pressure (<code>max_pressure_change</code>, default 100 psi) and for each phase saturation (<code>max_oil_saturation_change</code>, <code>max_water_saturation_change</code>, <code>max_gas_saturation_change</code>). If any of these limits are exceeded, the step is rejected and retried with a smaller timestep.</p> <pre><code>import bores\n\nTime = bores.Time\n\ntimer = bores.Timer(\n    initial_step_size=Time(days=0.5),     # Start with half-day steps\n    max_step_size=Time(days=30),          # Allow up to 30-day steps\n    min_step_size=Time(minutes=30),       # Never go below 30 minutes\n    simulation_time=Time(years=10),       # Run for 10 years\n    max_growth_per_step=1.3,              # Grow at most 30% per step\n    backoff_factor=0.5,                   # Halve step size on failure\n)\n</code></pre> <p>Timer Settings for Different Problems</p> <ul> <li>Waterflooding (slow fronts): <code>initial_step_size=Time(days=1)</code>, <code>max_step_size=Time(days=30)</code></li> <li>Gas injection (fast fronts): <code>initial_step_size=Time(hours=6)</code>, <code>max_step_size=Time(days=5)</code></li> <li>Early-time transient (well startup): <code>initial_step_size=Time(minutes=30)</code>, allow ramp-up</li> <li>Depletion (slow, uniform): <code>initial_step_size=Time(days=5)</code>, <code>max_step_size=Time(days=60)</code></li> </ul>"},{"location":"fundamentals/simulation-workflow/#what-happens-each-timestep","title":"What Happens Each Timestep","text":"<p>Let us walk through a single IMPES timestep in more detail to give you a concrete picture of what the simulator is doing.</p> <p>1. Propose a timestep size. The <code>Timer</code> proposes a step size \\(\\Delta t\\) based on the history of previous steps - whether they succeeded or failed, how large the CFL number was, and how much the pressure and saturation changed. This proposed size is a \"trial\" - it may be rejected later.</p> <p>2. Apply boundary conditions. Before solving anything, BORES updates the ghost cells (the padding layer around the grid) to reflect the current boundary conditions. For constant-pressure boundaries, the ghost cells are set to the boundary pressure. For no-flow boundaries (the default), ghost cells mirror their interior neighbors. For time-dependent boundaries like Carter-Tracy aquifers, the influx is computed based on the current pressure history.</p> <p>3. Build rock-fluid property grids. Relative permeabilities are computed from the current saturations using the rock-fluid tables you configured (Corey, Brooks-Corey, LET, etc.). Relative mobilities are then computed as \\(\\lambda_\\alpha = k_{r\\alpha} / \\mu_\\alpha\\). Capillary pressures are computed if enabled.</p> <p>4. Solve the pressure equation. The pressure coefficient matrix \\(\\mathbf{A}\\) and right-hand side vector \\(\\mathbf{b}\\) are assembled from transmissibilities, compressibilities, well terms, and gravity terms. The system \\(\\mathbf{A} \\mathbf{p}^{n+1} = \\mathbf{b}\\) is solved using the configured iterative solver and preconditioner. The solution gives the new pressure field.</p> <p>5. Validate the pressure solution. BORES checks that no cell has an unphysical pressure (negative or extremely high). If unphysical pressures are detected, the step is rejected with a diagnostic message.</p> <p>6. Update PVT properties. All pressure-dependent fluid properties are recomputed at the new pressure: formation volume factors (\\(B_o\\), \\(B_g\\), \\(B_w\\)), viscosities (\\(\\mu_o\\), \\(\\mu_g\\), \\(\\mu_w\\)), solution GOR (\\(R_s\\)), gas solubility in water (\\(R_{sw}\\)), compressibilities, and densities. If you provided PVT tables, they are used for interpolation; otherwise, correlations are evaluated.</p> <p>7. Update saturations. Inter-cell Darcy fluxes are computed from the new pressure gradient and current mobilities. Each cell's saturation is updated based on the net flux balance:</p> \\[S_\\alpha^{n+1} = S_\\alpha^n + \\frac{\\Delta t}{\\phi V_b} \\left( \\sum_{\\text{faces}} q_\\alpha + Q_\\alpha^{\\text{well}} \\right)\\] <p>where \\(V_b\\) is the bulk cell volume, \\(q_\\alpha\\) is the flux of phase \\(\\alpha\\) through a cell face, and \\(Q_\\alpha^{\\text{well}}\\) is the well source/sink term.</p> <p>8. Check changes. The maximum pressure change and maximum saturation change across all cells are compared against the configured limits. If either exceeds its limit, the step is rejected, the timestep is reduced, and the simulator returns to step 1 with the smaller timestep. The old pressure and saturation fields are restored.</p> <p>9. Record state. If the step is accepted and it falls on an output interval (controlled by <code>output_frequency</code> in <code>Config</code>), a <code>ModelState</code> snapshot is captured and yielded to the caller. This snapshot contains the full reservoir model state, well data, relative permeabilities, rate grids, and timer state.</p>"},{"location":"fundamentals/simulation-workflow/#running-a-simulation-in-bores","title":"Running a Simulation in BORES","text":"<p>With all the theory covered, here is what the actual code looks like. The <code>bores.run()</code> function is a Python generator that yields <code>ModelState</code> objects at each output interval.</p> <pre><code>import bores\n\n# Assume model and config have been set up\n# (see the Quick Example on the home page for full setup)\n\n# bores.run() returns a generator - it computes one step at a time\nsimulation = bores.run(model, config)\n\n# Iterate over the results\nfor state in simulation:\n    pressure = state.model.fluid_properties.pressure_grid\n    oil_sat = state.model.fluid_properties.oil_saturation_grid\n    print(\n        f\"Step {state.step:4d} | \"\n        f\"Time: {state.time_in_days:8.1f} days | \"\n        f\"Avg P: {pressure.mean():8.1f} psi | \"\n        f\"Avg So: {oil_sat.mean():.4f}\"\n    )\n</code></pre> <p>The generator pattern is important: BORES does not compute all timesteps upfront and store them in memory. It computes one step at a time and yields the result. This means you can process results as they arrive, stop early if a condition is met, or stream results to disk without holding the entire simulation history in memory.</p> <p>You can also use the <code>Run</code> class for a more structured approach, especially when loading models and configs from files:</p> <pre><code>import bores\n\n# Create a Run from files\nsim_run = bores.Run.from_files(\n    model_path=\"model.h5\",\n    config_path=\"config.yaml\",\n    pvt_table_path=\"pvt.h5\",  # Optional\n)\n\n# Iterate directly over the Run object\nfor state in sim_run:\n    process(state)\n</code></pre> <p>Collecting All States</p> <p>If your model is small enough to fit in memory, you can collect all states into a list for post-processing:</p> <pre><code>states = list(bores.run(model, config))\nfinal_state = states[-1]\nprint(f\"Simulation completed: {final_state.step} steps, {final_state.time_in_days:.1f} days\")\n</code></pre> <p>For large models, consider using BORES streaming utilities (<code>bores.streams</code>) to pipe results to disk (HDF5, Zarr, or pickle) instead of holding them all in memory.</p>"},{"location":"fundamentals/simulation-workflow/#the-modelstate-object","title":"The <code>ModelState</code> Object","text":"<p>Each yielded <code>ModelState</code> contains a complete snapshot of the simulation at that point in time. Here are the key attributes you will use most often:</p> Attribute Type Description <code>state.step</code> <code>int</code> Timestep index <code>state.step_size</code> <code>float</code> Timestep size in seconds <code>state.time</code> <code>float</code> Elapsed simulation time in seconds <code>state.time_in_days</code> <code>float</code> Elapsed simulation time in days <code>state.model</code> <code>ReservoirModel</code> Full reservoir model with updated properties <code>state.model.fluid_properties.pressure_grid</code> <code>ndarray</code> Pressure at each cell (psi) <code>state.model.fluid_properties.oil_saturation_grid</code> <code>ndarray</code> Oil saturation at each cell <code>state.model.fluid_properties.water_saturation_grid</code> <code>ndarray</code> Water saturation at each cell <code>state.model.fluid_properties.gas_saturation_grid</code> <code>ndarray</code> Gas saturation at each cell <code>state.injection</code> <code>RateGrids</code> Injection rates (oil, water, gas) in ft3/day <code>state.production</code> <code>RateGrids</code> Production rates (oil, water, gas) in ft3/day <code>state.wells</code> <code>Wells</code> Well configuration at this state <p>Because every property is a NumPy array, you can perform any NumPy operation on the results - compute field averages, extract well-block values, calculate material balance, or feed the data into your own analysis pipeline.</p>"},{"location":"fundamentals/simulation-workflow/#solver-and-preconditioner-selection","title":"Solver and Preconditioner Selection","text":"<p>The pressure equation at each IMPES timestep requires solving a sparse linear system. The choice of solver and preconditioner affects both the speed and robustness of the simulation. BORES provides several options that you configure through the <code>Config</code> class.</p> Default (BiCGSTAB + ILU)Difficult Problems (GMRES + CPR)Fast/Well-Conditioned (CG + Diagonal) <pre><code>config = bores.Config(\n    timer=timer,\n    rock_fluid_tables=rock_fluid,\n    pressure_solver=\"bicgstab\",\n    pressure_preconditioner=\"ilu\",\n    # ... other parameters\n)\n</code></pre> <p>The default combination of BiCGSTAB solver with ILU preconditioner works well for most problems and is the recommended starting point.</p> <pre><code>config = bores.Config(\n    timer=timer,\n    rock_fluid_tables=rock_fluid,\n    pressure_solver=\"gmres\",\n    pressure_preconditioner=\"cpr\",\n    # ... other parameters\n)\n</code></pre> <p>For problems with strong coupling, high permeability contrasts, or convergence difficulties, try GMRES with the CPR (Constrained Pressure Residual) preconditioner.</p> <pre><code>config = bores.Config(\n    timer=timer,\n    rock_fluid_tables=rock_fluid,\n    pressure_solver=\"cg\",\n    pressure_preconditioner=\"diagonal\",\n    # ... other parameters\n)\n</code></pre> <p>For well-conditioned problems (homogeneous reservoirs, mild contrasts), the conjugate gradient solver with a diagonal preconditioner is the cheapest option.</p> <p>Direct Solver Warning</p> <p>Avoid using <code>pressure_solver=\"direct\"</code> for grids larger than about 50,000 cells. The direct solver (sparse LU factorization) has \\(O(n^{1.5})\\) to \\(O(n^2)\\) memory scaling, and BORES will warn you about estimated memory usage for large systems. Iterative solvers with good preconditioners are almost always faster and more memory-efficient for reservoir simulation problems.</p> <p>For a comprehensive guide to solver and preconditioner selection, including performance benchmarks and tuning advice, see the Solvers and Preconditioners guide.</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Welcome to BORES. This section walks you through everything you need to go from a fresh Python environment to a running reservoir simulation. Whether you are setting up BORES for the first time or refreshing your understanding of the framework's design, these three guides have you covered.</p> <ul> <li> <p> Installation</p> <p>Set up your Python environment and install BORES along with its dependencies. Covers installation through both <code>uv</code> (recommended) and <code>pip</code>, optional packages for thermodynamics and visualization, and troubleshooting tips for common issues.</p> <p> Install BORES</p> </li> <li> <p> Quickstart</p> <p>Build and run your first simulation in under 5 minutes. This hands-on tutorial walks through a complete workflow: defining a grid, building a reservoir model, configuring the simulation, running it, and inspecting results.</p> <p> Run your first simulation</p> </li> <li> <p> Core Concepts</p> <p>Understand the foundational ideas behind BORES: the simulation pipeline, immutable data models, dimension generics, sign conventions, field units, precision control, time management, and serialization. Read this before diving into advanced features.</p> <p> Learn the fundamentals</p> </li> </ul>"},{"location":"getting-started/#recommended-reading-order","title":"Recommended Reading Order","text":"<p>If you are brand new to BORES, follow these pages in order:</p> <ol> <li>Installation - Get BORES installed and verify it works.</li> <li>Quickstart - Run a complete simulation end to end.</li> <li>Core Concepts - Build a mental model of how the framework is organized.</li> </ol> <p>After completing these three pages, you will be ready to explore the User Guide, Tutorials, and API Reference sections.</p>"},{"location":"getting-started/concepts/","title":"Core Concepts","text":"<p>Understand the foundational ideas behind BORES before diving into advanced features.</p> <p>This page covers the design principles and conventions that run through every part of BORES. Reading it will save you time when you encounter unfamiliar patterns in the API and help you write simulations that are correct, efficient, and maintainable. Each concept below explains both the what and the why, so you can make informed decisions when building your own workflows.</p>"},{"location":"getting-started/concepts/#the-simulation-pipeline","title":"The Simulation Pipeline","text":"<p>Every BORES simulation follows the same five-stage pipeline: Model Construction, Configuration, Simulation Run, State Streaming, and Analysis. Understanding this pipeline is the key to understanding how the framework fits together.</p> <p>In the first stage, you construct a <code>ReservoirModel</code> by defining the grid geometry, fluid properties, rock properties, and saturation distributions. The <code>reservoir_model()</code> factory function handles the heavy lifting: it runs PVT correlations, validates inputs, builds derived property grids, and assembles everything into an immutable model object. You can provide as few or as many properties as you like, and the factory will estimate the rest from correlations.</p> <p>In the second stage, you create a <code>Config</code> object that specifies how the simulation should run: the time stepping strategy, the evolution scheme, well definitions, boundary conditions, solver settings, and convergence tolerances. The config is also immutable, ensuring that your simulation parameters are locked in before the run begins.</p> <p>The third stage is the simulation run itself. <code>bores.run(model, config)</code> returns a generator that yields <code>ModelState</code> snapshots at each output interval. The generator-based design means computation happens lazily - the simulator only advances when you request the next state. The fourth stage, state streaming, optionally pipes these states to a storage backend (Zarr or HDF5) as they are produced, keeping memory usage bounded. The fifth stage is post-simulation analysis, where you compute recovery factors, plot production profiles, track saturation fronts, and extract engineering insights from the stored states.</p> <pre><code>flowchart LR\n    A[\"Model Construction\"] --&gt; B[\"Configuration\"]\n    B --&gt; C[\"Simulation Run\"]\n    C --&gt; D[\"State Streaming\"]\n    D --&gt; E[\"Analysis\"]\n\n    style A fill:#4CAF50,color:#fff,stroke:#388E3C\n    style B fill:#2196F3,color:#fff,stroke:#1565C0\n    style C fill:#FF9800,color:#fff,stroke:#EF6C00\n    style D fill:#9C27B0,color:#fff,stroke:#6A1B9A\n    style E fill:#F44336,color:#fff,stroke:#C62828</code></pre> <p>Lazy Evaluation</p> <p>The simulation generator does not precompute all states up front. Each call to <code>next()</code> advances the simulation by one output interval, solves the pressure and saturation equations, and yields the resulting <code>ModelState</code>. This means you can stop the simulation early, inspect intermediate results, or insert custom logic between steps without wasting computation.</p>"},{"location":"getting-started/concepts/#immutable-data-models","title":"Immutable Data Models","text":"<p>BORES represents almost all reservoir data using immutable (frozen) classes built with the attrs library. The core model classes - <code>ReservoirModel</code>, <code>FluidProperties</code>, <code>RockProperties</code>, <code>SaturationHistory</code>, and <code>Config</code> - are all frozen. Once created, their fields cannot be changed in place.</p> <p>Immutability matters deeply in simulation software. When you pass a <code>ReservoirModel</code> to <code>bores.run()</code>, the simulator works on internal copies of the data. Your original model object remains untouched, so you can safely reuse it for parameter sweeps, what-if scenarios, or debugging. There is no hidden state mutation that could silently corrupt your baseline.</p> <p>When you need a modified version of an immutable object, you use <code>attrs.evolve()</code> to create a new instance with specific fields replaced. BORES surfaces this pattern through convenience methods like <code>config.copy()</code> and <code>config.with_updates()</code>. The original object is never modified; you always get a fresh copy with the changes applied.</p> <pre><code>import bores\nimport attrs\n\n# Original config\nconfig = bores.Config(\n    timer=bores.Timer(\n        initial_step_size=bores.Time(days=1),\n        max_step_size=bores.Time(days=10),\n        min_step_size=bores.Time(hours=1),\n        simulation_time=bores.Time(days=365),\n    ),\n    rock_fluid_tables=rock_fluid,\n    wells=wells,\n    scheme=\"impes\",\n)\n\n# Create a modified copy with a different scheme\nexplicit_config = config.with_updates(scheme=\"explicit\")\n\n# The original is unchanged\nassert config.scheme == \"impes\"\nassert explicit_config.scheme == \"explicit\"\n</code></pre> <p>Parameter Sweeps</p> <p>Immutability makes parameter sweeps straightforward. Create a base config, then use <code>config.with_updates()</code> in a loop to generate variations. Each variation is independent, so you can run them in parallel without synchronization concerns.</p>"},{"location":"getting-started/concepts/#factory-functions","title":"Factory Functions","text":"<p>BORES uses factory functions - <code>reservoir_model()</code>, <code>injection_well()</code>, <code>production_well()</code>, and <code>wells_()</code> - as the primary way to construct complex objects. You will rarely need to instantiate <code>ReservoirModel</code>, <code>InjectionWell</code>, or <code>ProductionWell</code> directly.</p> <p>The reason for this design is that building a reservoir model involves far more than assigning values to fields. The <code>reservoir_model()</code> factory validates your inputs against physical constraints, estimates missing properties from PVT correlations (Standing, Vasquez-Beggs, Lee-Gonzalez, and others), resolves circular dependencies between oil compressibility and formation volume factor through iterative bootstrapping, normalizes saturations to sum to 1.0, builds depth and elevation grids, and applies fracture transmissibility modifications if fractures are defined. Doing all of this inside a constructor would make the class difficult to understand and test.</p> <p>Factory functions also provide a clear separation between what you specify (the inputs you care about) and what gets computed (the derived properties you did not provide). This lets you start simple - provide just pressure, temperature, porosity, and a few other essentials - and progressively add detail as your study demands it. The factories handle the transition gracefully, using correlations for anything you omit and your explicit values for anything you provide.</p> <p>The well factories follow the same principle. <code>injection_well()</code> and <code>production_well()</code> accept straightforward parameters (name, location, radius, control mode, fluids) and return fully constructed well objects. The <code>wells_()</code> function groups injectors and producers into a single <code>Wells</code> container that the simulator expects.</p> <pre><code>import bores\n\n# The factory estimates gas viscosity, density, compressibility, FVF, Rs, Rsw,\n# and many other properties from pressure, temperature, and oil/gas gravity\nmodel = bores.reservoir_model(\n    grid_shape=(10, 10, 3),\n    cell_dimension=(100.0, 100.0),\n    thickness_grid=thickness,\n    pressure_grid=pressure,\n    rock_compressibility=3e-6,\n    absolute_permeability=permeability,\n    porosity_grid=porosity,\n    temperature_grid=temperature,\n    water_saturation_grid=Sw,\n    gas_saturation_grid=Sg,\n    oil_saturation_grid=So,\n    oil_viscosity_grid=oil_viscosity,\n    oil_specific_gravity_grid=oil_sg,\n    oil_bubble_point_pressure_grid=bubble_point,\n    residual_oil_saturation_water_grid=Sorw,\n    residual_oil_saturation_gas_grid=Sorg,\n    residual_gas_saturation_grid=Sgr,\n    irreducible_water_saturation_grid=Swir,\n    connate_water_saturation_grid=Swc,\n)\n</code></pre> <p>Override Any Property</p> <p>If you have measured data or equation-of-state results for a specific property (for example, gas compressibility factor from lab PVT analysis), pass it directly to <code>reservoir_model()</code> as the corresponding <code>*_grid</code> parameter. The factory will use your value instead of computing it from correlations.</p>"},{"location":"getting-started/concepts/#generics-and-dimensions","title":"Generics and Dimensions","text":"<p>BORES models are generic over a dimension type parameter called <code>NDimension</code>. This means the same classes - <code>ReservoirModel</code>, <code>FluidProperties</code>, <code>RockProperties</code>, wells, boundary conditions, and grid utilities - work across 1D, 2D, and 3D simulations without separate implementations for each dimensionality.</p> <p>In practice, the dimension is determined by the shape of your grid. A <code>grid_shape</code> of <code>(100,)</code> creates a 1D model, <code>(10, 10)</code> creates a 2D model, and <code>(10, 10, 3)</code> creates a 3D model. The type system tracks dimensionality through type aliases: <code>OneDimension = Tuple[int]</code>, <code>TwoDimensions = Tuple[int, int]</code>, and <code>ThreeDimensions = Tuple[int, int, int]</code>. When you build a 3D model, the resulting <code>ReservoirModel[ThreeDimensions]</code> carries its dimensionality in the type signature.</p> <p>This generic design has practical benefits. You can prototype and debug on a fast 1D or 2D model, then scale up to 3D for your final study without changing any of your analysis code. The property grids, well definitions, and boundary conditions all adapt to the dimensionality of the model they belong to.</p> <p>The full 3D simulation pipeline (<code>bores.run()</code>) currently operates on <code>ThreeDimensions</code> models. Lower-dimensional models are primarily useful for model construction, property estimation, and analytical comparisons. Future releases will extend the full simulation loop to 1D and 2D natively.</p> <pre><code>import bores\n\n# 1D model for rapid prototyping\nmodel_1d = bores.reservoir_model(grid_shape=(100,), ...)\n\n# 3D model for production studies\nmodel_3d = bores.reservoir_model(grid_shape=(50, 50, 10), ...)\n\n# Type annotations reflect dimensionality\n# model_1d: ReservoirModel[OneDimension]\n# model_3d: ReservoirModel[ThreeDimensions]\n</code></pre>"},{"location":"getting-started/concepts/#units-convention","title":"Units Convention","text":"<p>BORES uses field units throughout the entire codebase. If you work in field units from the start, you never need to convert anything. Here is the complete list of units used in BORES:</p> Property Unit Symbol Pressure pounds per square inch psi Length / Thickness feet ft Permeability milliDarcy mD Viscosity centipoise cP Liquid rate stock-tank barrels per day STB/day Gas rate standard cubic feet per day SCF/day Temperature degrees Fahrenheit deg F Density pounds mass per cubic foot lbm/ft^3 Compressibility per psi psi^-1 Formation volume factor (oil, water) reservoir barrels per stock-tank barrel bbl/STB Formation volume factor (gas) reservoir cubic feet per standard cubic foot ft^3/SCF Solution GOR standard cubic feet per stock-tank barrel SCF/STB Porosity fraction - Saturation fraction - Relative permeability fraction - <p>The choice of field units is deliberate. The vast majority of reservoir engineering literature, well reports, and commercial simulator inputs use field units. By aligning with this convention, BORES reduces the friction of importing real-world data and comparing results against published benchmarks.</p> <p>All PVT correlations, well models, and solver equations inside BORES assume field units. The conversion constants (such as the 5.615 ft^3/bbl factor and the 0.001127 Darcy-to-field transmissibility constant) are embedded in the numerical kernels. You do not need to apply them yourself.</p> <p>SI Units</p> <p>BORES does not support SI or metric units natively. If your data is in SI units, you must convert to field units before passing values to BORES functions. Mixing unit systems will produce incorrect results without any error or warning.</p>"},{"location":"getting-started/concepts/#sign-convention","title":"Sign Convention","text":"<p>BORES uses a single, consistent sign convention for all flow quantities across the entire framework:</p> <ul> <li>Positive = injection / inflow (fluid entering the reservoir)</li> <li>Negative = production / outflow (fluid leaving the reservoir)</li> </ul> <p>This convention applies everywhere: well rates, flux boundary conditions, source/sink terms, and all internal flow calculations. It is the most common convention in reservoir simulation and matches what you will find in textbooks like Aziz and Settari.</p> <p>When defining a production well, specify a negative target rate. When defining an injection well, specify a positive target rate. The <code>ModelState</code> objects yielded by the simulator report production rates as positive values (the negation is applied automatically for readability), but the internal sign convention is always as described above.</p> <pre><code>import bores\n\n# Injection well: positive rate means fluid flows INTO the reservoir\ninjector_control = bores.ConstantRateControl(target_rate=500.0)   # +500 STB/day\n\n# Production well: fix the oil rate, let other phases flow naturally\nproducer_control = bores.PrimaryPhaseRateControl(\n    primary_phase=bores.FluidPhase.OIL,\n    primary_control=bores.AdaptiveBHPRateControl(\n        target_rate=-500.0,       # -500 STB/day of oil (production)\n        target_phase=\"oil\",\n        bhp_limit=1000.0,         # minimum BHP constraint\n    ),\n    secondary_clamp=bores.ProductionClamp(),\n)\n</code></pre> <p>Getting the Sign Wrong</p> <p>If you accidentally specify a positive rate for a production well, the well will behave as an injector. If you specify a negative rate for an injection well, it will behave as a producer. BORES does not currently validate the sign against the well type, so always double-check your rate signs when setting up wells.</p>"},{"location":"getting-started/concepts/#precision-control","title":"Precision Control","text":"<p>BORES defaults to 32-bit floating point (<code>numpy.float32</code>) for all computations. This is a deliberate performance choice: 32-bit operations use half the memory of 64-bit and are roughly twice as fast for SIMD vectorized calculations. For most reservoir simulations, 32-bit precision provides more than adequate accuracy.</p> <p>You can switch to 64-bit precision globally by calling <code>bores.use_64bit_precision()</code> before constructing your model. This is recommended when you need to match analytical solutions to many significant digits, when running very long simulations (thousands of time steps) where rounding errors can accumulate, or when working with extreme property contrasts (such as permeability ratios exceeding 10^6).</p> <p>The <code>bores.with_precision()</code> context manager lets you temporarily change precision for a specific block of code without affecting the rest of your program. This is useful for running a high-precision validation check alongside a normal-precision production run.</p> <pre><code>import bores\n\n# Global precision setting\nbores.use_64bit_precision()\n\n# Or temporary precision change\nwith bores.with_precision(bores.np.float64):\n    model = bores.reservoir_model(...)\n    states = list(bores.run(model, config))\n\n# Check current precision\nprint(bores.get_dtype())  # &lt;class 'numpy.float32'&gt; (back to default outside context)\n</code></pre> <p>When to Use 64-bit</p> <p>A practical rule of thumb: start with 32-bit (the default). If you observe pressure oscillations, material balance errors exceeding 1%, or results that differ significantly from reference solutions, try switching to 64-bit precision. In most cases, the issue is more likely to be a modeling error or solver configuration problem, but ruling out precision effects is a quick diagnostic step.</p>"},{"location":"getting-started/concepts/#serialization-and-registration","title":"Serialization and Registration","text":"<p>BORES provides a two-tier serialization system for saving and loading simulation objects. The base tier, <code>Serializable</code>, supports dictionary round-tripping via the cattrs library. Any <code>Serializable</code> class can be converted to a plain Python dictionary and reconstructed from one. The second tier, <code>StoreSerializable</code>, extends this with <code>dump()</code> and <code>load()</code> methods that write to and read from file-backed storage (HDF5, Zarr, YAML, JSON).</p> <p>All core BORES classes - <code>ReservoirModel</code>, <code>Config</code>, <code>FluidProperties</code>, <code>RockProperties</code>, well classes, boundary conditions, and relative permeability models - are serializable out of the box. You can save a model to disk, load it back, and get an identical object.</p> <p>When you define custom types that should participate in BORES serialization (for example, a custom relative permeability model or a custom well control), you need to register them using the provided decorators. This ensures that the deserializer knows how to reconstruct your custom type from its dictionary representation. The registration system uses a type registry that maps string type identifiers to Python classes.</p> <pre><code>import bores\n\n# Save a model to HDF5\nmodel.dump(\"my_model.h5\")\n\n# Load it back\nloaded_model = bores.ReservoirModel.from_file(\"my_model.h5\")\n\n# Save a config to YAML\nconfig.dump(\"config.yaml\")\n\n# Load it back\nloaded_config = bores.Config.from_file(\"config.yaml\")\n</code></pre> <p>Storage Backends</p> <p>BORES supports four storage backends: <code>ZarrStore</code> (chunked, compressed arrays - best for large simulations), <code>HDF5Store</code> (widely supported scientific format), <code>JSONStore</code> (human-readable, good for configs), and <code>YAMLStore</code> (human-readable, good for configs). Choose based on your data size and interoperability needs.</p>"},{"location":"getting-started/concepts/#configuration-as-code","title":"Configuration as Code","text":"<p>The <code>Config</code> class is a frozen attrs class that holds every parameter controlling a simulation run. Rather than scattering configuration across multiple files, environment variables, or global state, BORES puts everything in one place. This makes simulations reproducible: given the same <code>ReservoirModel</code> and <code>Config</code>, you will get the same results every time.</p> <p>The <code>Config</code> object includes the time stepping strategy (via <code>Timer</code>), well definitions, boundary conditions, rock-fluid tables, solver selection, preconditioner choice, convergence tolerances, evolution scheme, CFL thresholds, maximum saturation and pressure change limits, and many other parameters. Every parameter has a sensible default, so you only need to specify the ones you want to change.</p> <p>Because <code>Config</code> is immutable, changing a parameter requires creating a new config. The <code>copy()</code> and <code>with_updates()</code> methods make this concise. This pattern eliminates an entire class of bugs where simulation behavior changes unexpectedly because someone modified a shared config object.</p> <pre><code>import bores\n\nTime = bores.Time\n\nconfig = bores.Config(\n    # Time stepping\n    timer=bores.Timer(\n        initial_step_size=Time(days=1),\n        max_step_size=Time(days=10),\n        min_step_size=Time(hours=1),\n        simulation_time=Time(days=365),\n    ),\n\n    # Rock-fluid properties\n    rock_fluid_tables=bores.RockFluidTables(\n        relative_permeability_table=bores.BrooksCoreyThreePhaseRelPermModel(\n            water_exponent=2.0, oil_exponent=2.0, gas_exponent=2.0,\n        ),\n        capillary_pressure_table=bores.BrooksCoreyCapillaryPressureModel(),\n    ),\n\n    # Wells\n    wells=wells,\n\n    # Solver settings\n    scheme=\"impes\",\n    pressure_solver=\"bicgstab\",\n    pressure_preconditioner=\"ilu\",\n    pressure_convergence_tolerance=1e-6,\n    max_iterations=250,\n\n    # Stability controls\n    max_pressure_change=100.0,           # psi per step\n    max_oil_saturation_change=0.5,       # fraction per step\n    max_water_saturation_change=0.4,     # fraction per step\n)\n</code></pre> <p>Common Config Variations</p> Fast Screening RunHigh-Accuracy StudyExplicit Scheme <pre><code>screening_config = config.with_updates(\n    output_frequency=10,             # Output every 10th step\n    max_pressure_change=200.0,       # Relax stability constraints\n    pressure_preconditioner=\"diagonal\",  # Cheap preconditioner\n)\n</code></pre> <pre><code>accurate_config = config.with_updates(\n    pressure_convergence_tolerance=1e-8,\n    max_pressure_change=50.0,        # Tighter stability constraints\n    max_water_saturation_change=0.2,\n    pressure_preconditioner=\"cpr\",   # Strong preconditioner\n)\n</code></pre> <pre><code>explicit_config = config.with_updates(\n    scheme=\"explicit\",\n    saturation_cfl_threshold=0.6,    # CFL stability limit\n    pressure_cfl_threshold=0.9,\n)\n</code></pre>"},{"location":"getting-started/concepts/#next-steps","title":"Next Steps","text":"<p>With these concepts in hand, you are ready to explore the rest of BORES:</p> <ul> <li>User Guide - Detailed coverage of wells, boundary conditions, PVT correlations, relative permeability models, solvers, and time stepping strategies.</li> <li>Tutorials - End-to-end walkthroughs of common reservoir simulation workflows.</li> <li>API Reference - Complete documentation of every class, function, and parameter.</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>This page covers how to install BORES, verify your setup, and troubleshoot common issues. BORES supports Python 3.10 and above on Linux, macOS, and Windows.</p>"},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<p>Before installing BORES, make sure you have the following:</p> <ul> <li>Python 3.10 or later - BORES uses modern typing features and requires Python 3.10 as a minimum. You can check your version with <code>python --version</code>.</li> <li>A C compiler - Numba (used for JIT-compiled numerical kernels) occasionally needs to compile extensions. On Linux, <code>gcc</code> is typically available by default. On macOS, install Xcode command line tools with <code>xcode-select --install</code>. On Windows, the Microsoft Visual C++ Build Tools are sufficient.</li> <li>A working internet connection - Required to download BORES and its dependencies from PyPI.</li> </ul> <p>BORES depends on several scientific Python packages that will be installed automatically:</p> Package Purpose numpy Array operations and linear algebra scipy Sparse matrix solvers and numerical methods numba JIT compilation for performance-critical functions attrs / cattrs Data models and serialization h5py / zarr / orjson HDF5, Zarr, and JSON storage backends plotly Visualization (series, maps, 3D volumes)"},{"location":"getting-started/installation/#install-bores","title":"Install BORES","text":"uv (recommended)pip <p>uv is a fast Python package manager that handles dependency resolution efficiently. If you do not have <code>uv</code> installed yet, you can install it with:</p> <pre><code>curl -LsSf https://astral.sh/uv/install.sh | sh\n</code></pre> <p>Then install BORES:</p> <pre><code>uv add bores-framework\n</code></pre> <p>If you are working from a cloned copy of the BORES repository, you can install it in development mode:</p> <pre><code>uv sync\n</code></pre> <p>This reads the <code>pyproject.toml</code> and installs all dependencies, including optional dev tools.</p> <p>You can install BORES with standard pip:</p> <pre><code>pip install bores-framework\n</code></pre> <p>Or to ensure that pip uses an index for MKL-optimized numpy/scipy for x86_64 Linux/Windows:</p> <pre><code>pip install bores-framework --extra-index-url https://urob.github.io/numpy-mkl\n</code></pre> <p>For development mode from a local clone:</p> <pre><code>pip install -e \".[dev]\"\n</code></pre> <p>Virtual Environments</p> <p>Always install BORES inside a virtual environment to avoid conflicts with other packages. With <code>uv</code>, virtual environments are managed automatically. With <code>pip</code>, create one using <code>python -m venv .venv</code> and activate it before installing.</p>"},{"location":"getting-started/installation/#verify-your-installation","title":"Verify Your Installation","text":"<p>Run the following script to confirm that BORES is installed correctly and its core dependencies are available:</p> <pre><code>import bores\nprint(f\"BORES version: {bores.__version__}\")\nprint(f\"Default precision: {bores.get_dtype()}\")\n</code></pre> <p>Expected output:</p> <pre><code>BORES version: 0.1.0\nDefault precision: &lt;class 'numpy.float32'&gt;\n</code></pre> <p>If you see an <code>ImportError</code>, double-check that you installed BORES in the correct Python environment and that all dependencies resolved successfully.</p>"},{"location":"getting-started/installation/#optional-dependencies","title":"Optional Dependencies","text":"<p>BORES includes several optional packages that extend its capabilities. These are installed by default with the standard installation, but are worth knowing about if you are working in a minimal environment.</p>"},{"location":"getting-started/installation/#thermodynamics-coolprop-and-thermo","title":"Thermodynamics - CoolProp and thermo","text":"<p>BORES uses CoolProp and thermo for advanced fluid property calculations, particularly when computing gas properties from first principles. These packages enable accurate PVT calculations for non-standard gases like CO2 or nitrogen.</p> <pre><code>pip install coolprop thermo\n</code></pre>"},{"location":"getting-started/installation/#visualization-plotly-and-trame","title":"Visualization - Plotly and Trame","text":"<p>The visualization module relies on Plotly for generating charts and 3D renders, along with Kaleido for static image export and Trame for interactive 3D volume visualization in web browsers.</p> <pre><code>pip install plotly kaleido trame\n</code></pre>"},{"location":"getting-started/installation/#storage-hdf5-and-zarr","title":"Storage - HDF5 and Zarr","text":"<p>BORES supports multiple storage backends for saving and loading simulation results. h5py provides HDF5 support, while zarr enables chunked, compressed array storage suitable for large simulations.</p> <pre><code>pip install h5py zarr\n</code></pre>"},{"location":"getting-started/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/installation/#numba-compilation-errors","title":"Numba compilation errors","text":"<p>Numba compiles Python functions to machine code on first use. If you encounter compilation errors, try the following:</p> <ol> <li>Update Numba: Ensure you have numba &gt;= 0.63.0 installed.</li> <li>Clear the cache: Delete Numba's cache directory, typically found at <code>__pycache__</code> folders containing <code>.nbi</code> and <code>.nbc</code> files.</li> <li>Check your compiler: Run <code>numba -s</code> to print system information and verify that a compatible C compiler is detected.</li> </ol> <p>First-run latency</p> <p>The first time you import BORES or run a simulation, Numba compiles several cached functions. This may take 10-30 seconds. Subsequent runs will be much faster because compiled code is cached to disk.</p>"},{"location":"getting-started/installation/#missing-blaslapack-libraries","title":"Missing BLAS/LAPACK libraries","text":"<p>scipy and numpy depend on optimized linear algebra libraries. On Linux, if you see errors about missing BLAS or LAPACK:</p> Ubuntu / DebianFedora / RHELmacOSWindows <pre><code>sudo apt-get install libopenblas-dev liblapack-dev\n</code></pre> <pre><code>sudo dnf install openblas-devel lapack-devel\n</code></pre> <p>macOS ships with the Accelerate framework, which provides BLAS/LAPACK. No additional installation is needed.</p> <p>The numpy and scipy wheels on PyPI bundle their own BLAS/LAPACK (OpenBLAS). No additional installation is typically required. If you installed via <code>uv</code> on x86_64, MKL-optimized versions are used automatically.</p>"},{"location":"getting-started/installation/#hdf5-build-failures","title":"HDF5 build failures","text":"<p>If <code>h5py</code> fails to install, it may be because the HDF5 C library is not available on your system:</p> Ubuntu / DebianmacOSWindows <pre><code>sudo apt-get install libhdf5-dev\n</code></pre> <pre><code>brew install hdf5\n</code></pre> <p>Pre-built wheels for h5py are available on PyPI and should install without issues. If you encounter problems, try upgrading pip: <code>pip install --upgrade pip</code>.</p>"},{"location":"getting-started/installation/#platform-notes","title":"Platform Notes","text":""},{"location":"getting-started/installation/#linux","title":"Linux","text":"<p>Linux is the primary development and testing platform for BORES. All features, including MKL-optimized linear algebra on x86_64, work out of the box with the standard installation.</p>"},{"location":"getting-started/installation/#macos","title":"macOS","text":"<p>BORES works on both Intel and Apple Silicon Macs. On Apple Silicon (M1/M2/M3/M4), Numba uses the ARM64 backend, which is fully supported. The Accelerate framework provides optimized BLAS/LAPACK.</p>"},{"location":"getting-started/installation/#windows","title":"Windows","text":"<p>BORES is supported on Windows 10 and later. If you are using Windows Subsystem for Linux (WSL), the Linux installation instructions apply. Native Windows installation works with both <code>uv</code> and <code>pip</code>.</p> <p>MKL Optimization</p> <p>On x86_64 Linux and Windows, BORES is configured to use Intel MKL-optimized versions of numpy and scipy when installed via <code>uv</code>. This provides significant performance improvements for linear algebra operations, which are central to reservoir simulation. macOS and non-x86 architectures use standard OpenBLAS builds.</p>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<p>With BORES installed, head to the Quickstart to build and run your first simulation.</p>"},{"location":"getting-started/quickstart/","title":"Quick Start","text":"<p>Build and run your first reservoir simulation in under 5 minutes.</p>"},{"location":"getting-started/quickstart/#prerequisites","title":"Prerequisites","text":"<p>Before starting, make sure you have BORES installed and working. If you have not done this yet, follow the Installation guide first. You can verify your installation by running:</p> <pre><code>import bores\nprint(f\"BORES version: {bores.__version__}\")\n</code></pre> <p>You will also need basic familiarity with Python and NumPy. No prior reservoir engineering knowledge is required to follow this tutorial, though it will help you interpret the results.</p>"},{"location":"getting-started/quickstart/#your-first-simulation","title":"Your First Simulation","text":"<p>The following example sets up a complete 3D waterflood simulation from scratch. You will define a 10x10x3 reservoir grid, place an injection well and a production well, configure the simulation, and run it for one year. Every line is commented so you can follow along.</p> <p>This is a single, self-contained script. You can copy it into a Python file or notebook and run it directly.</p> <pre><code>import bores\nimport numpy as np\n\n# ---------------------------------------------------------------------------\n# Step 1: Set precision\n# ---------------------------------------------------------------------------\n# BORES defaults to 32-bit floating point for speed.\n# You can switch to 64-bit with bores.use_64bit_precision() if you need\n# higher numerical accuracy.\nbores.use_32bit_precision()\n\n# ---------------------------------------------------------------------------\n# Step 2: Define the grid and initial property distributions\n# ---------------------------------------------------------------------------\n# A 10x10x3 grid means 10 cells in X, 10 in Y, 3 layers in Z.\n# Each cell is 100 ft x 100 ft in the horizontal plane.\ngrid_shape = (10, 10, 3)\ncell_dimension = (100.0, 100.0)  # (dx, dy) in feet\n\n# Build uniform grids for each property.\n# In a real study you would load heterogeneous data from files.\nthickness = bores.build_uniform_grid(grid_shape, value=20.0)        # ft per layer\npressure = bores.build_uniform_grid(grid_shape, value=3000.0)       # psi\nporosity = bores.build_uniform_grid(grid_shape, value=0.20)         # fraction\ntemperature = bores.build_uniform_grid(grid_shape, value=180.0)     # deg F\noil_viscosity = bores.build_uniform_grid(grid_shape, value=1.5)     # cP\nbubble_point = bores.build_uniform_grid(grid_shape, value=2500.0)   # psi\n\n# Residual and irreducible saturations\nSorw = bores.build_uniform_grid(grid_shape, value=0.20)  # Residual oil (waterflood)\nSorg = bores.build_uniform_grid(grid_shape, value=0.15)  # Residual oil (gas flood)\nSgr  = bores.build_uniform_grid(grid_shape, value=0.05)  # Residual gas\nSwir = bores.build_uniform_grid(grid_shape, value=0.20)  # Irreducible water\nSwc  = bores.build_uniform_grid(grid_shape, value=0.20)  # Connate water\n\n# Build depth grid from thickness and a datum (top of reservoir at 5000 ft)\ndepth = bores.build_depth_grid(thickness, datum=5000.0)\n\n# Build initial saturations from fluid contact depths.\n# Place GOC above the reservoir and OWC below it so all cells\n# are in the oil zone (undersaturated, no initial gas cap).\nSw, So, Sg = bores.build_saturation_grids(\n    depth_grid=depth,\n    gas_oil_contact=4999.0,      # Above reservoir top (no gas cap)\n    oil_water_contact=5100.0,    # Below reservoir base (all oil zone)\n    connate_water_saturation_grid=Swc,\n    residual_oil_saturation_water_grid=Sorw,\n    residual_oil_saturation_gas_grid=Sorg,\n    residual_gas_saturation_grid=Sgr,\n    porosity_grid=porosity,\n)\n\n# Oil specific gravity (needed for PVT correlations)\noil_sg = bores.build_uniform_grid(grid_shape, value=0.85)  # ~35 deg API\n\n# Isotropic permeability: 100 mD in all directions\nperm_grid = bores.build_uniform_grid(grid_shape, value=100.0)\npermeability = bores.RockPermeability(x=perm_grid, y=perm_grid, z=perm_grid)\n\n# ---------------------------------------------------------------------------\n# Step 3: Build the reservoir model\n# ---------------------------------------------------------------------------\n# The reservoir_model() factory handles all PVT correlation calculations,\n# grid validation, and internal property estimation automatically.\nmodel = bores.reservoir_model(\n    grid_shape=grid_shape,\n    cell_dimension=cell_dimension,\n    thickness_grid=thickness,\n    pressure_grid=pressure,\n    rock_compressibility=3e-6,            # psi^-1\n    absolute_permeability=permeability,\n    porosity_grid=porosity,\n    temperature_grid=temperature,\n    water_saturation_grid=Sw,\n    gas_saturation_grid=Sg,\n    oil_saturation_grid=So,\n    oil_viscosity_grid=oil_viscosity,\n    oil_specific_gravity_grid=oil_sg,\n    oil_bubble_point_pressure_grid=bubble_point,\n    residual_oil_saturation_water_grid=Sorw,\n    residual_oil_saturation_gas_grid=Sorg,\n    residual_gas_saturation_grid=Sgr,\n    irreducible_water_saturation_grid=Swir,\n    connate_water_saturation_grid=Swc,\n)\n\n# ---------------------------------------------------------------------------\n# Step 4: Define wells\n# ---------------------------------------------------------------------------\n# Injection well in corner cell (0,0) perforated across all 3 layers.\n# Positive rate = injection.\ninjector = bores.injection_well(\n    well_name=\"INJ-1\",\n    perforating_intervals=[((0, 0, 0), (0, 0, 2))],\n    radius=0.25,  # ft\n    control=bores.ConstantRateControl(target_rate=500.0),  # 500 STB/day\n    injected_fluid=bores.InjectedFluid(\n        name=\"Water\",\n        phase=bores.FluidPhase.WATER,\n        specific_gravity=1.0,\n        molecular_weight=18.015,\n    ),\n)\n\n# Production well in opposite corner (9,9) perforated across all 3 layers.\n# PrimaryPhaseRateControl fixes the oil rate; water and gas flow naturally.\nproducer = bores.production_well(\n    well_name=\"PROD-1\",\n    perforating_intervals=[((9, 9, 0), (9, 9, 2))],\n    radius=0.25,  # ft\n    control=bores.PrimaryPhaseRateControl(\n        primary_phase=bores.FluidPhase.OIL,\n        primary_control=bores.AdaptiveBHPRateControl(\n            target_rate=-500.0,    # produce 500 STB/day of oil\n            target_phase=\"oil\",\n            bhp_limit=1000.0,      # never drop below 1000 psi\n        ),\n        secondary_clamp=bores.ProductionClamp(),\n    ),\n    produced_fluids=[\n        bores.ProducedFluid(\n            name=\"Oil\", phase=bores.FluidPhase.OIL,\n            specific_gravity=0.85, molecular_weight=200.0,\n        ),\n        bores.ProducedFluid(\n            name=\"Water\", phase=bores.FluidPhase.WATER,\n            specific_gravity=1.0, molecular_weight=18.015,\n        ),\n    ],\n)\n\n# Group wells together\nwells = bores.wells_(injectors=[injector], producers=[producer])\n\n# ---------------------------------------------------------------------------\n# Step 5: Define rock-fluid properties\n# ---------------------------------------------------------------------------\n# Brooks-Corey relative permeability model with Corey exponents of 2.0.\n# The capillary pressure model uses default Brooks-Corey parameters.\nrock_fluid = bores.RockFluidTables(\n    relative_permeability_table=bores.BrooksCoreyThreePhaseRelPermModel(\n        water_exponent=2.0,\n        oil_exponent=2.0,\n        gas_exponent=2.0,\n    ),\n    capillary_pressure_table=bores.BrooksCoreyCapillaryPressureModel(),\n)\n\n# ---------------------------------------------------------------------------\n# Step 6: Configure the simulation\n# ---------------------------------------------------------------------------\n# The Time helper converts human-readable durations to seconds.\nTime = bores.Time\n\nconfig = bores.Config(\n    timer=bores.Timer(\n        initial_step_size=Time(days=1),\n        max_step_size=Time(days=10),\n        min_step_size=Time(hours=1),\n        simulation_time=Time(days=365),\n    ),\n    rock_fluid_tables=rock_fluid,\n    wells=wells,\n    scheme=\"impes\",  # Implicit Pressure, Explicit Saturation\n)\n\n# ---------------------------------------------------------------------------\n# Step 7: Run the simulation\n# ---------------------------------------------------------------------------\n# bores.run() returns a generator that yields ModelState objects.\n# Each state is a snapshot of the reservoir at a specific time step.\nstates = list(bores.run(model, config))\n\n# ---------------------------------------------------------------------------\n# Step 8: Inspect results\n# ---------------------------------------------------------------------------\nfinal = states[-1]\nprint(f\"Completed {final.step} steps in {final.time_in_days:.1f} days\")\nprint(f\"Final avg pressure: {final.model.fluid_properties.pressure_grid.mean():.1f} psi\")\nprint(f\"Final avg oil saturation: {final.model.fluid_properties.oil_saturation_grid.mean():.4f}\")\nprint(f\"Final avg water saturation: {final.model.fluid_properties.water_saturation_grid.mean():.4f}\")\n</code></pre> <p>First-run compilation</p> <p>The very first time you run a BORES simulation, Numba compiles several internal functions to machine code. This one-time compilation typically takes 10-30 seconds. Subsequent runs reuse the cached compiled code and will be significantly faster.</p>"},{"location":"getting-started/quickstart/#understanding-the-code","title":"Understanding the Code","text":"<p>Now that you have a working simulation, let's walk through what each step does and why it matters.</p>"},{"location":"getting-started/quickstart/#setting-precision","title":"Setting Precision","text":"<p>BORES uses 32-bit floating point (<code>float32</code>) by default. This provides a good balance between speed and accuracy for most reservoir simulations, especially on modern hardware where 32-bit SIMD operations are twice as fast as 64-bit. The precision setting is global and affects all array operations throughout the simulation.</p> <p>If you are working on a problem where numerical accuracy is critical, for example comparing against analytical solutions or running very long simulations where small errors accumulate, you can switch to 64-bit precision by calling <code>bores.use_64bit_precision()</code> before building your model. You can also use the <code>bores.with_precision()</code> context manager to temporarily change precision for a specific block of code.</p>"},{"location":"getting-started/quickstart/#building-property-grids","title":"Building Property Grids","text":"<p>Every cell in the reservoir grid needs a set of physical properties: pressure, temperature, porosity, permeability, saturations, and so on. The <code>bores.build_uniform_grid()</code> helper creates a NumPy array of the specified shape filled with a single value. In a real study, you would typically load heterogeneous property distributions from geological models or well log data.</p> <p>Residual saturations define the minimum amount of each phase that remains trapped in the rock after displacement. These values control the maximum recovery you can achieve and directly influence the shape of relative permeability curves. The irreducible water saturation (<code>Swir</code>) is the minimum water saturation achievable by oil drainage, while the connate water saturation (<code>Swc</code>) represents the initial water present when the reservoir was formed.</p>"},{"location":"getting-started/quickstart/#building-saturation-grids","title":"Building Saturation Grids","text":"<p>The <code>bores.build_saturation_grids()</code> function creates physically realistic initial saturation distributions from fluid contact depths. You provide a depth grid (built from <code>bores.build_depth_grid()</code>), the gas-oil contact (GOC) and oil-water contact (OWC) depths, and the residual saturation grids. The function divides the reservoir into three zones based on depth:</p> <ul> <li>Gas cap (above GOC): Gas has displaced oil, leaving residual oil to gas displacement (\\(S_{org}\\)) and connate water (\\(S_{wc}\\)).</li> <li>Oil zone (between GOC and OWC): Original oil accumulation with connate water and residual gas (\\(S_{gr}\\)).</li> <li>Water zone (below OWC): Water has displaced oil, leaving residual oil to water displacement (\\(S_{orw}\\)).</li> </ul> <p>In this example, the GOC is placed above the reservoir top and the OWC below the reservoir base. This means all cells fall in the oil zone, which is the correct initialization for an undersaturated reservoir with no gas cap and no aquifer. The resulting saturations satisfy the constraint \\(S_o + S_w + S_g = 1.0\\) in every cell automatically. You can also enable smooth capillary transition zones at the contacts by passing <code>use_transition_zones=True</code>.</p>"},{"location":"getting-started/quickstart/#the-reservoir_model-factory","title":"The <code>reservoir_model()</code> Factory","text":"<p>The <code>bores.reservoir_model()</code> factory function is the primary entry point for constructing a reservoir model. When you call it, several things happen behind the scenes. First, it validates your input grids: checking that saturations are in valid ranges, that pressure and temperature are physically reasonable, and that the grid shape is consistent across all properties.</p> <p>Second, it computes any fluid properties you did not provide explicitly. In this example, we supplied oil viscosity and bubble point pressure, but omitted properties like gas density, water compressibility, formation volume factors, and solution gas-oil ratio. The factory uses industry-standard PVT correlations (Standing, Vasquez-Beggs, Lee-Gonzalez, and others) to estimate these from pressure, temperature, and fluid gravity. This means you can get a working model with minimal input while retaining the option to override any property with your own data.</p> <p>Third, it assembles the <code>FluidProperties</code>, <code>RockProperties</code>, and <code>SaturationHistory</code> objects and packages them into an immutable <code>ReservoirModel</code>. Because the model is immutable, you can safely pass it around your code without worrying about accidental modifications.</p>"},{"location":"getting-started/quickstart/#defining-wells","title":"Defining Wells","text":"<p>Wells are the primary mechanism for injecting fluid into or producing fluid from the reservoir. BORES uses factory functions - <code>bores.injection_well()</code> and <code>bores.production_well()</code> - to construct well objects with validated parameters.</p> <p>Each well needs a name, one or more perforating intervals (defined as pairs of grid coordinates specifying where the well connects to the reservoir), a wellbore radius, a control mode, and a fluid specification. The perforating intervals in this example span from layer 0 to layer 2, meaning the well is open across all three layers.</p> <p>Sign Convention</p> <p>BORES uses a consistent sign convention throughout the entire framework: positive values mean injection (fluid flowing into the reservoir) and negative values mean production (fluid flowing out). This applies to well rates, flux boundaries, and all internal flow calculations. When you specify <code>target_rate=-500.0</code> for a producer, the negative sign tells BORES this is a production rate.</p> <p>The <code>PrimaryPhaseRateControl</code> on the producer is the standard approach in reservoir simulation. You fix the oil rate (the primary phase) at -500 STB/day, and the simulator computes the BHP needed to deliver that rate. Water and gas then produce at their natural rates at the resulting BHP. The inner <code>AdaptiveBHPRateControl</code> handles the automatic switch from rate to BHP mode when the well can no longer sustain the target rate without dropping below 1000 psi.</p>"},{"location":"getting-started/quickstart/#rock-fluid-properties","title":"Rock-Fluid Properties","text":"<p>The <code>BrooksCoreyThreePhaseRelPermModel</code> defines how easily each phase flows through the rock as a function of saturation. The Corey exponents control the curvature of the relative permeability curves: higher exponents produce steeper curves, meaning a phase needs higher saturation before it can flow significantly. An exponent of 2.0 is a common starting point for sandstone reservoirs.</p> <p>The capillary pressure model (<code>BrooksCoreyCapillaryPressureModel</code>) accounts for the pressure difference between phases at the pore scale. Capillary forces are especially important in fine-grained rocks and at saturation fronts. The default parameters are reasonable for an initial study, but you should calibrate them against core flood data for any serious analysis.</p> <p>These rock-fluid models are bundled into a <code>RockFluidTables</code> object, which the simulator queries at every time step to determine phase mobilities and capillary pressures at the current saturation state.</p>"},{"location":"getting-started/quickstart/#simulation-configuration","title":"Simulation Configuration","text":"<p>The <code>bores.Config</code> class gathers every simulation parameter into a single, immutable object. The <code>Timer</code> controls time stepping: it starts with a 1-day step, can grow to 10 days when conditions are stable, and can shrink to 1 hour when the solver needs smaller steps for convergence. The timer adapts automatically based on CFL conditions, pressure changes, and saturation changes.</p> <p>The <code>scheme=\"impes\"</code> setting selects the IMPES (Implicit Pressure, Explicit Saturation) evolution scheme, which solves pressure implicitly and then updates saturations explicitly. This is the default and most commonly used approach in black-oil simulation. It provides a good balance between stability (from implicit pressure) and efficiency (from explicit saturation transport).</p> <p>The <code>Config</code> object is frozen after creation. If you need to modify a parameter, use <code>config.copy(timer=new_timer)</code> or <code>config.with_updates(scheme=\"explicit\")</code> to create a new configuration with the desired changes.</p>"},{"location":"getting-started/quickstart/#running-the-simulation","title":"Running the Simulation","text":"<p>The <code>bores.run()</code> function accepts a <code>ReservoirModel</code> and a <code>Config</code> and returns a Python generator that yields <code>ModelState</code> objects. Each <code>ModelState</code> is a complete snapshot of the reservoir at a particular time step, including the updated model, well states, production and injection rates, relative permeabilities, and capillary pressures.</p> <p>In this example, <code>list(bores.run(model, config))</code> collects all states into a list. For large simulations, you may want to process states one at a time to conserve memory, or use <code>bores.StateStream</code> to persist them to disk as they are generated.</p> <p>The generator-based design means the simulation runs lazily. It only computes the next time step when you request the next state. This gives you full control over the simulation loop and lets you insert custom logic between steps, such as checking convergence criteria or modifying well controls.</p>"},{"location":"getting-started/quickstart/#streaming-results-to-storage","title":"Streaming Results to Storage","text":"<p>For long-running simulations, collecting all states in memory is impractical. BORES provides <code>StateStream</code> to write states to disk as they are computed, keeping memory usage low. Here is how you would modify the run loop to use a Zarr store:</p> <pre><code>import bores\n\n# ... (model and config setup from above) ...\n\nstore = bores.ZarrStore(\"waterflood_results.zarr\")\n\nwith bores.StateStream(states=bores.run(model, config), store=store) as stream:\n    for state in stream:\n        # Each state is persisted to disk automatically\n        if state.step % 10 == 0:\n            print(f\"Step {state.step}: P_avg = {state.model.fluid_properties.pressure_grid.mean():.1f} psi\")\n</code></pre> <p><code>StateStream</code> currently supports two storage backends <code>ZarrStore</code> and <code>HDF5Store</code>. Zarr is recommended for large simulations because it supports chunked, compressed storage and is efficient for both writing and later analysis.</p>"},{"location":"getting-started/quickstart/#basic-visualization","title":"Basic Visualization","text":"<p>BORES includes Plotly-based visualization tools for quick inspection of results. The <code>make_series_plot()</code> function creates line plots from time-series data:</p> <pre><code>import bores\nimport numpy as np\n\n# ... (run the simulation and collect states as before) ...\n\n# Extract average pressure over time\ntime_days = np.array([s.time_in_days for s in states])\navg_pressure = np.array([\n    s.model.fluid_properties.pressure_grid.mean() for s in states\n])\n\n# Create pressure vs time plot\npressure_series = np.column_stack([time_days, avg_pressure])\nfig = bores.make_series_plot(\n    data=pressure_series,\n    title=\"Average Reservoir Pressure\",\n    x_label=\"Time (days)\",\n    y_label=\"Pressure (psi)\",\n)\nfig.show()\n</code></pre> <p>Multiple Series</p> <p>You can plot multiple series by passing a dictionary of named arrays:</p> <pre><code>avg_So = np.array([s.model.fluid_properties.oil_saturation_grid.mean() for s in states])\navg_Sw = np.array([s.model.fluid_properties.water_saturation_grid.mean() for s in states])\n\nfig = bores.make_series_plot(\n    data={\n        \"Oil Saturation\": np.column_stack([time_days, avg_So]),\n        \"Water Saturation\": np.column_stack([time_days, avg_Sw]),\n    },\n    title=\"Average Saturations\",\n    x_label=\"Time (days)\",\n    y_label=\"Saturation (fraction)\",\n)\nfig.show()\n</code></pre>"},{"location":"getting-started/quickstart/#whats-next","title":"What's Next?","text":"<p>You now have a working simulation and a basic understanding of the BORES workflow. Here are the recommended next steps:</p> <ul> <li>Core Concepts - Understand the design principles behind BORES: immutable models, factory functions, generics, and the sign convention.</li> <li>User Guide - Deep dives into wells, boundary conditions, PVT correlations, relative permeability models, and solver configuration.</li> <li>Tutorials - Step-by-step walkthroughs of common workflows: depletion studies, waterflooding, gas injection, history matching, and more.</li> <li>API Reference - Complete documentation of every class, function, and parameter in the BORES package.</li> </ul>"},{"location":"reference/glossary/","title":"Glossary","text":""},{"location":"reference/glossary/#petroleum-engineering-terms","title":"Petroleum Engineering Terms","text":"API gravity A measure of how heavy or light a petroleum liquid is compared to water. Defined as \\(\\text{API} = \\frac{141.5}{\\gamma_o} - 131.5\\) where \\(\\gamma_o\\) is the oil specific gravity. Higher API values indicate lighter oils. Light crude is typically above 31 API, medium crude is 22 to 31, and heavy crude is below 22. Aquifer A body of water-bearing rock connected to the reservoir that provides pressure support as fluids are produced. Aquifers can be modeled analytically (using Carter-Tracy or Van Everdingen-Hurst models) or numerically (by extending the simulation grid into the water zone). Aquifer influx The volume of water flowing from an aquifer into the reservoir over time in response to pressure decline. Measured in reservoir barrels (bbl). Black-oil model A simplified thermodynamic model that describes reservoir fluids as three phases (oil, water, gas) with pressure-dependent properties. Gas can dissolve in oil (solution gas) but oil and water are immiscible with each other. This is the most widely used model for conventional reservoir simulation. Bottom-hole pressure (BHP) The pressure measured at the bottom of a well at the depth of the producing formation. BHP is the pressure used in flow rate calculations and well control specifications. Measured in psi. Bottom water drive A recovery mechanism where an aquifer located below the oil zone pushes water upward into the oil column as pressure declines, displacing oil toward the wells. Bubble point pressure The pressure at which the first gas bubble forms in an oil that is initially at a higher pressure (undersaturated). Below the bubble point, gas comes out of solution and forms a free gas phase. Also called saturation pressure. Capillary pressure The pressure difference across the interface between two immiscible fluids in a porous medium, caused by surface tension and wettability. Capillary pressure depends on the saturations of the phases and controls the distribution of fluids in the transition zones between fluid contacts. Compressibility A measure of how much a fluid or rock changes volume in response to a change in pressure. Defined as \\(c = -\\frac{1}{V}\\frac{\\partial V}{\\partial P}\\). Measured in psi\\(^{-1}\\). Connate water The water present in the pore spaces of a reservoir rock at the time of hydrocarbon accumulation. Connate water is held in place by capillary forces and is typically immobile during production. Also called irreducible water saturation (\\(S_{wc}\\)). Critical gas saturation The minimum gas saturation at which gas becomes mobile in a porous medium. Below this saturation, gas is trapped in isolated bubbles and cannot flow. Typically 2% to 5% of pore volume. Dip (structural) The angle of inclination of a rock layer relative to the horizontal. Structural dip affects gravity-driven flow and the position of fluid contacts. Measured in degrees. Edge water drive A recovery mechanism where an aquifer located at the lateral edges of the reservoir supplies water that displaces oil toward the producing wells. Effective permeability The permeability of a rock to a specific fluid phase when multiple phases are present. It is the product of absolute permeability and relative permeability: \\(k_{\\text{eff}} = k \\cdot k_r\\). Formation volume factor (FVF) The ratio of the volume of a fluid at reservoir conditions (pressure, temperature) to its volume at standard (surface) conditions. Oil FVF (\\(B_o\\)) is measured in bbl/STB. Gas FVF (\\(B_g\\)) is measured in ft3/SCF. Water FVF (\\(B_w\\)) is measured in bbl/STB. Gas-oil contact (GOC) The depth at which the gas cap meets the oil zone. Above the GOC, the pore space is primarily filled with gas. Below it, the pore space is primarily filled with oil (and connate water). Gas-oil ratio (GOR) The volume of gas produced per unit volume of oil produced, both measured at standard conditions. Measured in SCF/STB. Solution GOR (\\(R_s\\)) refers specifically to the gas dissolved in oil at reservoir conditions. Immiscible displacement A displacement process in which the injected fluid and the displaced fluid remain as separate phases (they do not mix at the molecular level). Waterflooding is the most common example of immiscible displacement. IMPES Implicit Pressure, Explicit Saturation. A numerical solution method that solves the pressure equation implicitly (unconditionally stable) and updates saturations explicitly (subject to CFL stability condition). This is the most common method for black-oil simulation because it balances stability and computational cost. Irreducible water saturation See Connate water. Miscible displacement A displacement process in which the injected fluid and the displaced fluid mix completely at the molecular level, eliminating the interface between them. Miscible displacement eliminates capillary trapping and can achieve very high recovery factors. Requires the injected fluid to be miscible with the oil, which depends on pressure, temperature, and composition. Minimum miscibility pressure (MMP) The lowest pressure at which a particular injection gas achieves miscible displacement with a particular oil. Below the MMP, the displacement is immiscible. Above the MMP, it is miscible. Measured in psi. Mobility The ratio of a phase's effective permeability to its viscosity: \\(\\lambda = k_r / \\mu\\). Mobility determines how easily a phase flows through the porous medium. The mobility ratio between displacing and displaced fluids controls sweep efficiency. Oil-water contact (OWC) The depth at which the oil zone meets the water zone. Below the OWC, the pore space is primarily filled with water. Permeability (absolute) A measure of a rock's ability to transmit fluid, independent of the fluid properties. Measured in millidarcies (mD). Higher permeability means fluid flows more easily through the rock. Porosity The fraction of the total rock volume that is pore space (voids). Effective porosity includes only the interconnected pores that can transmit fluid. Dimensionless, typically expressed as a decimal (0.20 = 20%). Relative permeability The ratio of the effective permeability of a phase at a given saturation to the absolute permeability of the rock. Dimensionless, ranges from 0 to 1. Relative permeability curves describe how easily each phase flows as a function of saturation. Residual oil saturation The fraction of oil that remains trapped in the pore spaces after displacement by water (\\(S_{orw}\\)) or gas (\\(S_{org}\\)). This oil is immobile and cannot be recovered by the displacing fluid. Typically 15% to 35% of pore volume for water flooding. Skin factor A dimensionless number that accounts for the additional pressure drop (positive skin) or reduced pressure drop (negative skin) near the wellbore due to formation damage, perforation, or stimulation. Positive skin indicates damage; negative skin indicates stimulation (e.g., hydraulic fracture). Solution gas Natural gas that is dissolved in oil at reservoir pressure and temperature. As pressure drops below the bubble point, solution gas comes out of the oil and forms a free gas phase. The amount of gas dissolved is described by the gas-oil ratio (\\(R_s\\)). Specific gravity The ratio of a substance's density to the density of a reference substance. For oil, the reference is water at standard conditions (\\(\\gamma_o = \\rho_o / \\rho_w\\)). For gas, the reference is air (\\(\\gamma_g = M_g / M_{\\text{air}}\\)). Transmissibility A quantity that describes the flow capacity between two adjacent grid cells. It incorporates the permeability, cross-sectional area, and distance between cell centers: \\(T = \\frac{k \\cdot A}{\\Delta x}\\). Transmissibility modification is how faults and fractures affect flow. Undersaturated oil Oil at a pressure above its bubble point, meaning all the gas that can dissolve in the oil at that temperature is dissolved. No free gas phase exists. As pressure drops below the bubble point, the oil becomes saturated and free gas appears. Water cut The fraction of the total produced liquid that is water, measured at surface conditions. Water cut increases during a waterflood as the injected water breaks through to the producing wells. Expressed as a fraction (0 to 1) or percentage. Water drive A natural recovery mechanism in which pressure support comes from water encroachment (from an aquifer or injected water), displacing oil toward the producing wells. Wettability The preference of the rock surface for one fluid over another. In a water-wet rock, water preferentially contacts the rock surface and occupies the smaller pores. In an oil-wet rock, oil preferentially contacts the surface. Wettability strongly affects relative permeability and capillary pressure curves."},{"location":"reference/glossary/#numerical-and-simulation-terms","title":"Numerical and Simulation Terms","text":"Boundary condition A mathematical specification of what happens at the edges of the simulation domain. Common types include no-flow (Neumann with zero flux), constant pressure (Dirichlet), and specified flux (Neumann with non-zero flux). Boundary conditions determine whether fluid can enter or leave the domain at its edges. CFL condition The Courant-Friedrichs-Lewy condition, a stability requirement for explicit numerical schemes. The CFL number must be less than 1 for stability: \\(\\text{CFL} = v \\cdot \\Delta t / \\Delta x &lt; 1\\). This limits the maximum timestep for a given grid resolution and flow velocity. Convergence tolerance The threshold that determines when an iterative solver has found a solution that is \"good enough.\" Tighter tolerances produce more accurate solutions but require more iterations. In BORES, pressure tolerance defaults to \\(10^{-6}\\) and saturation tolerance to \\(10^{-4}\\). Deserialization The process of reconstructing an object from its stored representation (dictionary, JSON, HDF5, etc.). The reverse of serialization. In BORES, deserialization uses the <code>load()</code> function or <code>from_dict()</code> method. Explicit scheme A numerical method that computes the solution at the next timestep directly from the current timestep values, without solving a system of equations. Fast per step but subject to CFL stability limits. Grid cell The fundamental spatial unit of the simulation domain. Each cell has a position, size, and a set of property values (pressure, saturations, porosity, permeability). Cells exchange fluid with their neighbors according to Darcy's law. Implicit scheme A numerical method that computes the solution at the next timestep by solving a system of equations that couples the new and current timestep values. Unconditionally stable (no CFL limit) but more expensive per step and requires iterative solvers. Krylov method A class of iterative methods for solving large sparse linear systems. Named after Alexei Krylov. Examples include Conjugate Gradient (CG), BiCGSTAB, and GMRES. These methods build a solution in a subspace that grows with each iteration. Preconditioner A transformation applied to a linear system to make it easier for an iterative solver to converge. A good preconditioner approximates the inverse of the coefficient matrix. Common preconditioners include ILU (Incomplete LU), AMG (Algebraic Multigrid), and Jacobi (diagonal). Registration In BORES, the process of adding a custom object (solver, preconditioner, well control, boundary function) to the framework's internal registry so it can be referenced by name and serialized/deserialized correctly. Done using decorator functions like <code>@solver_func</code>, <code>@preconditioner_factory</code>, <code>@well_control</code>. Renderer In the visualization system, a class responsible for producing a specific type of plot (line, heatmap, volume, etc.). Renderers are used by the <code>DataVisualizer</code> class to generate Plotly figures. Serialization The process of converting an object into a storable representation (dictionary, JSON, HDF5, etc.) that can be saved to disk and later reconstructed. In BORES, serialization uses the <code>dump()</code> function or <code>to_dict()</code> method. Timestep The discrete time interval over which the simulator advances the solution from one state to the next. Smaller timesteps are more accurate but more expensive. Adaptive timestep control adjusts the interval automatically based on solution behavior. Transmissibility See the petroleum term above. In numerical context, transmissibility is precomputed between each pair of adjacent cells and stored in the coefficient matrix. Modifying transmissibility (via faults or fractures) changes the flow connectivity of the grid."},{"location":"reference/units/","title":"Units","text":""},{"location":"reference/units/#overview","title":"Overview","text":"<p>BORES uses oil-field units throughout the entire framework. This is the most common unit system in petroleum engineering in North America, and it is the system used by the empirical correlations that BORES implements (Standing, Vazquez-Beggs, Hall-Yarborough, etc.). Using a consistent unit system eliminates the need for unit conversions inside the simulator and reduces the risk of conversion errors.</p> <p>If you are accustomed to SI units, you will need to convert your input data to oil-field units before passing it to BORES. The conversion tables below cover the most common quantities. There is no built-in unit conversion system in BORES, so conversions must be done externally (using NumPy, pint, or manual multiplication).</p>"},{"location":"reference/units/#standard-unit-system","title":"Standard Unit System","text":""},{"location":"reference/units/#pressure","title":"Pressure","text":"Quantity Unit Symbol Reservoir pressure pounds per square inch psi Bottom-hole pressure pounds per square inch psi Capillary pressure pounds per square inch psi Standard pressure 14.696 psi psi"},{"location":"reference/units/#temperature","title":"Temperature","text":"Quantity Unit Symbol Reservoir temperature degrees Fahrenheit F Standard temperature 60.0 F F <p>Temperature in Correlations</p> <p>Some internal calculations convert to Rankine (\\(R = F + 459.67\\)) for absolute temperature ratios. You always provide temperatures in Fahrenheit; the conversion happens internally.</p>"},{"location":"reference/units/#length","title":"Length","text":"Quantity Unit Symbol Grid cell dimensions feet ft Reservoir depth feet ft Wellbore radius feet ft Formation thickness feet ft"},{"location":"reference/units/#area-and-volume","title":"Area and Volume","text":"Quantity Unit Symbol Cross-sectional area square feet ft2 Pore volume reservoir barrels bbl Grid cell volume cubic feet ft3"},{"location":"reference/units/#flow-rates","title":"Flow Rates","text":"Quantity Unit Symbol Oil rate (reservoir) barrels per day bbl/day Oil rate (surface) stock-tank barrels per day STB/day Gas rate (reservoir) cubic feet per day ft3/day Gas rate (surface) standard cubic feet per day SCF/day Water rate barrels per day bbl/day"},{"location":"reference/units/#fluid-properties","title":"Fluid Properties","text":"Quantity Unit Symbol Oil formation volume factor barrels per stock-tank barrel bbl/STB Gas formation volume factor cubic feet per standard cubic foot ft3/SCF Water formation volume factor barrels per stock-tank barrel bbl/STB Oil viscosity centipoise cP Gas viscosity centipoise cP Water viscosity centipoise cP Oil density pounds-mass per cubic foot lbm/ft3 Gas density pounds-mass per cubic foot lbm/ft3 Water density pounds-mass per cubic foot lbm/ft3 Oil compressibility inverse psi psi-1 Gas compressibility inverse psi psi-1 Water compressibility inverse psi psi-1 Oil specific gravity dimensionless (relative to water) - Gas specific gravity dimensionless (relative to air) - API gravity degrees API API Gas-oil ratio standard cubic feet per stock-tank barrel SCF/STB Gas solubility in water standard cubic feet per stock-tank barrel SCF/STB Salinity parts per million ppm"},{"location":"reference/units/#rock-properties","title":"Rock Properties","text":"Quantity Unit Symbol Permeability millidarcies mD Porosity dimensionless (fraction) - Rock compressibility inverse psi psi-1 Relative permeability dimensionless (fraction) -"},{"location":"reference/units/#time","title":"Time","text":"Quantity Unit Symbol Internal simulation time seconds s Timer parameters seconds s Display convention days, years - <p>Time Units</p> <p>BORES stores all time values internally in seconds. The <code>Time()</code> helper function converts from human-readable units (days, months, years) to seconds:</p> <pre><code>import bores\n\none_day = bores.Time(days=1)          # 86400.0 seconds\none_year = bores.Time(years=1)        # 31557600.0 seconds\ncombined = bores.Time(days=30, hours=6)  # 2613600.0 seconds\n</code></pre>"},{"location":"reference/units/#dimensionless-quantities","title":"Dimensionless Quantities","text":"Quantity Range Porosity 0 to 1 (typically 0.05 to 0.35) Saturation (oil, water, gas) 0 to 1 Relative permeability 0 to 1 Z-factor (gas compressibility factor) 0 to ~2 (typically 0.3 to 1.0) CFL number 0 to ~1 (must be &lt; 1 for stability) Skin factor typically -5 to +20 Todd-Longstaff omega 0 (fully segregated) to 1 (fully mixed)"},{"location":"reference/units/#common-conversions-from-si","title":"Common Conversions from SI","text":"<p>If your data is in SI units, use these conversion factors:</p> Quantity SI Unit Oil-Field Unit Multiply SI by Pressure Pa (Pascal) psi 1.450377e-4 Pressure MPa psi 145.0377 Pressure bar psi 14.50377 Pressure atm psi 14.696 Temperature Celsius Fahrenheit \\(F = C \\times 9/5 + 32\\) Temperature Kelvin Fahrenheit \\(F = (K - 273.15) \\times 9/5 + 32\\) Length meters feet 3.28084 Length centimeters feet 0.0328084 Permeability m2 mD 1.01325e+15 Permeability Darcy mD 1000 Viscosity Pa.s cP 1000 Viscosity mPa.s cP 1.0 Density kg/m3 lbm/ft3 0.062428 Volume m3 bbl 6.28981 Volume liters bbl 0.00628981 Flow rate m3/s bbl/day 543439.65 Flow rate m3/day bbl/day 6.28981 Compressibility Pa-1 psi-1 6894.757"},{"location":"reference/units/#example-conversion","title":"Example Conversion","text":"<pre><code>import numpy as np\n\n# Convert SI pressure data to oil-field units\npressure_mpa = np.array([20.0, 25.0, 30.0])  # MPa\npressure_psi = pressure_mpa * 145.0377         # psi\n\n# Convert SI permeability to oil-field units\nperm_m2 = 1e-13                                # m^2\nperm_md = perm_m2 * 1.01325e15                 # mD (= 101.325 mD)\n\n# Convert Celsius to Fahrenheit\ntemp_c = 93.3                                  # Celsius\ntemp_f = temp_c * 9.0 / 5.0 + 32.0            # Fahrenheit (= 200 F)\n</code></pre>"},{"location":"reference/units/#standard-conditions","title":"Standard Conditions","text":"<p>BORES uses the following standard (surface) conditions, consistent with petroleum industry conventions:</p> Quantity Value Standard pressure 14.696 psi (1 atm) Standard temperature 60.0 F (15.56 C) <p>These are the conditions at which surface volumes (STB, SCF) are defined. Formation volume factors convert between reservoir conditions and these standard conditions.</p> <p>You can access these values programmatically through the constants system:</p> <pre><code>import bores\n\nprint(bores.c.STANDARD_PRESSURE)     # 14.696 psi\nprint(bores.c.STANDARD_TEMPERATURE)  # 60.0 F\n</code></pre>"},{"location":"reference/units/#sign-conventions","title":"Sign Conventions","text":"<p>BORES uses the following sign conventions throughout the library:</p> Quantity Positive Means Negative Means Flow rate at wells Injection into reservoir Production from reservoir Flux at boundaries Inflow to domain Outflow from domain Depth Increasing downward - Elevation Increasing upward - Skin factor Formation damage Stimulation"},{"location":"tutorials/","title":"Tutorials","text":"<p>Step-by-step guides that walk you through complete reservoir simulation workflows, from simple depletion to advanced miscible flooding.</p>"},{"location":"tutorials/#prerequisites","title":"Prerequisites","text":"<p>Before starting these tutorials, make sure you have completed the following:</p> <ol> <li>Installation - BORES is installed and working in your environment.</li> <li>Quickstart - You have run the quickstart example successfully.</li> <li>Core Concepts - You understand the simulation pipeline, immutable models, and factory functions.</li> </ol> <p>You should also be comfortable with Python and NumPy basics. Each tutorial builds on the previous one, so we recommend following them in order.</p>"},{"location":"tutorials/#tutorial-roadmap","title":"Tutorial Roadmap","text":"<p>The tutorials progress from fundamental skills to advanced recovery techniques. Each one introduces new concepts while reinforcing what you have already learned.</p> <ul> <li> <p>Your First Simulation</p> <p>Build a simple depletion model with a single production well. Learn the complete simulation workflow from grid construction to result visualization.</p> <p> Tutorial 1</p> </li> <li> <p>Building Reservoir Models</p> <p>Construct realistic heterogeneous models with layered properties, anisotropic permeability, structural dip, and 3D visualization.</p> <p> Tutorial 2</p> </li> <li> <p>Waterflood Simulation</p> <p>Set up a complete waterflood with injection and production wells. Track water breakthrough, water cut, and oil recovery factor.</p> <p> Tutorial 3</p> </li> <li> <p>Gas Injection</p> <p>Simulate immiscible gas injection and observe gravity override, gas mobility effects, and compare recovery against waterflooding.</p> <p> Tutorial 4</p> </li> <li> <p>Miscible Gas Flooding</p> <p>Model miscible displacement with the Todd-Longstaff method. Configure CO2 injection with custom fluid properties and analyze mixing behavior.</p> <p> Tutorial 5</p> </li> </ul>"},{"location":"tutorials/#suggested-reading-order","title":"Suggested Reading Order","text":"Order Tutorial What You Will Learn Time 1 Your First Simulation Full simulation workflow, depletion drive, basic visualization 20 min 2 Building Reservoir Models Heterogeneity, anisotropy, structural dip, 3D visualization 25 min 3 Waterflood Simulation Injection wells, water breakthrough, recovery analysis 30 min 4 Gas Injection Gas injectors, gravity effects, gas-oil displacement 25 min 5 Miscible Gas Flooding Todd-Longstaff model, CO2 properties, miscible displacement 30 min <p>Learning Approach</p> <p>Each tutorial is self-contained with complete, runnable code. However, the explanations assume familiarity with earlier tutorials. If you jump ahead and encounter an unfamiliar concept, check the earlier tutorials or the Core Concepts page.</p>"},{"location":"tutorials/01-first-simulation/","title":"Your First Simulation","text":"<p>Build a complete depletion simulation from scratch and learn every step of the BORES workflow.</p>"},{"location":"tutorials/01-first-simulation/#overview","title":"Overview","text":"<p>In this tutorial, you will build a small 3D reservoir model with a single production well, run a primary depletion simulation, and visualize the results. Unlike the Quickstart, which focused on getting a simulation running as fast as possible, this tutorial explains the why behind every parameter choice. By the end, you will understand how pressure, saturation, and production evolve during depletion drive and be ready to tackle more complex scenarios.</p> <p>Primary depletion is the simplest recovery mechanism: you produce oil from the reservoir without injecting any fluid to maintain pressure. As oil is withdrawn, reservoir pressure declines, dissolved gas comes out of solution (if pressure drops below the bubble point), and eventually the production rate falls because there is not enough pressure to push fluid to the wellbore. Understanding this baseline behavior is essential before studying enhanced recovery methods like waterflooding or gas injection.</p> <p>We will work with a 10x10x3 homogeneous reservoir - small enough to run in seconds but large enough to observe realistic pressure and saturation trends across the grid.</p>"},{"location":"tutorials/01-first-simulation/#physical-setup","title":"Physical Setup","text":"<p>Our model represents a small sandstone reservoir with the following characteristics:</p> <ul> <li>Grid: 10 cells in X, 10 cells in Y, 3 layers in Z (300 total cells)</li> <li>Cell size: 100 ft x 100 ft horizontally, 20 ft thick per layer</li> <li>Porosity: 20% (uniform)</li> <li>Permeability: 100 mD isotropic</li> <li>Initial pressure: 3,000 psi (above bubble point)</li> <li>Bubble point: 2,500 psi</li> <li>Temperature: 180 F</li> <li>Oil viscosity: 1.5 cP (light to medium oil)</li> <li>Initial saturations: 75% oil, 25% connate water, 0% gas</li> </ul> <p>The single production well sits at grid location (5, 5) - roughly the center of the reservoir - and is perforated across all three layers. It operates under adaptive BHP-rate control, targeting 200 STB/day of oil production with a minimum BHP of 500 psi.</p> <p>Why Start Above Bubble Point?</p> <p>Starting with the reservoir pressure above the bubble point means we begin in the undersaturated regime. All gas is dissolved in the oil phase. As we produce and pressure drops, we will eventually cross the bubble point, free gas will appear, and the system transitions to two-phase (oil + gas) flow. This transition is one of the most important phenomena in reservoir engineering, and observing it in simulation helps build intuition for real-world behavior.</p>"},{"location":"tutorials/01-first-simulation/#step-1-import-and-set-precision","title":"Step 1 - Import and Set Precision","text":"<pre><code>import bores\nimport numpy as np\n\n# Use 32-bit precision (default, faster computation)\nbores.use_32bit_precision()\n</code></pre> <p>BORES defaults to 32-bit floating point for performance. On modern hardware, 32-bit SIMD operations are roughly twice as fast as 64-bit. For this tutorial, 32-bit precision is more than adequate. If you were comparing results against analytical solutions or running very long simulations where small errors accumulate, you would switch to <code>bores.use_64bit_precision()</code>.</p>"},{"location":"tutorials/01-first-simulation/#step-2-define-grid-and-properties","title":"Step 2 - Define Grid and Properties","text":"<pre><code># Grid dimensions\ngrid_shape = (10, 10, 3)\ncell_dimension = (100.0, 100.0)  # (dx, dy) in feet\n\n# Build uniform property grids\nthickness = bores.build_uniform_grid(grid_shape, value=20.0)        # ft per layer\npressure = bores.build_uniform_grid(grid_shape, value=3000.0)       # psi\nporosity = bores.build_uniform_grid(grid_shape, value=0.20)         # fraction\ntemperature = bores.build_uniform_grid(grid_shape, value=180.0)     # deg F\noil_viscosity = bores.build_uniform_grid(grid_shape, value=1.5)     # cP\nbubble_point = bores.build_uniform_grid(grid_shape, value=2500.0)   # psi\noil_sg = bores.build_uniform_grid(grid_shape, value=0.85)           # ~35 deg API\n\n# Residual and irreducible saturations\nSorw = bores.build_uniform_grid(grid_shape, value=0.20)  # Residual oil (waterflood)\nSorg = bores.build_uniform_grid(grid_shape, value=0.15)  # Residual oil (gas flood)\nSgr  = bores.build_uniform_grid(grid_shape, value=0.05)  # Residual gas\nSwir = bores.build_uniform_grid(grid_shape, value=0.20)  # Irreducible water\nSwc  = bores.build_uniform_grid(grid_shape, value=0.20)  # Connate water\n\n# Build initial saturations from fluid contacts\n# Depth grid: top of reservoir at 5000 ft, 20 ft per layer\ndepth = bores.depth_grid(thickness_grid=thickness, datum=5000.0)\n\nSw, So, Sg = bores.build_saturation_grids(\n    depth_grid=depth,\n    gas_oil_contact=4900.0,       # GOC above reservoir (no initial gas cap)\n    oil_water_contact=5100.0,     # OWC near reservoir bottom\n    connate_water_saturation_grid=Swc,\n    residual_oil_saturation_water_grid=Sorw,\n    residual_oil_saturation_gas_grid=Sorg,\n    residual_gas_saturation_grid=Sgr,\n    porosity_grid=porosity,\n)\n</code></pre> <p>Each call to <code>bores.build_uniform_grid()</code> creates a NumPy array of the specified shape filled with a single value. In a real study, you would load heterogeneous data from geological models, well logs, or geostatistical realizations. For this tutorial, uniform properties let us focus on understanding the simulation workflow without the complexity of spatial heterogeneity.</p> <p>The <code>bores.build_saturation_grids()</code> function computes physically consistent initial saturations from fluid contact depths. You provide the gas-oil contact (GOC) and oil-water contact (OWC) depths, along with residual saturation grids, and BORES assigns each cell to the correct fluid zone. Cells above the GOC get gas and connate water, cells between GOC and OWC get oil and connate water, and cells below the OWC get water. This ensures that \\(S_o + S_w + S_g = 1.0\\) everywhere, which is fundamental to the black-oil formulation. Here we place the GOC above the reservoir (no gas cap) and the OWC near the bottom, giving mostly oil with connate water.</p> <p>The oil specific gravity of 0.85 corresponds to roughly 35 degrees API, which is a light to medium crude oil. This value drives the PVT correlations that BORES uses to estimate properties like solution gas-oil ratio, formation volume factor, and oil density.</p>"},{"location":"tutorials/01-first-simulation/#step-3-set-up-permeability","title":"Step 3 - Set Up Permeability","text":"<pre><code># Isotropic permeability: 100 mD in all directions\nperm_grid = bores.build_uniform_grid(grid_shape, value=100.0)\npermeability = bores.RockPermeability(x=perm_grid, y=perm_grid, z=perm_grid)\n</code></pre> <p>Permeability controls how easily fluid flows through the rock. We use <code>bores.RockPermeability</code> to define permeability in each direction. For isotropic rock (same permeability everywhere), you can pass the same grid for x, y, and z. If you only provide the x-direction grid, BORES assumes isotropy and copies it to y and z automatically.</p> <p>A value of 100 mD is typical of a good quality sandstone reservoir. In the next tutorial, you will learn how to create anisotropic permeability where vertical permeability differs from horizontal, which is very common in real reservoirs due to layered deposition.</p> <p>Shortcut for Isotropic Permeability</p> <p>If your permeability is isotropic, you can pass just the x-direction grid and BORES will use it for all directions:</p> <pre><code>permeability = bores.RockPermeability(x=perm_grid)\n# y and z are automatically set equal to x\n</code></pre>"},{"location":"tutorials/01-first-simulation/#step-4-build-the-reservoir-model","title":"Step 4 - Build the Reservoir Model","text":"<pre><code>model = bores.reservoir_model(\n    grid_shape=grid_shape,\n    cell_dimension=cell_dimension,\n    thickness_grid=thickness,\n    pressure_grid=pressure,\n    rock_compressibility=3e-6,            # psi^-1\n    absolute_permeability=permeability,\n    porosity_grid=porosity,\n    temperature_grid=temperature,\n    water_saturation_grid=Sw,\n    gas_saturation_grid=Sg,\n    oil_saturation_grid=So,\n    oil_viscosity_grid=oil_viscosity,\n    oil_specific_gravity_grid=oil_sg,\n    oil_bubble_point_pressure_grid=bubble_point,\n    residual_oil_saturation_water_grid=Sorw,\n    residual_oil_saturation_gas_grid=Sorg,\n    residual_gas_saturation_grid=Sgr,\n    irreducible_water_saturation_grid=Swir,\n    connate_water_saturation_grid=Swc,\n)\n</code></pre> <p>The <code>bores.reservoir_model()</code> factory does a lot of work behind the scenes. It validates all your inputs, then computes every fluid property you did not provide explicitly: gas viscosity, gas density, gas compressibility factor, gas formation volume factor, water density, water compressibility, oil formation volume factor, oil compressibility, solution gas-oil ratio, and many others. All of these are estimated from pressure, temperature, and fluid gravity using industry-standard PVT correlations (Standing, Vasquez-Beggs, Lee-Gonzalez, and others).</p> <p>The rock compressibility of \\(3 \\times 10^{-6}\\) psi\\(^{-1}\\) is typical for consolidated sandstone. This parameter controls how much the pore volume changes with pressure. While small compared to fluid compressibilities, rock compressibility contributes to the total system compressibility that governs pressure diffusion.</p> <p>The resulting <code>model</code> object is immutable. You cannot modify its properties after construction, which ensures your initial conditions remain untouched throughout the simulation.</p> <p>Oil Specific Gravity is Required</p> <p>You must provide <code>oil_specific_gravity_grid</code> (or use PVT tables) so that BORES can compute API gravity and all downstream oil PVT properties. Without it, the factory will raise a <code>ValidationError</code>.</p>"},{"location":"tutorials/01-first-simulation/#step-5-define-the-production-well","title":"Step 5 - Define the Production Well","text":"<pre><code>producer = bores.production_well(\n    well_name=\"PROD-1\",\n    perforating_intervals=[((5, 5, 0), (5, 5, 2))],\n    radius=0.25,  # ft\n    control=bores.PrimaryPhaseRateControl(\n        primary_phase=bores.FluidPhase.OIL,\n        primary_control=bores.AdaptiveBHPRateControl(\n            target_rate=-200.0,    # produce 200 STB/day of oil\n            target_phase=\"oil\",\n            bhp_limit=500.0,       # minimum BHP constraint\n        ),\n        secondary_clamp=bores.ProductionClamp(),\n    ),\n    produced_fluids=[\n        bores.ProducedFluid(\n            name=\"Oil\", phase=bores.FluidPhase.OIL,\n            specific_gravity=0.85, molecular_weight=200.0,\n        ),\n        bores.ProducedFluid(\n            name=\"Water\", phase=bores.FluidPhase.WATER,\n            specific_gravity=1.0, molecular_weight=18.015,\n        ),\n        bores.ProducedFluid(\n            name=\"Gas\", phase=bores.FluidPhase.GAS,\n            specific_gravity=0.65, molecular_weight=16.04,\n        ),\n    ],\n)\n\nwells = bores.wells_(producers=[producer])\n</code></pre> <p>The well is placed at grid location (5, 5) and perforated from layer 0 to layer 2, connecting it to all three reservoir layers. The perforating interval is specified as a pair of (x, y, z) coordinates: the start and end of the perforation.</p> <p>We use <code>PrimaryPhaseRateControl</code> because it is the standard approach in reservoir simulation for production wells. You fix the oil rate (the primary phase), and the simulator computes the BHP required to deliver that rate. Water and gas then flow at whatever their natural Darcy rates are at the resulting BHP. This is far more realistic than applying the same rate to all phases.</p> <p>Inside the primary control, <code>AdaptiveBHPRateControl</code> handles the oil rate target of -200 STB/day (negative = production). When reservoir pressure is high, the well achieves this rate. As pressure declines, eventually the drawdown needed to maintain -200 STB/day would push BHP below 500 psi. At that point, the control automatically switches to constant-BHP mode and lets the oil rate decline naturally. The <code>ProductionClamp</code> on the secondary phases prevents backflow of water or gas into the reservoir.</p> <p>The <code>produced_fluids</code> list tells the simulator which phases can flow into this well. Even though we start with no free gas, we include a gas <code>ProducedFluid</code> because gas will appear once pressure drops below the bubble point.</p> <p>The <code>wells_()</code> factory groups wells into a <code>Wells</code> container. Since this is a depletion study with no injection, we only have producers.</p>"},{"location":"tutorials/01-first-simulation/#step-6-configure-rock-fluid-properties","title":"Step 6 - Configure Rock-Fluid Properties","text":"<pre><code>rock_fluid = bores.RockFluidTables(\n    relative_permeability_table=bores.BrooksCoreyThreePhaseRelPermModel(\n        water_exponent=2.0,\n        oil_exponent=2.0,\n        gas_exponent=2.0,\n    ),\n    capillary_pressure_table=bores.BrooksCoreyCapillaryPressureModel(),\n)\n</code></pre> <p>The <code>BrooksCoreyThreePhaseRelPermModel</code> defines how relative permeability varies with saturation using the Corey power-law model. The exponents control curve shape: an exponent of 2.0 produces moderately curved functions that are a reasonable starting point for sandstone. Higher exponents (3-4) would make the curves steeper, meaning phases need higher saturation before they can flow significantly.</p> <p>The <code>BrooksCoreyCapillaryPressureModel</code> uses default parameters suitable for a first approximation. Capillary pressure represents the pressure difference between phases at the pore scale due to surface tension. For this tutorial, the defaults are adequate. In the Building Reservoir Models tutorial, you will see how to customize these parameters.</p> <p>Both models are bundled into a <code>RockFluidTables</code> object, which the simulator queries at every time step.</p>"},{"location":"tutorials/01-first-simulation/#step-7-set-up-the-timer-and-configuration","title":"Step 7 - Set Up the Timer and Configuration","text":"<pre><code>config = bores.Config(\n    timer=bores.Timer(\n        initial_step_size=bores.Time(days=1),\n        max_step_size=bores.Time(days=15),\n        min_step_size=bores.Time(hours=1),\n        simulation_time=bores.Time(days=730),   # 2 years\n    ),\n    rock_fluid_tables=rock_fluid,\n    wells=wells,\n    scheme=\"impes\",\n)\n</code></pre> <p>The <code>bores.Time()</code> helper converts human-readable durations to seconds, which is the internal time unit used by BORES. You can combine units freely: <code>bores.Time(years=1, days=30)</code> gives you one year plus thirty days.</p> <p>The <code>Timer</code> manages adaptive time stepping. It starts with a 1-day step, can grow to 15 days when conditions are stable, and can shrink to 1 hour if the solver needs smaller steps for convergence. The timer automatically adjusts based on CFL conditions, pressure changes, and saturation changes. For a depletion study, pressure changes are usually gradual, so the timer will ramp up to larger steps fairly quickly.</p> <p>We simulate for 730 days (2 years) to observe the full depletion cycle: initial high-rate production, pressure decline through the bubble point, gas liberation, and eventual rate decline as pressure support diminishes.</p> <p>The <code>scheme=\"impes\"</code> setting selects the IMPES (Implicit Pressure, Explicit Saturation) evolution scheme. This is the standard choice for most black-oil simulations, offering good stability from implicit pressure solving with the efficiency of explicit saturation transport.</p>"},{"location":"tutorials/01-first-simulation/#step-8-run-the-simulation","title":"Step 8 - Run the Simulation","text":"<pre><code># Run and collect all states\nstates = list(bores.run(model, config))\n\n# Print summary\nfinal = states[-1]\nprint(f\"Completed {final.step} steps in {final.time_in_days:.1f} days\")\nprint(f\"Final avg pressure: {final.model.fluid_properties.pressure_grid.mean():.1f} psi\")\nprint(f\"Final avg oil saturation: {final.model.fluid_properties.oil_saturation_grid.mean():.4f}\")\n</code></pre> <p>The <code>bores.run()</code> function returns a Python generator. Each iteration advances the simulation by one time step and yields a <code>ModelState</code> snapshot. Wrapping it with <code>list()</code> collects all snapshots into memory. For this small model, that is perfectly fine. For larger models, you would use <code>StateStream</code> to persist states to disk as they are generated.</p> <p>Each <code>ModelState</code> contains the complete reservoir state at that time step, including the updated model, well states, injection and production rate grids, relative permeabilities, and capillary pressures.</p> <p>First-Run Compilation</p> <p>The first time you run a BORES simulation, Numba compiles several internal functions to machine code. This one-time compilation typically takes 10-30 seconds. Subsequent runs reuse the cached compiled code and start immediately.</p>"},{"location":"tutorials/01-first-simulation/#step-9-visualize-results","title":"Step 9 - Visualize Results","text":""},{"location":"tutorials/01-first-simulation/#pressure-decline","title":"Pressure Decline","text":"<pre><code>import numpy as np\n\n# Extract time series data\ntime_days = np.array([s.time_in_days for s in states])\navg_pressure = np.array([\n    s.model.fluid_properties.pressure_grid.mean() for s in states\n])\n\n# Plot pressure vs time\npressure_series = np.column_stack([time_days, avg_pressure])\nfig = bores.make_series_plot(\n    data=pressure_series,\n    title=\"Average Reservoir Pressure During Depletion\",\n    x_label=\"Time (days)\",\n    y_label=\"Pressure (psi)\",\n)\nfig.show()\n</code></pre> <p>You should see pressure declining from 3,000 psi toward lower values over the 2-year period. The rate of decline depends on the production rate relative to the total compressible volume of the reservoir. When pressure crosses the bubble point (2,500 psi), the decline may slow because gas liberation provides additional drive energy.</p>"},{"location":"tutorials/01-first-simulation/#saturation-evolution","title":"Saturation Evolution","text":"<pre><code>avg_So = np.array([\n    s.model.fluid_properties.oil_saturation_grid.mean() for s in states\n])\navg_Sg = np.array([\n    s.model.fluid_properties.gas_saturation_grid.mean() for s in states\n])\n\nfig = bores.make_series_plot(\n    data={\n        \"Oil Saturation\": np.column_stack([time_days, avg_So]),\n        \"Gas Saturation\": np.column_stack([time_days, avg_Sg]),\n    },\n    title=\"Average Saturations During Depletion\",\n    x_label=\"Time (days)\",\n    y_label=\"Saturation (fraction)\",\n)\nfig.show()\n</code></pre> <p>As pressure drops below the bubble point, gas comes out of solution and gas saturation increases. Oil saturation decreases both because oil is being produced and because the oil formation volume factor changes (oil shrinks as gas leaves it). This is the classic solution gas drive mechanism.</p>"},{"location":"tutorials/01-first-simulation/#3d-pressure-distribution","title":"3D Pressure Distribution","text":"<pre><code>viz = bores.plotly3d.DataVisualizer()\nfig = viz.make_plot(\n    source=states[-1],\n    property=\"pressure\",\n    plot_type=\"volume\",\n    title=\"Final Pressure Distribution\",\n)\nfig.show()\n</code></pre> <p>The 3D visualization shows the pressure distribution at the final time step. You should see lower pressure near the production well and higher pressure at the reservoir boundaries, reflecting the pressure drawdown cone around the wellbore.</p>"},{"location":"tutorials/01-first-simulation/#key-takeaways","title":"Key Takeaways","text":"<ol> <li> <p>Depletion drive relies solely on the natural energy stored in compressed rock and fluids. Without pressure maintenance (injection), production rates eventually decline.</p> </li> <li> <p>The bubble point is a critical threshold. Above it, the system behaves as single-phase (undersaturated) oil. Below it, gas liberates from solution, creating a two-phase system with very different flow characteristics.</p> </li> <li> <p><code>PrimaryPhaseRateControl</code> is the standard way to control production wells. You fix the oil (or gas) rate and let the other phases flow at whatever BHP results from the primary phase. <code>AdaptiveBHPRateControl</code> within it handles the automatic switch from rate to BHP mode as reservoir pressure declines.</p> </li> <li> <p>The <code>reservoir_model()</code> factory computes most PVT properties automatically from correlations. You only need to provide the properties you know; the factory estimates the rest.</p> </li> <li> <p>BORES uses field units: psi for pressure, ft for length, mD for permeability, cP for viscosity, STB/day for oil rates, and degrees Fahrenheit for temperature.</p> </li> </ol>"},{"location":"tutorials/01-first-simulation/#next-steps","title":"Next Steps","text":"<p>In the next tutorial, you will learn how to build more realistic reservoir models with heterogeneous properties, anisotropic permeability, and structural dip. These features are essential for capturing the geological complexity that drives real reservoir behavior.</p>"},{"location":"tutorials/02-building-models/","title":"Building Reservoir Models","text":"<p>Construct realistic reservoir models with heterogeneous properties, anisotropic permeability, structural dip, and 3D visualization.</p>"},{"location":"tutorials/02-building-models/#overview","title":"Overview","text":"<p>In the previous tutorial, you built a homogeneous reservoir with uniform properties everywhere. Real reservoirs are never that simple. Rock properties vary from layer to layer due to depositional history, permeability is typically lower in the vertical direction than horizontal, and the reservoir surface may be tilted (dipping) rather than perfectly flat.</p> <p>This tutorial teaches you how to construct models that capture these geological complexities using BORES's grid-building utilities. You will create layered porosity and permeability distributions, set up anisotropic permeability using <code>RockPermeability</code>, apply structural dip with <code>apply_structural_dip()</code>, and visualize the resulting model in 3D before running any simulation.</p> <p>Building a realistic model is the foundation of any meaningful simulation study. The quality of your results depends directly on how well your model captures the key geological features that control fluid flow. Even when you are working with simplified models for screening studies, understanding how to introduce heterogeneity helps you assess whether your simplifications are reasonable.</p> <p>We will work with a larger 20x20x5 grid to give the layering and dip enough room to be visually apparent.</p>"},{"location":"tutorials/02-building-models/#physical-setup","title":"Physical Setup","text":"<p>Our model represents a layered sandstone reservoir with the following characteristics:</p> <ul> <li>Grid: 20 cells in X, 20 cells in Y, 5 layers in Z (2,000 total cells)</li> <li>Cell size: 50 ft x 50 ft horizontally</li> <li>Layer thicknesses: Varying from 15 ft to 25 ft per layer</li> <li>Porosity: Varies by layer (15% to 25%)</li> <li>Permeability: Varies by layer and direction (anisotropic)</li> <li>Structural dip: 3 degrees toward the east</li> <li>Initial pressure: 3,500 psi</li> <li>Temperature: 200 F</li> </ul>"},{"location":"tutorials/02-building-models/#step-1-layered-property-grids","title":"Step 1 - Layered Property Grids","text":"<p>Real reservoirs are deposited in layers, and each layer can have different rock quality. BORES provides <code>build_layered_grid()</code> to create grids where property values vary along a chosen axis.</p> <pre><code>import bores\nimport numpy as np\n\nbores.use_32bit_precision()\n\ngrid_shape = (20, 20, 5)\ncell_dimension = (50.0, 50.0)  # ft\n\n# Layer thicknesses (5 layers, varying from 15 to 25 ft)\nthickness = bores.build_layered_grid(\n    grid_shape=grid_shape,\n    layer_values=[25.0, 20.0, 15.0, 20.0, 25.0],\n    orientation=\"z\",\n)\n\n# Porosity varies by layer: good sand, tight, moderate, good, excellent\nporosity = bores.build_layered_grid(\n    grid_shape=grid_shape,\n    layer_values=[0.22, 0.15, 0.18, 0.22, 0.25],\n    orientation=\"z\",\n)\n</code></pre> <p>The <code>orientation=\"z\"</code> parameter tells BORES that the layering runs along the vertical (z) axis. The <code>layer_values</code> list must have exactly as many entries as there are cells in that direction - in this case, 5 values for 5 layers. You can also layer along <code>\"x\"</code> or <code>\"y\"</code> for lateral property variations, though vertical layering is the most common geological pattern.</p> <p>Notice how porosity varies from 15% (a tight, cemented zone in layer 2) to 25% (an excellent sand in layer 5). This kind of variation is typical of fluvial or deltaic depositional environments where sand quality changes with the energy of the depositing current.</p> <p>The thickness grid controls how much pore volume each layer contains. Thicker layers with higher porosity dominate the flow behavior because they hold more fluid and transmit it more easily.</p>"},{"location":"tutorials/02-building-models/#step-2-anisotropic-permeability","title":"Step 2 - Anisotropic Permeability","text":"<p>In most sedimentary rocks, horizontal permeability is significantly higher than vertical permeability. This anisotropy arises from the way sediment grains settle and compact. Shale laminae and clay drapes between sand layers further reduce vertical flow.</p> <pre><code># Horizontal permeability varies by layer (mD)\nkx_values = [150.0, 50.0, 80.0, 200.0, 300.0]\nky_values = [150.0, 50.0, 80.0, 200.0, 300.0]\n\n# Vertical permeability is typically 10-20% of horizontal\nkz_values = [15.0, 5.0, 8.0, 20.0, 30.0]\n\nkx_grid = bores.build_layered_grid(\n    grid_shape=grid_shape, layer_values=kx_values, orientation=\"z\"\n)\nky_grid = bores.build_layered_grid(\n    grid_shape=grid_shape, layer_values=ky_values, orientation=\"z\"\n)\nkz_grid = bores.build_layered_grid(\n    grid_shape=grid_shape, layer_values=kz_values, orientation=\"z\"\n)\n\npermeability = bores.RockPermeability(x=kx_grid, y=ky_grid, z=kz_grid)\n</code></pre> <p>The <code>RockPermeability</code> object holds separate permeability grids for each direction. Here, horizontal permeability (kx and ky) ranges from 50 mD in the tight zone to 300 mD in the best sand, while vertical permeability (kz) is set to 10% of horizontal in each layer. This 10:1 anisotropy ratio is a common starting assumption for sandstones, though real ratios can range from 2:1 in clean sands to 1000:1 in thinly laminated sequences.</p> <p>The anisotropy has important implications for fluid flow. Water or gas injected at one location will spread more easily in the horizontal plane than it will migrate vertically between layers. This affects sweep efficiency, breakthrough times, and ultimate recovery.</p> <p>Permeability Anisotropy Ratio</p> <p>The ratio \\(k_v/k_h\\) (vertical-to-horizontal permeability) is one of the most important parameters controlling vertical conformance in reservoir simulation. Common ranges:</p> <ul> <li>Clean, massive sandstone: \\(k_v/k_h\\) = 0.3 - 1.0</li> <li>Laminated sandstone: \\(k_v/k_h\\) = 0.01 - 0.1</li> <li>Layered with shale breaks: \\(k_v/k_h\\) = 0.001 - 0.01</li> </ul>"},{"location":"tutorials/02-building-models/#step-3-remaining-property-grids","title":"Step 3 - Remaining Property Grids","text":"<pre><code># Uniform properties for simplicity\npressure = bores.build_uniform_grid(grid_shape, value=3500.0)       # psi\ntemperature = bores.build_uniform_grid(grid_shape, value=200.0)     # deg F\noil_viscosity = bores.build_uniform_grid(grid_shape, value=1.2)     # cP\nbubble_point = bores.build_uniform_grid(grid_shape, value=2800.0)   # psi\noil_sg = bores.build_uniform_grid(grid_shape, value=0.82)           # ~40 deg API\n\n# Residual saturations\nSorw = bores.build_uniform_grid(grid_shape, value=0.20)\nSorg = bores.build_uniform_grid(grid_shape, value=0.15)\nSgr  = bores.build_uniform_grid(grid_shape, value=0.05)\nSwir = bores.build_uniform_grid(grid_shape, value=0.25)\nSwc  = bores.build_uniform_grid(grid_shape, value=0.25)\n\n# Build initial saturations from fluid contacts\ndepth = bores.build_depth_grid(thickness, datum=5000.0)\n\nSw, So, Sg = bores.build_saturation_grids(\n    depth_grid=depth,\n    gas_oil_contact=4900.0,       # GOC above reservoir (no initial gas cap)\n    oil_water_contact=5120.0,     # OWC below reservoir\n    connate_water_saturation_grid=Swc,\n    residual_oil_saturation_water_grid=Sorw,\n    residual_oil_saturation_gas_grid=Sorg,\n    residual_gas_saturation_grid=Sgr,\n    porosity_grid=porosity,\n)\n</code></pre> <p>For this tutorial, we keep some properties uniform to focus on the model-building aspects. The <code>build_saturation_grids()</code> function computes physically consistent saturations from fluid contact depths, ensuring that \\(S_o + S_w + S_g = 1.0\\) in every cell. Here we place the GOC above the reservoir (no gas cap) and the OWC below, so most cells are in the oil zone with connate water. In a real study, you might also use spatially varying temperature (geothermal gradient) or place the contacts within the reservoir to create initial gas caps or water legs.</p>"},{"location":"tutorials/02-building-models/#step-4-build-the-model-with-structural-dip","title":"Step 4 - Build the Model with Structural Dip","text":"<p>Structural dip means the reservoir surface is tilted relative to horizontal. This tilt creates a gravity component that drives fluids: gas migrates updip (toward higher elevation) while water drains downdip (toward lower elevation). Structural dip is one of the primary mechanisms for gas-oil and oil-water contact movement in real reservoirs.</p> <pre><code>model = bores.reservoir_model(\n    grid_shape=grid_shape,\n    cell_dimension=cell_dimension,\n    thickness_grid=thickness,\n    pressure_grid=pressure,\n    rock_compressibility=3e-6,\n    absolute_permeability=permeability,\n    porosity_grid=porosity,\n    temperature_grid=temperature,\n    water_saturation_grid=Sw,\n    gas_saturation_grid=Sg,\n    oil_saturation_grid=So,\n    oil_viscosity_grid=oil_viscosity,\n    oil_specific_gravity_grid=oil_sg,\n    oil_bubble_point_pressure_grid=bubble_point,\n    residual_oil_saturation_water_grid=Sorw,\n    residual_oil_saturation_gas_grid=Sorg,\n    residual_gas_saturation_grid=Sgr,\n    irreducible_water_saturation_grid=Swir,\n    connate_water_saturation_grid=Swc,\n    dip_angle=3.0,        # 3 degrees from horizontal\n    dip_azimuth=90.0,     # dipping toward East\n)\n</code></pre> <p>The <code>dip_angle</code> parameter specifies the tilt in degrees from horizontal (0 = flat, 90 = vertical). A 3-degree dip is moderate and common in many real reservoirs. The <code>dip_azimuth</code> parameter specifies the direction of dip using compass convention: 0 = North, 90 = East, 180 = South, 270 = West. So <code>dip_azimuth=90.0</code> means the reservoir dips toward the east, with the updip (highest) side on the west.</p> <p>When you later run a simulation with this model, the simulator will account for gravity effects along the dip. Gas will tend to migrate westward (updip) while water will tend to flow eastward (downdip). This has practical implications for well placement: producers are often placed updip to take advantage of gravity drainage, while injectors are placed downdip so that injected fluid sweeps upward through the oil column.</p> <p>Dip and Gravity</p> <p>Structural dip effects are computed using the depth grid and the gravity term in the flow equations. If you set <code>disable_structural_dip=True</code> in the <code>Config</code>, the simulator ignores gravity effects regardless of the dip angle specified in the model. This can be useful for debugging or for studying horizontal flow in isolation.</p>"},{"location":"tutorials/02-building-models/#step-5-visualize-the-model-before-running","title":"Step 5 - Visualize the Model Before Running","text":"<p>One of the most valuable practices in reservoir simulation is inspecting your model visually before running any simulation. This catches errors in property assignments, grid construction, and well placement before they lead to confusing results.</p>"},{"location":"tutorials/02-building-models/#porosity-distribution","title":"Porosity Distribution","text":"<pre><code>viz = bores.plotly3d.DataVisualizer()\n\nfig = viz.make_plot(\n    source=model,\n    property=\"porosity\",\n    plot_type=\"volume\",\n    title=\"Porosity Distribution (Layered)\",\n)\nfig.show()\n</code></pre> <p>You should see five distinct horizontal bands of color corresponding to the five porosity values. The tight zone (layer 2, 15% porosity) should appear as a cooler color band sandwiched between better quality sands.</p>"},{"location":"tutorials/02-building-models/#permeability-distribution","title":"Permeability Distribution","text":"<pre><code>fig = viz.make_plot(\n    source=model,\n    property=\"permeability-x\",\n    plot_type=\"volume\",\n    title=\"Horizontal Permeability (X-direction)\",\n)\nfig.show()\n</code></pre> <p>The permeability visualization reveals the same layered pattern but with a wider range of values - from 50 mD in the tight zone to 300 mD in the best sand. This layered contrast will strongly influence how fluids flow through the reservoir during simulation.</p>"},{"location":"tutorials/02-building-models/#depth-grid-showing-dip","title":"Depth Grid (showing dip)","text":"<pre><code>depth_grid = model.get_depth_grid(apply_dip=True)\nfig = viz.make_plot(\n    source=depth_grid,\n    plot_type=\"volume\",\n    title=\"Depth Grid with 3-Degree Eastward Dip\",\n)\nfig.show()\n</code></pre> <p>The depth grid visualization shows the structural dip clearly. Cells on the western side of the model should be at shallower depth (higher elevation) than cells on the eastern side, reflecting the 3-degree eastward tilt.</p>"},{"location":"tutorials/02-building-models/#step-6-adding-random-heterogeneity","title":"Step 6 - Adding Random Heterogeneity","text":"<p>For more realistic models, you can add random perturbations to the layered base values. This simulates the natural variability within each geological layer.</p> <pre><code>rng = np.random.default_rng(seed=42)\n\n# Start from layered porosity and add +/- 2% random variation\nporosity_heterogeneous = porosity.copy()\nnoise = rng.normal(loc=0.0, scale=0.02, size=grid_shape).astype(np.float32)\nporosity_heterogeneous = np.clip(porosity_heterogeneous + noise, 0.05, 0.35)\n\n# Permeability: log-normal perturbation (more physically realistic)\nkx_heterogeneous = kx_grid.copy()\nlog_noise = rng.normal(loc=0.0, scale=0.3, size=grid_shape).astype(np.float32)\nkx_heterogeneous = kx_heterogeneous * np.exp(log_noise)\nkx_heterogeneous = np.clip(kx_heterogeneous, 1.0, 1000.0)\n</code></pre> <p>Permeability in real rocks follows a log-normal distribution, meaning that the logarithm of permeability is normally distributed. Multiplying by <code>exp(noise)</code> preserves this statistical property. The <code>np.clip()</code> calls ensure values stay within physically reasonable bounds.</p> <p>Reproducible Random Models</p> <p>Always use a seeded random number generator (<code>np.random.default_rng(seed=42)</code>) when building stochastic models. This ensures your results are reproducible across runs, which is essential for debugging, peer review, and comparison studies.</p>"},{"location":"tutorials/02-building-models/#step-7-tips-for-real-world-model-building","title":"Step 7 - Tips for Real-World Model Building","text":"<p>When transitioning from tutorial models to real-world applications, keep these guidelines in mind:</p> <p>Start simple, add complexity incrementally. Begin with a uniform model to verify your simulation runs correctly. Then add layering, then heterogeneity, then structural features. If something breaks, you know which addition caused the problem.</p> <p>Validate property ranges. Before building the model, check that your property values are physically reasonable:</p> Property Typical Range Units Porosity 0.05 - 0.35 fraction Permeability 0.1 - 10,000 mD Rock compressibility 1e-7 - 1e-5 psi\\(^{-1}\\) Oil viscosity 0.2 - 100 cP Oil specific gravity 0.7 - 1.0 dimensionless Temperature 100 - 400 F <p>Mind the saturation constraint. In every cell, \\(S_o + S_w + S_g = 1.0\\). If you build saturation grids from different sources, they may not sum to exactly 1.0. The <code>reservoir_model()</code> factory will normalize them and warn you, but it is better to ensure consistency upfront.</p> <p>Use layered grids for geological layering. The <code>build_layered_grid()</code> function with <code>orientation=\"z\"</code> is the natural way to represent vertical heterogeneity. For lateral variations (facies changes), use <code>orientation=\"x\"</code> or <code>orientation=\"y\"</code>, or build grids from external geological model data.</p>"},{"location":"tutorials/02-building-models/#key-takeaways","title":"Key Takeaways","text":"<ol> <li> <p><code>build_layered_grid()</code> creates grids with property values that vary along a specified axis, which is the natural way to represent geological layering.</p> </li> <li> <p><code>RockPermeability(x=..., y=..., z=...)</code> defines anisotropic permeability, which is essential for realistic vertical flow modeling. Vertical permeability is typically 10-100x lower than horizontal.</p> </li> <li> <p>Structural dip (<code>dip_angle</code> and <code>dip_azimuth</code> in <code>reservoir_model()</code>) introduces gravity-driven flow that affects gas migration, water drainage, and well placement strategy.</p> </li> <li> <p>Always visualize your model using <code>bores.plotly3d.DataVisualizer</code> before running simulations. Visual inspection catches errors that are invisible in the numbers.</p> </li> <li> <p>Log-normal perturbations (multiply by <code>exp(noise)</code>) are more physically realistic for permeability heterogeneity than additive Gaussian noise.</p> </li> </ol>"},{"location":"tutorials/02-building-models/#next-steps","title":"Next Steps","text":"<p>With a realistic heterogeneous model in hand, you are ready to study secondary recovery. In the next tutorial, you will add injection wells to maintain reservoir pressure and sweep oil toward the producers - the fundamental waterflood workflow.</p>"},{"location":"tutorials/03-waterflood/","title":"Waterflood Simulation","text":"<p>Set up a complete waterflood with injection and production wells, track water breakthrough, and analyze oil recovery.</p>"},{"location":"tutorials/03-waterflood/#overview","title":"Overview","text":"<p>Waterflooding is the most widely used secondary recovery technique in the oil industry. By injecting water into the reservoir, you maintain pressure (preventing the decline you saw in the depletion tutorial) and physically displace oil toward the production wells. The key engineering questions are: when does water break through at the producer? How much oil can you recover? How does the water cut evolve over time?</p> <p>In this tutorial, you will set up a waterflood simulation with one injection well and one production well in opposite corners of the grid (a \"corner-to-corner\" pattern). You will track water breakthrough, water cut, oil recovery factor, and pressure maintenance. At the end, you will compare the waterflood results against the depletion case from the first tutorial to quantify the benefit of water injection.</p> <p>Waterflooding works because water is cheap, readily available (especially offshore), and displaces oil reasonably efficiently in many reservoir types. The injected water pushes a saturation front through the reservoir. Ahead of the front, oil saturation is high and water saturation is at connate levels. Behind the front, oil saturation has been reduced to the residual value and water saturation is high. The sharpness and stability of this front depend on the mobility ratio between water and oil.</p>"},{"location":"tutorials/03-waterflood/#physical-setup","title":"Physical Setup","text":"<p>We use a 15x15x3 reservoir with a water injector in corner (0, 0) and an oil producer in the opposite corner (14, 14). Both wells are perforated across all three layers.</p> <ul> <li>Grid: 15x15x3 (675 cells)</li> <li>Cell size: 80 ft x 80 ft, 20 ft thick per layer</li> <li>Porosity: 20%</li> <li>Permeability: 150 mD isotropic</li> <li>Initial pressure: 3,000 psi</li> <li>Oil viscosity: 2.0 cP</li> <li>Injection rate: 400 STB/day water</li> <li>Production rate: 400 STB/day (adaptive BHP control)</li> </ul> <p>Mobility Ratio</p> <p>The mobility ratio \\(M = \\lambda_w / \\lambda_o\\) controls sweep efficiency. Here, water viscosity (~0.5 cP at reservoir conditions) is much lower than oil viscosity (2.0 cP), giving an unfavorable mobility ratio (\\(M &gt; 1\\)). This means the water front will be somewhat unstable, with water tending to finger through the oil rather than pushing it as a clean piston. Higher oil viscosity or lower water mobility would improve this ratio.</p>"},{"location":"tutorials/03-waterflood/#step-1-build-the-reservoir-model","title":"Step 1 - Build the Reservoir Model","text":"<pre><code>import bores\nimport numpy as np\n\nbores.use_32bit_precision()\n\ngrid_shape = (15, 15, 3)\ncell_dimension = (80.0, 80.0)\n\n# Property grids\nthickness = bores.build_uniform_grid(grid_shape, value=20.0)\npressure = bores.build_uniform_grid(grid_shape, value=3000.0)\nporosity = bores.build_uniform_grid(grid_shape, value=0.20)\ntemperature = bores.build_uniform_grid(grid_shape, value=180.0)\noil_viscosity = bores.build_uniform_grid(grid_shape, value=2.0)\nbubble_point = bores.build_uniform_grid(grid_shape, value=2500.0)\noil_sg = bores.build_uniform_grid(grid_shape, value=0.87)\n\nSorw = bores.build_uniform_grid(grid_shape, value=0.22)\nSorg = bores.build_uniform_grid(grid_shape, value=0.15)\nSgr  = bores.build_uniform_grid(grid_shape, value=0.05)\nSwir = bores.build_uniform_grid(grid_shape, value=0.22)\nSwc  = bores.build_uniform_grid(grid_shape, value=0.22)\n\n# Build initial saturations from fluid contacts\ndepth = bores.build_depth_grid(thickness, datum=5000.0)\n\nSw, So, Sg = bores.build_saturation_grids(\n    depth_grid=depth,\n    gas_oil_contact=4900.0,       # GOC above reservoir (no initial gas cap)\n    oil_water_contact=5100.0,     # OWC near reservoir bottom\n    connate_water_saturation_grid=Swc,\n    residual_oil_saturation_water_grid=Sorw,\n    residual_oil_saturation_gas_grid=Sorg,\n    residual_gas_saturation_grid=Sgr,\n    porosity_grid=porosity,\n)\n\nperm_grid = bores.build_uniform_grid(grid_shape, value=150.0)\npermeability = bores.RockPermeability(x=perm_grid)\n\nmodel = bores.reservoir_model(\n    grid_shape=grid_shape,\n    cell_dimension=cell_dimension,\n    thickness_grid=thickness,\n    pressure_grid=pressure,\n    rock_compressibility=3e-6,\n    absolute_permeability=permeability,\n    porosity_grid=porosity,\n    temperature_grid=temperature,\n    water_saturation_grid=Sw,\n    gas_saturation_grid=Sg,\n    oil_saturation_grid=So,\n    oil_viscosity_grid=oil_viscosity,\n    oil_specific_gravity_grid=oil_sg,\n    oil_bubble_point_pressure_grid=bubble_point,\n    residual_oil_saturation_water_grid=Sorw,\n    residual_oil_saturation_gas_grid=Sorg,\n    residual_gas_saturation_grid=Sgr,\n    irreducible_water_saturation_grid=Swir,\n    connate_water_saturation_grid=Swc,\n)\n</code></pre> <p>The setup is similar to the first tutorial with a few differences. The oil viscosity is slightly higher (2.0 cP) to make the displacement dynamics more interesting. The residual oil saturation during waterflood (Sorw = 0.22) determines the maximum oil recovery: in the swept zone, oil saturation will drop to 22%, meaning up to 78% of the pore volume in the swept region is eventually occupied by water.</p> <p>We use <code>build_saturation_grids()</code> to compute physically consistent initial saturations from the fluid contact depths. The GOC is placed above the reservoir (no gas cap) and the OWC near the bottom, giving us an oil-filled reservoir with connate water. This approach ensures \\(S_o + S_w + S_g = 1.0\\) in every cell and uses the correct residual saturations for each zone.</p> <p>Note that we pass only the x-direction permeability to <code>RockPermeability</code>. BORES automatically copies it to y and z, giving us isotropic permeability with less code.</p>"},{"location":"tutorials/03-waterflood/#step-2-define-the-injection-well","title":"Step 2 - Define the Injection Well","text":"<pre><code>injector = bores.injection_well(\n    well_name=\"INJ-1\",\n    perforating_intervals=[((0, 0, 0), (0, 0, 2))],\n    radius=0.25,\n    control=bores.ConstantRateControl(target_rate=400.0),\n    injected_fluid=bores.InjectedFluid(\n        name=\"Water\",\n        phase=bores.FluidPhase.WATER,\n        specific_gravity=1.0,\n        molecular_weight=18.015,\n    ),\n)\n</code></pre> <p>The injection well is placed at grid corner (0, 0) and perforated from layer 0 to layer 2. The <code>ConstantRateControl</code> with <code>target_rate=400.0</code> (positive = injection) injects water at a constant 400 STB/day. We do not set a BHP limit on the injector in this example, though in practice you would want to limit injection pressure to avoid fracturing the formation.</p> <p>The <code>InjectedFluid</code> specifies that we are injecting water with standard properties. BORES uses the specific gravity and molecular weight to compute water density and viscosity at reservoir conditions using its internal correlations.</p> <p>Matching Injection and Production Rates</p> <p>In a voidage-replacement waterflood, you typically match the volumetric injection rate to the volumetric production rate. This maintains reservoir pressure at approximately the initial level. If injection exceeds production, pressure rises. If production exceeds injection, pressure declines despite the water support.</p>"},{"location":"tutorials/03-waterflood/#step-3-define-the-production-well","title":"Step 3 - Define the Production Well","text":"<pre><code>producer = bores.production_well(\n    well_name=\"PROD-1\",\n    perforating_intervals=[((14, 14, 0), (14, 14, 2))],\n    radius=0.25,\n    control=bores.PrimaryPhaseRateControl(\n        primary_phase=bores.FluidPhase.OIL,\n        primary_control=bores.AdaptiveBHPRateControl(\n            target_rate=-400.0,\n            target_phase=\"oil\",\n            bhp_limit=800.0,\n        ),\n        secondary_clamp=bores.ProductionClamp(),\n    ),\n    produced_fluids=[\n        bores.ProducedFluid(\n            name=\"Oil\", phase=bores.FluidPhase.OIL,\n            specific_gravity=0.87, molecular_weight=200.0,\n        ),\n        bores.ProducedFluid(\n            name=\"Water\", phase=bores.FluidPhase.WATER,\n            specific_gravity=1.0, molecular_weight=18.015,\n        ),\n    ],\n)\n</code></pre> <p>The producer sits in the opposite corner at (14, 14). We use <code>PrimaryPhaseRateControl</code> with oil as the primary phase and a target rate of -400 STB/day. The simulator computes the BHP needed to deliver that oil rate, and water flows naturally at whatever rate corresponds to that BHP. The <code>bhp_limit=800.0</code> prevents the BHP from dropping below 800 psi. The <code>ProductionClamp</code> prevents any accidental backflow of water into the reservoir.</p> <p>Notice that the <code>produced_fluids</code> list includes both oil and water. Before water breakthrough, the producer will mainly produce oil. After breakthrough, an increasing fraction of the produced fluid will be water. Because we use <code>PrimaryPhaseRateControl</code>, the oil rate stays at the target while the water rate grows with increasing water cut.</p>"},{"location":"tutorials/03-waterflood/#step-4-group-wells-and-configure","title":"Step 4 - Group Wells and Configure","text":"<pre><code>wells = bores.wells_(injectors=[injector], producers=[producer])\n\nrock_fluid = bores.RockFluidTables(\n    relative_permeability_table=bores.BrooksCoreyThreePhaseRelPermModel(\n        water_exponent=2.5,\n        oil_exponent=2.0,\n        gas_exponent=2.0,\n    ),\n    capillary_pressure_table=bores.BrooksCoreyCapillaryPressureModel(),\n)\n\nconfig = bores.Config(\n    timer=bores.Timer(\n        initial_step_size=bores.Time(days=1),\n        max_step_size=bores.Time(days=10),\n        min_step_size=bores.Time(hours=1),\n        simulation_time=bores.Time(days=1095),  # 3 years\n    ),\n    rock_fluid_tables=rock_fluid,\n    wells=wells,\n    scheme=\"impes\",\n)\n</code></pre> <p>We set the water Corey exponent to 2.5 (slightly higher than oil's 2.0), which makes the water relative permeability curve steeper. This is physically reasonable because water in a water-wet rock needs to occupy more pore space before it can flow efficiently.</p> <p>The simulation runs for 3 years (1,095 days), which is enough time to observe water breakthrough, the transition to high water cut, and the plateau in recovery factor.</p>"},{"location":"tutorials/03-waterflood/#step-5-run-the-simulation","title":"Step 5 - Run the Simulation","text":"<pre><code>states = list(bores.run(model, config))\nfinal = states[-1]\nprint(f\"Completed {final.step} steps in {final.time_in_days:.1f} days\")\n</code></pre>"},{"location":"tutorials/03-waterflood/#step-6-analyze-water-breakthrough","title":"Step 6 - Analyze Water Breakthrough","text":"<p>Water breakthrough is the moment when injected water first arrives at the production well. Before breakthrough, the producer makes essentially dry oil. After breakthrough, water cut increases rapidly.</p> <pre><code>time_days = np.array([s.time_in_days for s in states])\n\n# Water saturation at the producer location (14, 14, center layer)\nSw_at_producer = np.array([\n    s.model.fluid_properties.water_saturation_grid[14, 14, 1] for s in states\n])\n\n# Detect breakthrough: first time Sw exceeds initial connate value significantly\nbreakthrough_mask = Sw_at_producer &gt; 0.30\nif np.any(breakthrough_mask):\n    bt_index = np.argmax(breakthrough_mask)\n    print(f\"Water breakthrough at approximately {time_days[bt_index]:.0f} days\")\nelse:\n    print(\"Water has not broken through during the simulation period\")\n</code></pre> <p>The timing of breakthrough depends on the distance between injector and producer, the injection rate, the pore volume between them, and the mobility ratio. In an ideal piston-like displacement, breakthrough would occur when one pore volume of water has been injected. In reality, the unfavorable mobility ratio causes early breakthrough because water fingers through the oil.</p>"},{"location":"tutorials/03-waterflood/#step-7-plot-water-cut-and-recovery","title":"Step 7 - Plot Water Cut and Recovery","text":"<pre><code># Average saturations over time\navg_So = np.array([\n    s.model.fluid_properties.oil_saturation_grid.mean() for s in states\n])\navg_Sw = np.array([\n    s.model.fluid_properties.water_saturation_grid.mean() for s in states\n])\n\n# Water cut: fraction of total production that is water\n# Approximate using average saturation change\ninitial_So = 0.75\noil_recovered_fraction = (initial_So - avg_So) / (initial_So - 0.22)  # Normalize by movable oil\n\nfig = bores.make_series_plot(\n    data={\n        \"Oil Saturation\": np.column_stack([time_days, avg_So]),\n        \"Water Saturation\": np.column_stack([time_days, avg_Sw]),\n    },\n    title=\"Average Saturations During Waterflood\",\n    x_label=\"Time (days)\",\n    y_label=\"Saturation (fraction)\",\n)\nfig.show()\n</code></pre> <p>You should see water saturation gradually increasing from the initial connate value (0.25) as the flood front progresses through the reservoir. Oil saturation decreases correspondingly. After breakthrough, the rate of change accelerates because water is now taking a shortcut through the swept zone to the producer.</p>"},{"location":"tutorials/03-waterflood/#recovery-factor","title":"Recovery Factor","text":"<pre><code>fig = bores.make_series_plot(\n    data=np.column_stack([time_days, oil_recovered_fraction]),\n    title=\"Oil Recovery Factor (Waterflood)\",\n    x_label=\"Time (days)\",\n    y_label=\"Recovery Factor (fraction)\",\n)\nfig.show()\n</code></pre> <p>The recovery factor curve is the primary metric for evaluating a waterflood. You should see rapid initial recovery as the flood front sweeps through the reservoir, a change in slope around breakthrough time (when water starts being produced instead of displacing oil), and a gradual approach toward the ultimate recovery limit.</p>"},{"location":"tutorials/03-waterflood/#step-8-pressure-maintenance","title":"Step 8 - Pressure Maintenance","text":"<pre><code>avg_pressure = np.array([\n    s.model.fluid_properties.pressure_grid.mean() for s in states\n])\n\nfig = bores.make_series_plot(\n    data=np.column_stack([time_days, avg_pressure]),\n    title=\"Average Reservoir Pressure (Waterflood)\",\n    x_label=\"Time (days)\",\n    y_label=\"Pressure (psi)\",\n)\nfig.show()\n</code></pre> <p>Unlike the depletion case from Tutorial 1, where pressure declined continuously, the waterflood should maintain pressure close to the initial value (3,000 psi) because the injected water replaces the produced fluid volume. You may see slight pressure fluctuations as the flood front moves through the reservoir and the simulator adjusts well rates.</p> <p>Pressure vs Depletion</p> <p>Compare this pressure plot with the depletion result from Your First Simulation. The difference is dramatic: waterflooding maintains pressure near the initial value, while depletion allows continuous decline. This pressure support is the primary benefit of waterflooding, enabling higher production rates for longer periods.</p>"},{"location":"tutorials/03-waterflood/#step-9-visualize-the-water-front","title":"Step 9 - Visualize the Water Front","text":"<pre><code>viz = bores.plotly3d.DataVisualizer()\n\n# Visualize water saturation at a few time steps\nfor state in [states[len(states) // 4], states[len(states) // 2], states[-1]]:\n    fig = viz.make_plot(\n        source=state,\n        property=\"water-saturation\",\n        plot_type=\"volume\",\n        title=f\"Water Saturation at Day {state.time_in_days:.0f}\",\n    )\n    fig.show()\n</code></pre> <p>These 3D visualizations show the water saturation front advancing from the injector corner (0, 0) toward the producer corner (14, 14). You should observe the front spreading diagonally across the reservoir. The front may not be perfectly sharp due to numerical dispersion and the unfavorable mobility ratio.</p>"},{"location":"tutorials/03-waterflood/#discussion","title":"Discussion","text":"<p>The waterflood results illustrate several important principles of secondary recovery. First, water injection dramatically improves recovery compared to primary depletion. The depletion case from Tutorial 1 recovered oil only through pressure decline and solution gas drive, while the waterflood physically displaces oil by pushing it toward the producer.</p> <p>Second, the timing and sharpness of water breakthrough depend on the mobility ratio. With our oil viscosity of 2.0 cP and water viscosity around 0.5 cP, the mobility ratio is approximately 4:1 (unfavorable). This means water moves about 4 times faster than oil at the same saturation, leading to early breakthrough and a gradual increase in water cut rather than a sharp transition.</p> <p>Third, pressure maintenance is a major advantage of waterflooding. By keeping reservoir pressure above the bubble point, we avoid the complications of free gas (gas coning, reduced oil mobility) that plague depletion operations. This is why waterflooding is typically initiated early in field life, before significant pressure decline.</p>"},{"location":"tutorials/03-waterflood/#key-takeaways","title":"Key Takeaways","text":"<ol> <li> <p>Water injection maintains reservoir pressure and displaces oil, yielding significantly higher recovery than primary depletion.</p> </li> <li> <p><code>InjectedFluid</code> with <code>phase=FluidPhase.WATER</code> configures a water injection well. The positive <code>target_rate</code> follows BORES's sign convention (positive = injection).</p> </li> <li> <p>Water breakthrough occurs when injected water first reaches the producer. After breakthrough, water cut increases and oil production rate declines.</p> </li> <li> <p>Mobility ratio (\\(M = \\lambda_w / \\lambda_o\\)) controls sweep efficiency. Higher oil viscosity or lower Corey exponents for water improve the displacement.</p> </li> <li> <p>3D visualization of the saturation front helps you understand how the flood progresses through the reservoir and identify sweep inefficiencies.</p> </li> </ol>"},{"location":"tutorials/03-waterflood/#next-steps","title":"Next Steps","text":"<p>In the next tutorial, you will replace the water injector with a gas injector and observe how gas injection differs from waterflooding: gravity override, higher gas mobility, and different displacement characteristics.</p>"},{"location":"tutorials/04-gas-injection/","title":"Gas Injection","text":"<p>Simulate immiscible gas injection, observe gravity override effects, and compare gas flood recovery against waterflooding.</p>"},{"location":"tutorials/04-gas-injection/#overview","title":"Overview","text":"<p>Gas injection is an alternative to waterflooding for reservoirs where water is scarce, where the oil is too viscous for efficient water displacement, or where associated gas needs to be reinjected. In this tutorial, you will set up an immiscible gas injection simulation, observe the characteristic gravity override phenomenon, and compare the results against the waterflood from the previous tutorial.</p> <p>Immiscible gas injection means the injected gas does not mix with the oil at the molecular level. Instead, the gas forms a separate phase that displaces oil by pushing it ahead of the gas front. The key challenge is that gas is much lighter than oil and much less viscous, creating two problems: gravity override (gas rises to the top of the reservoir and bypasses oil below) and viscous fingering (the highly mobile gas front is unstable and fingers through the oil).</p> <p>Understanding these challenges is essential before moving to the next tutorial on miscible flooding, where the gas actually mixes with oil to eliminate interfacial tension and achieve much higher displacement efficiency.</p> <p>We use the same 15x15x3 grid from the waterflood tutorial so you can make a direct comparison between the two recovery methods.</p>"},{"location":"tutorials/04-gas-injection/#physical-setup","title":"Physical Setup","text":"<p>The reservoir is identical to the waterflood tutorial, but the injection fluid changes from water to gas:</p> <ul> <li>Grid: 15x15x3 (675 cells)</li> <li>Cell size: 80 ft x 80 ft, 20 ft thick per layer</li> <li>Permeability: 150 mD isotropic</li> <li>Initial pressure: 3,000 psi</li> <li>Oil viscosity: 2.0 cP</li> <li>Gas injector: Corner (0, 0), 2,000 MSCF/day</li> <li>Oil producer: Corner (14, 14), adaptive BHP control</li> </ul> <p>Gas Mobility</p> <p>Gas viscosity at reservoir conditions is typically 0.01-0.03 cP, compared to 0.5-1.0 cP for water and 1-5 cP for oil. This extreme mobility difference (gas is 50-200 times more mobile than oil) means gas injection has a very unfavorable mobility ratio. Without gravity trapping, structural dip benefits, or miscibility, gas floods tend to have lower sweep efficiency than waterfloods.</p>"},{"location":"tutorials/04-gas-injection/#step-1-build-the-reservoir-model","title":"Step 1 - Build the Reservoir Model","text":"<pre><code>import bores\nimport numpy as np\n\nbores.use_32bit_precision()\n\ngrid_shape = (15, 15, 3)\ncell_dimension = (80.0, 80.0)\n\nthickness = bores.build_uniform_grid(grid_shape, value=20.0)\npressure = bores.build_uniform_grid(grid_shape, value=3000.0)\nporosity = bores.build_uniform_grid(grid_shape, value=0.20)\ntemperature = bores.build_uniform_grid(grid_shape, value=180.0)\noil_viscosity = bores.build_uniform_grid(grid_shape, value=2.0)\nbubble_point = bores.build_uniform_grid(grid_shape, value=2500.0)\noil_sg = bores.build_uniform_grid(grid_shape, value=0.87)\n\nSorw = bores.build_uniform_grid(grid_shape, value=0.22)\nSorg = bores.build_uniform_grid(grid_shape, value=0.15)\nSgr  = bores.build_uniform_grid(grid_shape, value=0.05)\nSwir = bores.build_uniform_grid(grid_shape, value=0.22)\nSwc  = bores.build_uniform_grid(grid_shape, value=0.22)\n\n# Build initial saturations from fluid contacts\ndepth = bores.build_depth_grid(thickness, datum=5000.0)\n\nSw, So, Sg = bores.build_saturation_grids(\n    depth_grid=depth,\n    gas_oil_contact=4900.0,       # GOC above reservoir (no initial gas cap)\n    oil_water_contact=5100.0,     # OWC near reservoir bottom\n    connate_water_saturation_grid=Swc,\n    residual_oil_saturation_water_grid=Sorw,\n    residual_oil_saturation_gas_grid=Sorg,\n    residual_gas_saturation_grid=Sgr,\n    porosity_grid=porosity,\n)\n\nperm_grid = bores.build_uniform_grid(grid_shape, value=150.0)\npermeability = bores.RockPermeability(x=perm_grid)\n\nmodel = bores.reservoir_model(\n    grid_shape=grid_shape,\n    cell_dimension=cell_dimension,\n    thickness_grid=thickness,\n    pressure_grid=pressure,\n    rock_compressibility=3e-6,\n    absolute_permeability=permeability,\n    porosity_grid=porosity,\n    temperature_grid=temperature,\n    water_saturation_grid=Sw,\n    gas_saturation_grid=Sg,\n    oil_saturation_grid=So,\n    oil_viscosity_grid=oil_viscosity,\n    oil_specific_gravity_grid=oil_sg,\n    oil_bubble_point_pressure_grid=bubble_point,\n    residual_oil_saturation_water_grid=Sorw,\n    residual_oil_saturation_gas_grid=Sorg,\n    residual_gas_saturation_grid=Sgr,\n    irreducible_water_saturation_grid=Swir,\n    connate_water_saturation_grid=Swc,\n)\n</code></pre> <p>The model is intentionally identical to the waterflood tutorial. Using the same reservoir lets you make a clean comparison between the two injection strategies with no confounding geological differences.</p>"},{"location":"tutorials/04-gas-injection/#step-2-define-the-gas-injection-well","title":"Step 2 - Define the Gas Injection Well","text":"<pre><code>gas_injector = bores.injection_well(\n    well_name=\"GAS-INJ-1\",\n    perforating_intervals=[((0, 0, 0), (0, 0, 2))],\n    radius=0.25,\n    control=bores.ConstantRateControl(target_rate=500.0),\n    injected_fluid=bores.InjectedFluid(\n        name=\"Methane\",\n        phase=bores.FluidPhase.GAS,\n        specific_gravity=0.65,\n        molecular_weight=16.04,\n    ),\n)\n</code></pre> <p>The key difference from the waterflood is the <code>InjectedFluid</code> configuration. Here we inject gas (<code>phase=FluidPhase.GAS</code>) with a specific gravity of 0.65, which is typical for methane-rich natural gas. The molecular weight of 16.04 g/mol corresponds to pure methane.</p> <p>The <code>target_rate=500.0</code> is in reservoir volume units (RB/day for gas at reservoir conditions). BORES uses the gas formation volume factor to convert between surface and reservoir volumes internally.</p> <p>Notice that we do not set <code>is_miscible=True</code>. By default, <code>InjectedFluid</code> creates an immiscible gas - the gas and oil remain as separate phases with a clear interface between them. Miscible injection, where the gas dissolves into and mixes with the oil, is covered in the next tutorial.</p> <p>Gas Specific Gravity</p> <p>The specific gravity of a gas is relative to air (air = 1.0). Common injection gases:</p> <ul> <li>Methane (CH4): 0.554</li> <li>Natural gas: 0.6 - 0.8</li> <li>CO2: 1.52</li> <li>Nitrogen (N2): 0.967</li> </ul> <p>Lighter gases (lower specific gravity) have stronger gravity override tendencies. CO2 is denser than methane and therefore shows less gravity segregation.</p>"},{"location":"tutorials/04-gas-injection/#step-3-define-the-producer-and-configure","title":"Step 3 - Define the Producer and Configure","text":"<pre><code>producer = bores.production_well(\n    well_name=\"PROD-1\",\n    perforating_intervals=[((14, 14, 0), (14, 14, 2))],\n    radius=0.25,\n    control=bores.PrimaryPhaseRateControl(\n        primary_phase=bores.FluidPhase.OIL,\n        primary_control=bores.AdaptiveBHPRateControl(\n            target_rate=-400.0,\n            target_phase=\"oil\",\n            bhp_limit=800.0,\n        ),\n        secondary_clamp=bores.ProductionClamp(),\n    ),\n    produced_fluids=[\n        bores.ProducedFluid(\n            name=\"Oil\", phase=bores.FluidPhase.OIL,\n            specific_gravity=0.87, molecular_weight=200.0,\n        ),\n        bores.ProducedFluid(\n            name=\"Water\", phase=bores.FluidPhase.WATER,\n            specific_gravity=1.0, molecular_weight=18.015,\n        ),\n        bores.ProducedFluid(\n            name=\"Gas\", phase=bores.FluidPhase.GAS,\n            specific_gravity=0.65, molecular_weight=16.04,\n        ),\n    ],\n)\n\nwells = bores.wells_(injectors=[gas_injector], producers=[producer])\n\nrock_fluid = bores.RockFluidTables(\n    relative_permeability_table=bores.BrooksCoreyThreePhaseRelPermModel(\n        water_exponent=2.5,\n        oil_exponent=2.0,\n        gas_exponent=2.0,\n    ),\n    capillary_pressure_table=bores.BrooksCoreyCapillaryPressureModel(),\n)\n\nconfig = bores.Config(\n    timer=bores.Timer(\n        initial_step_size=bores.Time(days=0.5),\n        max_step_size=bores.Time(days=5),\n        min_step_size=bores.Time(hours=0.5),\n        simulation_time=bores.Time(days=1095),  # 3 years\n    ),\n    rock_fluid_tables=rock_fluid,\n    wells=wells,\n    scheme=\"impes\",\n)\n</code></pre> <p>There are two important differences in the timer configuration compared to the waterflood. The initial step size is smaller (0.5 days vs 1 day) and the maximum step size is reduced (5 days vs 10 days). This is because gas injection creates sharper saturation fronts and higher flow velocities that require smaller time steps for numerical stability.</p> <p>Gas is much more compressible and mobile than water, so the pressure and saturation equations change more rapidly near the gas front. The adaptive timer will manage this automatically, but starting with smaller steps reduces the number of rejected steps during the early, most dynamic phase of the flood.</p> <p>Time Step Management for Gas Injection</p> <p>If you encounter convergence issues during gas injection, try:</p> <ol> <li>Reducing <code>initial_step_size</code> to <code>Time(hours=6)</code> or smaller</li> <li>Reducing <code>max_step_size</code> to <code>Time(days=3)</code></li> <li>Increasing the gas Corey exponent (e.g., 3.0) to smooth the gas relative permeability curve</li> <li>These adjustments help the solver handle the high-mobility gas front</li> </ol>"},{"location":"tutorials/04-gas-injection/#step-4-run-the-simulation","title":"Step 4 - Run the Simulation","text":"<pre><code>states = list(bores.run(model, config))\nfinal = states[-1]\nprint(f\"Completed {final.step} steps in {final.time_in_days:.1f} days\")\nprint(f\"Final avg pressure: {final.model.fluid_properties.pressure_grid.mean():.1f} psi\")\nprint(f\"Final avg gas saturation: {final.model.fluid_properties.gas_saturation_grid.mean():.4f}\")\n</code></pre>"},{"location":"tutorials/04-gas-injection/#step-5-observe-gravity-override","title":"Step 5 - Observe Gravity Override","text":"<p>Gravity override is the dominant feature of immiscible gas injection. Because gas is lighter than oil, it tends to rise to the top of the reservoir and flow along the upper layers, bypassing oil in the lower layers.</p> <pre><code># Gas saturation in top layer vs bottom layer over time\ntime_days = np.array([s.time_in_days for s in states])\navg_Sg_top = np.array([\n    s.model.fluid_properties.gas_saturation_grid[:, :, 0].mean() for s in states\n])\navg_Sg_bottom = np.array([\n    s.model.fluid_properties.gas_saturation_grid[:, :, 2].mean() for s in states\n])\n\nfig = bores.make_series_plot(\n    data={\n        \"Gas Saturation (Top Layer)\": np.column_stack([time_days, avg_Sg_top]),\n        \"Gas Saturation (Bottom Layer)\": np.column_stack([time_days, avg_Sg_bottom]),\n    },\n    title=\"Gas Saturation by Layer - Gravity Override\",\n    x_label=\"Time (days)\",\n    y_label=\"Gas Saturation (fraction)\",\n)\nfig.show()\n</code></pre> <p>You should see gas saturation increasing much faster in the top layer than in the bottom layer. This is gravity override in action. The gas preferentially flows through the upper part of the reservoir, leaving significant unswept oil in the lower layers.</p>"},{"location":"tutorials/04-gas-injection/#visualize-the-gas-front-in-3d","title":"Visualize the Gas Front in 3D","text":"<pre><code>viz = bores.plotly3d.DataVisualizer()\n\nfig = viz.make_plot(\n    source=states[len(states) // 2],\n    property=\"gas-saturation\",\n    plot_type=\"volume\",\n    title=f\"Gas Saturation at Day {states[len(states) // 2].time_in_days:.0f}\",\n)\nfig.show()\n</code></pre> <p>The 3D visualization makes the gravity override visually obvious. You should see high gas saturation concentrated in the top layer, with much less gas penetration into the lower layers. This non-uniform sweep pattern is the primary limitation of immiscible gas injection in reservoirs without significant structural dip.</p>"},{"location":"tutorials/04-gas-injection/#step-6-compare-gas-flood-vs-waterflood-recovery","title":"Step 6 - Compare Gas Flood vs Waterflood Recovery","text":"<pre><code>avg_So = np.array([\n    s.model.fluid_properties.oil_saturation_grid.mean() for s in states\n])\n\ninitial_So = 0.75\nSor_gas = 0.15  # Residual oil to gas\nrecovery_factor = (initial_So - avg_So) / (initial_So - Sor_gas)\n\nfig = bores.make_series_plot(\n    data=np.column_stack([time_days, recovery_factor]),\n    title=\"Oil Recovery Factor (Gas Injection)\",\n    x_label=\"Time (days)\",\n    y_label=\"Recovery Factor (fraction)\",\n)\nfig.show()\n</code></pre> <p>Compare this recovery curve with the waterflood result from the previous tutorial. In most cases, the gas flood will show:</p> <ol> <li>Earlier breakthrough because gas moves much faster through the reservoir</li> <li>Lower ultimate recovery because gravity override leaves unswept oil in lower layers</li> <li>Different curve shape with a steeper initial rise but earlier flattening</li> </ol> <p>The residual oil saturation to gas (Sorg = 0.15) is actually lower than to water (Sorw = 0.22), meaning gas can displace oil more efficiently at the microscopic (pore) level. But the macroscopic sweep efficiency is worse due to gravity override and viscous fingering, so the overall recovery is often lower.</p>"},{"location":"tutorials/04-gas-injection/#step-7-pressure-response","title":"Step 7 - Pressure Response","text":"<pre><code>avg_pressure = np.array([\n    s.model.fluid_properties.pressure_grid.mean() for s in states\n])\n\nfig = bores.make_series_plot(\n    data=np.column_stack([time_days, avg_pressure]),\n    title=\"Average Reservoir Pressure (Gas Injection)\",\n    x_label=\"Time (days)\",\n    y_label=\"Pressure (psi)\",\n)\nfig.show()\n</code></pre> <p>Gas injection provides some pressure maintenance, but the response differs from waterflooding. Gas is highly compressible, so a large volume of gas at surface conditions translates to a relatively small volume at reservoir conditions. The pressure support from gas injection is typically less effective than from water injection at the same surface injection rate.</p>"},{"location":"tutorials/04-gas-injection/#discussion","title":"Discussion","text":"<p>The gas injection results highlight the fundamental trade-off of gas flooding. At the pore scale, gas is an excellent displacement agent - it can reduce oil saturation below what water achieves (Sorg &lt; Sorw). But at the reservoir scale, the extreme mobility contrast and density difference between gas and oil lead to poor sweep efficiency through gravity override and viscous fingering.</p> <p>This is why gas injection is often most effective in reservoirs with significant structural dip (where gravity helps push gas updip through the oil column), in thin reservoirs (where there is less room for gravity segregation), or when the gas is injected at conditions that achieve miscibility with the oil (eliminating the interfacial tension that causes trapping).</p> <p>In real field operations, operators often use WAG (Water Alternating Gas) injection to combine the microscopic displacement efficiency of gas with the better sweep efficiency of water. The water slugs control the gas mobility and reduce gravity override, while the gas slugs provide superior pore-level displacement.</p>"},{"location":"tutorials/04-gas-injection/#key-takeaways","title":"Key Takeaways","text":"<ol> <li> <p>Gas injection uses <code>InjectedFluid</code> with <code>phase=FluidPhase.GAS</code> and appropriate gas properties (specific gravity, molecular weight).</p> </li> <li> <p>Gravity override is the dominant challenge: gas rises to the top of the reservoir, bypassing oil in lower layers and reducing sweep efficiency.</p> </li> <li> <p>Smaller time steps are needed for gas injection (compared to waterflooding) because gas fronts are sharper and gas is more compressible.</p> </li> <li> <p>Pore-level displacement by gas is efficient (low Sorg), but macroscopic sweep is poor due to unfavorable mobility ratio and density contrast.</p> </li> <li> <p>Comparison with waterflooding shows that immiscible gas injection typically achieves earlier breakthrough and lower ultimate recovery in flat, thick reservoirs.</p> </li> </ol>"},{"location":"tutorials/04-gas-injection/#next-steps","title":"Next Steps","text":"<p>In the next tutorial, you will learn how to make gas injection dramatically more effective by achieving miscibility between the injected gas and the reservoir oil. The Todd-Longstaff model in BORES enables you to simulate miscible displacement where the gas-oil interfacial tension vanishes, eliminating residual oil trapping in the swept zone.</p>"},{"location":"tutorials/05-miscible-flooding/","title":"Miscible Gas Flooding","text":"<p>Model miscible displacement using the Todd-Longstaff method, configure CO2 injection with custom fluid properties, and analyze solvent mixing behavior.</p>"},{"location":"tutorials/05-miscible-flooding/#overview","title":"Overview","text":"<p>In the previous tutorial, you saw that immiscible gas injection suffers from gravity override and poor sweep efficiency. Miscible gas injection overcomes many of these limitations by creating conditions where the injected gas dissolves into and mixes with the reservoir oil at the molecular level. When miscibility is achieved, the interfacial tension between gas and oil vanishes, residual oil trapping is eliminated, and the displacement efficiency approaches 100% in the swept zone.</p> <p>This tutorial introduces the Todd-Longstaff miscible displacement model, which is the industry-standard approach for simulating miscible flooding in black-oil simulators. You will configure CO2 injection with custom density and viscosity properties, run a miscible flood, visualize solvent concentration evolution, and study the sensitivity of the mixing parameter (omega).</p> <p>Miscible flooding is one of the most effective enhanced oil recovery (EOR) techniques, particularly for CO2 injection in light to medium oil reservoirs. Understanding how to set up and interpret miscible simulations is essential for evaluating EOR potential.</p>"},{"location":"tutorials/05-miscible-flooding/#the-todd-longstaff-model","title":"The Todd-Longstaff Model","text":"<p>The Todd-Longstaff model is a practical engineering approach to miscible displacement that avoids the computational cost of full compositional simulation. It works by modifying the effective viscosity and density of the oil phase based on how much solvent has mixed into it. The model uses a single mixing parameter, \\(\\omega\\) (omega), that controls the degree of mixing between the injected solvent and the reservoir oil.</p> <p>The effective viscosity is computed as:</p> \\[\\mu_{\\text{eff}} = \\mu_{\\text{mix}}^{\\omega} \\cdot \\mu_{\\text{seg}}^{1-\\omega}\\] <p>where \\(\\mu_{\\text{mix}}\\) is the fully-mixed viscosity (computed from oil and solvent viscosities), \\(\\mu_{\\text{seg}}\\) is the segregated (unmixed) viscosity, and \\(\\omega\\) ranges from 0 to 1. When \\(\\omega = 1\\), the fluids are perfectly mixed within each grid cell. When \\(\\omega = 0\\), the fluids are completely segregated and behave as two distinct phases despite being in the same grid cell.</p> <p>The density follows the same form:</p> \\[\\rho_{\\text{eff}} = \\rho_{\\text{mix}}^{\\omega} \\cdot \\rho_{\\text{seg}}^{1-\\omega}\\] <p>In practice, \\(\\omega\\) typically ranges from 0.5 to 0.8 for most reservoir applications. A value of \u2154 (0.667) is the most common default. The choice of \\(\\omega\\) depends on grid resolution: coarse grids need lower \\(\\omega\\) values to account for unresolved sub-grid mixing, while fine grids can use higher values because more of the physical mixing is resolved by the grid itself.</p> <p>The model also accounts for pressure-dependent miscibility using the minimum miscibility pressure (MMP). Below the MMP, the displacement is immiscible. Above the MMP, full miscibility is achieved. BORES uses a smooth hyperbolic tangent transition between these regimes, controlled by the <code>miscibility_transition_width</code> parameter.</p>"},{"location":"tutorials/05-miscible-flooding/#physical-setup","title":"Physical Setup","text":"<p>We use the same 15x15x3 grid for consistency, but now inject CO2 with miscible properties:</p> <ul> <li>Grid: 15x15x3 (675 cells)</li> <li>Initial pressure: 3,000 psi (above MMP)</li> <li>CO2 injector: Corner (0, 0)</li> <li>MMP: 1,800 psi</li> <li>Todd-Longstaff omega: 0.67</li> <li>CO2 density: 35.0 lbm/ft3 (at reservoir conditions)</li> <li>CO2 viscosity: 0.05 cP (at reservoir conditions)</li> </ul> <p>Minimum Miscibility Pressure (MMP)</p> <p>The MMP is the lowest pressure at which the injected gas achieves miscibility with the reservoir oil. Below this pressure, a gas-oil interface exists and trapping occurs. Above it, the fluids become fully miscible and can mix in all proportions. The MMP depends on oil composition, gas composition, and temperature. For CO2 injection:</p> <ul> <li>Light oils (35-45 API): MMP = 1,200 - 2,500 psi</li> <li>Medium oils (25-35 API): MMP = 2,000 - 3,500 psi</li> <li>Heavy oils (&lt; 25 API): MMP &gt; 3,500 psi (often impractical)</li> </ul>"},{"location":"tutorials/05-miscible-flooding/#step-1-build-the-reservoir-model","title":"Step 1 - Build the Reservoir Model","text":"<pre><code>import bores\nimport numpy as np\n\nbores.use_32bit_precision()\n\ngrid_shape = (15, 15, 3)\ncell_dimension = (80.0, 80.0)\n\nthickness = bores.build_uniform_grid(grid_shape, value=20.0)\npressure = bores.build_uniform_grid(grid_shape, value=3000.0)\nporosity = bores.build_uniform_grid(grid_shape, value=0.20)\ntemperature = bores.build_uniform_grid(grid_shape, value=180.0)\noil_viscosity = bores.build_uniform_grid(grid_shape, value=2.0)\nbubble_point = bores.build_uniform_grid(grid_shape, value=2500.0)\noil_sg = bores.build_uniform_grid(grid_shape, value=0.87)\n\nSorw = bores.build_uniform_grid(grid_shape, value=0.22)\nSorg = bores.build_uniform_grid(grid_shape, value=0.15)\nSgr  = bores.build_uniform_grid(grid_shape, value=0.05)\nSwir = bores.build_uniform_grid(grid_shape, value=0.22)\nSwc  = bores.build_uniform_grid(grid_shape, value=0.22)\n\n# Build initial saturations from fluid contacts\ndepth = bores.build_depth_grid(thickness, datum=5000.0)\n\nSw, So, Sg = bores.build_saturation_grids(\n    depth_grid=depth,\n    gas_oil_contact=4900.0,       # GOC above reservoir (no initial gas cap)\n    oil_water_contact=5100.0,     # OWC near reservoir bottom\n    connate_water_saturation_grid=Swc,\n    residual_oil_saturation_water_grid=Sorw,\n    residual_oil_saturation_gas_grid=Sorg,\n    residual_gas_saturation_grid=Sgr,\n    porosity_grid=porosity,\n)\n\nperm_grid = bores.build_uniform_grid(grid_shape, value=150.0)\npermeability = bores.RockPermeability(x=perm_grid)\n\nmodel = bores.reservoir_model(\n    grid_shape=grid_shape,\n    cell_dimension=cell_dimension,\n    thickness_grid=thickness,\n    pressure_grid=pressure,\n    rock_compressibility=3e-6,\n    absolute_permeability=permeability,\n    porosity_grid=porosity,\n    temperature_grid=temperature,\n    water_saturation_grid=Sw,\n    gas_saturation_grid=Sg,\n    oil_saturation_grid=So,\n    oil_viscosity_grid=oil_viscosity,\n    oil_specific_gravity_grid=oil_sg,\n    oil_bubble_point_pressure_grid=bubble_point,\n    residual_oil_saturation_water_grid=Sorw,\n    residual_oil_saturation_gas_grid=Sorg,\n    residual_gas_saturation_grid=Sgr,\n    irreducible_water_saturation_grid=Swir,\n    connate_water_saturation_grid=Swc,\n    reservoir_gas=\"co2\",\n)\n</code></pre> <p>The only difference in the model construction is <code>reservoir_gas=\"co2\"</code>, which tells the PVT correlation engine that the gas phase properties should be computed for CO2 rather than methane. This affects gas viscosity, density, compressibility factor, and other derived properties.</p>"},{"location":"tutorials/05-miscible-flooding/#step-2-configure-the-co2-injection-well","title":"Step 2 - Configure the CO2 Injection Well","text":"<pre><code>co2_injector = bores.injection_well(\n    well_name=\"CO2-INJ-1\",\n    perforating_intervals=[((0, 0, 0), (0, 0, 2))],\n    radius=0.25,\n    control=bores.ConstantRateControl(target_rate=500.0),\n    injected_fluid=bores.InjectedFluid(\n        name=\"CO2\",\n        phase=bores.FluidPhase.GAS,\n        specific_gravity=1.52,\n        molecular_weight=44.01,\n        is_miscible=True,\n        minimum_miscibility_pressure=1800.0,\n        todd_longstaff_omega=0.67,\n        density=35.0,       # lbm/ft3 at reservoir conditions\n        viscosity=0.05,     # cP at reservoir conditions\n    ),\n)\n</code></pre> <p>This is the most important part of the tutorial. The <code>InjectedFluid</code> has several new parameters compared to the immiscible gas injection:</p> <p><code>is_miscible=True</code> activates the Todd-Longstaff miscible displacement model. Without this flag, the gas and oil phases remain separate regardless of pressure.</p> <p><code>minimum_miscibility_pressure=1800.0</code> sets the MMP in psi. Since our reservoir pressure is 3,000 psi, which is well above the MMP, the displacement will be fully miscible from the start. If reservoir pressure drops below the MMP during the simulation, the model automatically transitions to immiscible behavior.</p> <p><code>todd_longstaff_omega=0.67</code> is the mixing parameter. The value of \u2154 is the most commonly used default in the industry. We will explore the sensitivity to this parameter later in the tutorial.</p> <p><code>density=35.0</code> and <code>viscosity=0.05</code> override the correlation-based property calculations. This is important for CO2 because standard gas correlations (designed for hydrocarbon gases) significantly underestimate CO2 density and may give inaccurate viscosity values. At reservoir conditions (3,000 psi, 180 F), supercritical CO2 has a density around 35 lbm/ft3 and a viscosity around 0.05 cP. These values should ideally come from laboratory measurements or an equation of state model.</p> <p>CO2 Properties Require Overrides</p> <p>Standard gas PVT correlations in BORES (and most black-oil simulators) are calibrated for hydrocarbon gases and can give errors of 25% or more for CO2 density. Always provide explicit <code>density</code> and <code>viscosity</code> values for CO2 injection based on lab data, NIST tables, or an equation of state calculation. The overrides are backward compatible - if you omit them, BORES falls back to correlations.</p>"},{"location":"tutorials/05-miscible-flooding/#step-3-define-the-producer-and-configure","title":"Step 3 - Define the Producer and Configure","text":"<pre><code>producer = bores.production_well(\n    well_name=\"PROD-1\",\n    perforating_intervals=[((14, 14, 0), (14, 14, 2))],\n    radius=0.25,\n    control=bores.PrimaryPhaseRateControl(\n        primary_phase=bores.FluidPhase.OIL,\n        primary_control=bores.AdaptiveBHPRateControl(\n            target_rate=-400.0,\n            target_phase=\"oil\",\n            bhp_limit=800.0,\n        ),\n        secondary_clamp=bores.ProductionClamp(),\n    ),\n    produced_fluids=[\n        bores.ProducedFluid(\n            name=\"Oil\", phase=bores.FluidPhase.OIL,\n            specific_gravity=0.87, molecular_weight=200.0,\n        ),\n        bores.ProducedFluid(\n            name=\"Water\", phase=bores.FluidPhase.WATER,\n            specific_gravity=1.0, molecular_weight=18.015,\n        ),\n        bores.ProducedFluid(\n            name=\"CO2\", phase=bores.FluidPhase.GAS,\n            specific_gravity=1.52, molecular_weight=44.01,\n        ),\n    ],\n)\n\nwells = bores.wells_(injectors=[co2_injector], producers=[producer])\n\nrock_fluid = bores.RockFluidTables(\n    relative_permeability_table=bores.BrooksCoreyThreePhaseRelPermModel(\n        water_exponent=2.5,\n        oil_exponent=2.0,\n        gas_exponent=2.0,\n    ),\n    capillary_pressure_table=bores.BrooksCoreyCapillaryPressureModel(),\n)\n\nconfig = bores.Config(\n    timer=bores.Timer(\n        initial_step_size=bores.Time(days=0.5),\n        max_step_size=bores.Time(days=5),\n        min_step_size=bores.Time(hours=0.5),\n        simulation_time=bores.Time(days=1095),\n    ),\n    rock_fluid_tables=rock_fluid,\n    wells=wells,\n    scheme=\"impes\",\n    miscibility_model=\"todd_longstaff\",\n)\n</code></pre> <p>The critical configuration change is <code>miscibility_model=\"todd_longstaff\"</code> in the <code>Config</code>. This tells the simulator to use the Todd-Longstaff miscible model during saturation updates. Without this setting, the simulator would treat all gas injection as immiscible regardless of the <code>InjectedFluid</code> settings.</p> <p>The timer settings are the same as the immiscible gas injection tutorial because miscible fronts can be equally sharp.</p>"},{"location":"tutorials/05-miscible-flooding/#step-4-run-the-simulation","title":"Step 4 - Run the Simulation","text":"<pre><code>states = list(bores.run(model, config))\nfinal = states[-1]\nprint(f\"Completed {final.step} steps in {final.time_in_days:.1f} days\")\nprint(f\"Final avg pressure: {final.model.fluid_properties.pressure_grid.mean():.1f} psi\")\nprint(f\"Final avg oil saturation: {final.model.fluid_properties.oil_saturation_grid.mean():.4f}\")\n</code></pre>"},{"location":"tutorials/05-miscible-flooding/#step-5-visualize-solvent-concentration","title":"Step 5 - Visualize Solvent Concentration","text":"<p>One of the unique outputs of a miscible simulation is the solvent concentration field. This tracks how much CO2 has mixed into the oil phase in each cell, ranging from 0 (pure oil) to 1 (pure solvent).</p> <pre><code>viz = bores.plotly3d.DataVisualizer()\n\n# Visualize solvent concentration at midpoint and end\nfor state in [states[len(states) // 2], states[-1]]:\n    fig = viz.make_plot(\n        source=state,\n        property=\"solvent-concentration\",\n        plot_type=\"volume\",\n        title=f\"Solvent Concentration at Day {state.time_in_days:.0f}\",\n    )\n    fig.show()\n</code></pre> <p>The solvent concentration visualization shows the mixing zone between the pure CO2 bank and the undisplaced oil. In a miscible flood, this transition zone is smoother than the sharp front you see in immiscible displacement. The concentration field reveals how effectively the CO2 is contacting and mixing with the oil.</p>"},{"location":"tutorials/05-miscible-flooding/#concentration-profile-over-time","title":"Concentration Profile Over Time","text":"<pre><code>time_days = np.array([s.time_in_days for s in states])\navg_concentration = np.array([\n    s.model.fluid_properties.solvent_concentration_grid.mean() for s in states\n])\n\nfig = bores.make_series_plot(\n    data=np.column_stack([time_days, avg_concentration]),\n    title=\"Average Solvent Concentration Over Time\",\n    x_label=\"Time (days)\",\n    y_label=\"Solvent Concentration (fraction)\",\n)\nfig.show()\n</code></pre> <p>The average solvent concentration increases over time as more CO2 enters the reservoir and mixes with the oil. The rate of increase depends on the injection rate relative to the pore volume and the mixing efficiency (controlled by omega).</p>"},{"location":"tutorials/05-miscible-flooding/#step-6-compare-miscible-vs-immiscible-recovery","title":"Step 6 - Compare Miscible vs Immiscible Recovery","text":"<pre><code>avg_So = np.array([\n    s.model.fluid_properties.oil_saturation_grid.mean() for s in states\n])\n\ninitial_So = 0.75\nrecovery_factor = (initial_So - avg_So) / initial_So\n\nfig = bores.make_series_plot(\n    data=np.column_stack([time_days, recovery_factor]),\n    title=\"Oil Recovery Factor (Miscible CO2 Flood)\",\n    x_label=\"Time (days)\",\n    y_label=\"Recovery Factor (fraction of OOIP)\",\n)\nfig.show()\n</code></pre> <p>Compare this recovery curve with the immiscible gas flood from Tutorial 4. The miscible flood should show significantly higher ultimate recovery because:</p> <ol> <li> <p>Zero residual oil in swept zones - Miscibility eliminates capillary trapping, so oil saturation can drop to zero in cells fully contacted by CO2 (instead of being limited to Sorg = 0.15 in the immiscible case).</p> </li> <li> <p>Better sweep efficiency - The mixing of CO2 with oil reduces the viscosity contrast, improving the mobility ratio and reducing viscous fingering.</p> </li> <li> <p>Density modification - As CO2 dissolves into oil, it changes the oil density, which can reduce gravity segregation effects.</p> </li> </ol>"},{"location":"tutorials/05-miscible-flooding/#step-7-omega-sensitivity-analysis","title":"Step 7 - Omega Sensitivity Analysis","text":"<p>The mixing parameter \\(\\omega\\) has a significant effect on miscible flood performance. Here is how you would set up a sensitivity study by running multiple simulations with different omega values:</p> <pre><code># This is a conceptual example showing how to run a sensitivity study\nomega_values = [0.33, 0.50, 0.67, 0.80, 1.00]\nresults = {}\n\nfor omega in omega_values:\n    # Create a new injector with different omega\n    inj = bores.injection_well(\n        well_name=\"CO2-INJ-1\",\n        perforating_intervals=[((0, 0, 0), (0, 0, 2))],\n        radius=0.25,\n        control=bores.ConstantRateControl(target_rate=500.0),\n        injected_fluid=bores.InjectedFluid(\n            name=\"CO2\",\n            phase=bores.FluidPhase.GAS,\n            specific_gravity=1.52,\n            molecular_weight=44.01,\n            is_miscible=True,\n            minimum_miscibility_pressure=1800.0,\n            todd_longstaff_omega=omega,\n            density=35.0,\n            viscosity=0.05,\n        ),\n    )\n\n    # Update wells and config\n    wells_omega = bores.wells_(injectors=[inj], producers=[producer])\n    config_omega = config.with_updates(wells=wells_omega)\n\n    # Run simulation\n    states_omega = list(bores.run(model, config_omega))\n\n    # Store recovery factor\n    time_d = np.array([s.time_in_days for s in states_omega])\n    avg_so = np.array([\n        s.model.fluid_properties.oil_saturation_grid.mean() for s in states_omega\n    ])\n    rf = (initial_So - avg_so) / initial_So\n    results[f\"omega = {omega:.2f}\"] = np.column_stack([time_d, rf])\n\n# Plot all recovery curves together\nfig = bores.make_series_plot(\n    data=results,\n    title=\"Recovery Factor Sensitivity to Todd-Longstaff Omega\",\n    x_label=\"Time (days)\",\n    y_label=\"Recovery Factor (fraction of OOIP)\",\n)\nfig.show()\n</code></pre> <p>You should observe the following trends:</p> <ul> <li>\\(\\omega\\) = 0.33 (low mixing): Behaves closer to immiscible displacement. Poor mixing, lower recovery.</li> <li>\\(\\omega\\) = 0.67 (default): Moderate mixing. Represents typical field-scale behavior.</li> <li>\\(\\omega\\) = 1.00 (perfect mixing): Each grid cell is perfectly mixed. Highest recovery but may be optimistic for coarse grids.</li> </ul> <p>Choosing Omega</p> <p>The appropriate \\(\\omega\\) value depends on your grid resolution:</p> <ul> <li>Coarse grids (&gt; 100 ft cells): Use \\(\\omega\\) = 0.5 - 0.67 to compensate for unresolved mixing</li> <li>Medium grids (30 - 100 ft cells): Use \\(\\omega\\) = 0.67 - 0.8</li> <li>Fine grids (&lt; 30 ft cells): Use \\(\\omega\\) = 0.8 - 1.0 since the grid resolves more mixing</li> <li>When in doubt: Start with \\(\\omega\\) = \u2154 (0.667)</li> </ul>"},{"location":"tutorials/05-miscible-flooding/#when-to-use-miscible-flooding","title":"When to Use Miscible Flooding","text":"<p>Miscible gas flooding is most appropriate when:</p> <p>Reservoir pressure exceeds the MMP. If the reservoir pressure is below the MMP, you cannot achieve miscibility without first re-pressurizing the reservoir (typically through waterflooding). This is why miscible floods are often implemented as tertiary recovery after a waterflood.</p> <p>The oil is light to medium gravity. Heavier oils have higher MMPs, making miscibility harder to achieve. For oils below 25 API, the required MMP may exceed the fracture pressure of the formation.</p> <p>CO2 or enriched gas is available. CO2 is the most common miscible injectant because it achieves miscibility at lower pressures than lean natural gas. Enriched gas (natural gas with added intermediate hydrocarbons) is an alternative when CO2 is not available.</p> <p>The reservoir has reasonable continuity. Miscible floods are most effective in continuous, well-connected reservoirs where the solvent can contact a large fraction of the oil volume. Highly fractured or compartmentalized reservoirs may not benefit from miscible injection.</p>"},{"location":"tutorials/05-miscible-flooding/#key-takeaways","title":"Key Takeaways","text":"<ol> <li> <p>The Todd-Longstaff model simulates miscible displacement by modifying effective oil viscosity and density based on solvent concentration and the mixing parameter \\(\\omega\\).</p> </li> <li> <p><code>InjectedFluid</code> with <code>is_miscible=True</code> enables miscible behavior. You must also provide <code>minimum_miscibility_pressure</code> and <code>todd_longstaff_omega</code>.</p> </li> <li> <p>CO2 properties require explicit overrides (<code>density</code> and <code>viscosity</code> parameters) because standard gas correlations are inaccurate for CO2 at reservoir conditions.</p> </li> <li> <p><code>miscibility_model=\"todd_longstaff\"</code> must be set in the <code>Config</code> to activate miscible simulation during the solver loop.</p> </li> <li> <p>The mixing parameter \\(\\omega\\) controls the degree of sub-grid mixing. Use 0.67 as a default and adjust based on grid resolution and calibration data.</p> </li> <li> <p>Miscible flooding eliminates residual oil trapping, achieving near-100% displacement efficiency in swept zones, which can dramatically increase recovery compared to immiscible injection.</p> </li> </ol>"},{"location":"tutorials/05-miscible-flooding/#what-you-have-learned","title":"What You Have Learned","text":"<p>Across these five tutorials, you have progressed from a simple depletion study to an advanced miscible flooding simulation:</p> <ol> <li>Your First Simulation - The complete BORES workflow, primary depletion drive</li> <li>Building Reservoir Models - Heterogeneity, anisotropy, structural dip</li> <li>Waterflood Simulation - Secondary recovery with water injection</li> <li>Gas Injection - Immiscible gas displacement, gravity override</li> <li>Miscible Gas Flooding (this tutorial) - Todd-Longstaff miscible displacement with CO2</li> </ol> <p>You now have the foundational skills to set up, run, and analyze a wide range of reservoir simulation studies with BORES. For deeper exploration of specific topics, consult the User Guide for detailed coverage of wells, boundary conditions, PVT models, and solver configuration, or the API Reference for complete documentation of every class and function.</p>"},{"location":"user-guide/","title":"User Guide","text":"<p>The User Guide provides detailed documentation for every major subsystem in BORES. Each page covers one topic in depth, with working code examples, parameter references, and practical guidance.</p>"},{"location":"user-guide/#sections","title":"Sections","text":"Section Description Grids Grid construction utilities: uniform, layered, depth, structural dip, and saturation grids Rock Properties Porosity, permeability (isotropic and anisotropic), and rock compressibility Fluid Properties PVT correlations, oil/gas/water properties, and the reservoir model factory Relative Permeability Brooks-Corey model, Corey exponents, wettability, and three-phase mixing rules Capillary Pressure Brooks-Corey, Van Genuchten, Leverett J-function, and tabular capillary pressure Wells Well Basics Production and injection wells, perforations, well index, skin factor Well Controls Rate controls, BHP controls, PrimaryPhaseRateControl, MultiPhaseRateControl Well Fluids Produced fluids, injected fluids, CO2 property overrides Well Schedules Time-dependent well events, predicates, and actions Well Patterns Common well placement patterns for waterfloods and EOR Simulation Time Stepping Timer class, adaptive control, CFL conditions, ramp-up Solvers Pressure solvers, preconditioners, CachedPreconditionerFactory Streaming and Storage StateStream, storage backends, replay Advanced Boundary Conditions No-flow, constant pressure, periodic, Carter-Tracy aquifer Faults and Fractures Transmissibility modifiers, fault definitions PVT Tables Tabular PVT as alternative to correlations Simulation Analysis Analysis utilities, recovery factors, production profiles Serialization Saving/loading models, custom type registration Miscible Flooding Todd-Longstaff model, MMP, mixing parameter Configuration Complete Config class reference Constants Physical constants and the Constants class <p>Where to Start</p> <p>If you completed the Tutorials, start with the sections most relevant to your current project. The sections on wells, relative permeability, and simulation controls are the most commonly referenced.</p>"},{"location":"user-guide/capillary-pressure/","title":"Capillary Pressure","text":""},{"location":"user-guide/capillary-pressure/#what-is-capillary-pressure","title":"What is Capillary Pressure?","text":"<p>When two immiscible fluids share the same pore space, the interface between them curves due to differences in how strongly each fluid adheres to the rock surface. This curvature creates a pressure difference across the fluid-fluid interface, and that pressure difference is called capillary pressure. It is defined as the pressure in the non-wetting phase minus the pressure in the wetting phase:</p> \\[P_c = P_{nw} - P_w\\] <p>In a water-wet rock, water preferentially coats the grain surfaces and occupies the smaller pores, making water the wetting phase and oil the non-wetting phase. The oil-water capillary pressure \\(P_{cow} = P_o - P_w\\) is positive, meaning oil pressure exceeds water pressure. This pressure difference is what allows oil to occupy larger pores while water fills the smaller ones. The magnitude of capillary pressure depends on the pore throat size, the interfacial tension between the fluids, the contact angle of the fluid-rock system, and the saturation state.</p> <p>Capillary pressure plays a critical role in controlling the initial fluid distribution in a reservoir. Before any production begins, the reservoir is in capillary-gravity equilibrium: the capillary pressure at every point balances the gravity head caused by the density difference between the fluids. This equilibrium determines the transition zone, the region between the free water level and the depth where oil saturation reaches its maximum. In thick transition zones (common in tight rocks with high capillary pressure), water saturation decreases gradually with height above the free water level, and the oil column is never fully \"clean\" of water. In high-permeability rocks with low capillary pressure, the transition zone is thin and the contacts are sharp.</p> <p>During simulation, capillary pressure affects flow by modifying the pressure field. The pressure equation for each phase includes a capillary pressure correction: \\(P_o = P_w + P_{cow}\\) and \\(P_g = P_o + P_{cgo}\\). This means capillary forces act as an additional driving force (or resistance) to flow. In waterflooding, capillary pressure causes imbibition, where water spontaneously enters oil-filled pores even without an external pressure gradient. In gas injection, capillary entry pressure can prevent gas from entering tight rock layers, creating capillary barriers that trap gas.</p> <p>In a three-phase system (oil, water, gas), BORES tracks two capillary pressures:</p> <ul> <li>Oil-water capillary pressure: \\(P_{cow} = P_o - P_w\\) (positive in water-wet rock)</li> <li>Gas-oil capillary pressure: \\(P_{cgo} = P_g - P_o\\) (positive because gas is always non-wetting relative to oil)</li> </ul> <p>Both depend on saturation and are computed by the capillary pressure model at every grid cell and every timestep.</p>"},{"location":"user-guide/capillary-pressure/#the-brooks-corey-model","title":"The Brooks-Corey Model","text":"<p>The Brooks-Corey capillary pressure model is the most widely used analytical correlation in petroleum engineering. It relates capillary pressure to the effective saturation through a power law based on two parameters: the entry pressure and the pore size distribution index.</p> <p>The model is expressed as:</p> \\[P_c = P_d \\cdot S_e^{-1/\\lambda}\\] <p>where \\(P_d\\) is the entry (or displacement) pressure in psi, \\(S_e\\) is the effective (normalized) saturation, and \\(\\lambda\\) is the pore size distribution index. The entry pressure \\(P_d\\) represents the minimum capillary pressure needed for the non-wetting phase to enter the largest pore throats. Rocks with large, well-connected pores have low entry pressures (1-5 psi), while tight rocks with small pore throats have high entry pressures (10-50+ psi).</p> <p>The pore size distribution index \\(\\lambda\\) controls how rapidly capillary pressure changes with saturation. A large \\(\\lambda\\) (say 4-6) means the pore sizes are narrowly distributed (uniform rock), so capillary pressure changes gradually and the transition zone is narrow. A small \\(\\lambda\\) (say 0.5-1.5) means the pore sizes vary widely, producing a broad transition zone where capillary pressure changes steeply near residual saturation. Most reservoir sandstones have \\(\\lambda\\) values between 1.5 and 4.0, while carbonates tend to have lower values due to their more heterogeneous pore structure.</p>"},{"location":"user-guide/capillary-pressure/#basic-usage","title":"Basic Usage","text":"<pre><code>import bores\n\ncapillary = bores.BrooksCoreyCapillaryPressureModel(\n    oil_water_entry_pressure_water_wet=5.0,     # psi\n    oil_water_pore_size_distribution_index_water_wet=2.0,\n    gas_oil_entry_pressure=1.0,                  # psi\n    gas_oil_pore_size_distribution_index=2.0,\n)\n</code></pre> <p>This creates a water-wet Brooks-Corey model with an oil-water entry pressure of 5 psi, a gas-oil entry pressure of 1 psi, and a pore size distribution index of 2.0 for both systems. The gas-oil entry pressure is typically lower than the oil-water entry pressure because the gas-oil interfacial tension is lower than oil-water interfacial tension.</p> <p>Like the relative permeability model, residual saturations can be set on the model or inherited from the reservoir model. When the saturation endpoints are set to <code>None</code> (the default), BORES uses the endpoint grids from the reservoir model automatically. If you provide explicit values, those override the grid-level defaults.</p> <pre><code>capillary = bores.BrooksCoreyCapillaryPressureModel(\n    irreducible_water_saturation=0.25,\n    residual_oil_saturation_water=0.25,\n    residual_oil_saturation_gas=0.15,\n    residual_gas_saturation=0.05,\n    oil_water_entry_pressure_water_wet=5.0,\n    oil_water_pore_size_distribution_index_water_wet=2.5,\n    gas_oil_entry_pressure=1.5,\n    gas_oil_pore_size_distribution_index=2.0,\n)\n</code></pre>"},{"location":"user-guide/capillary-pressure/#brooks-corey-parameters","title":"Brooks-Corey Parameters","text":"Parameter Default Description <code>irreducible_water_saturation</code> <code>None</code> Connate water saturation \\(S_{wc}\\). If <code>None</code>, uses grid values. <code>residual_oil_saturation_water</code> <code>None</code> Residual oil to waterflood \\(S_{or,w}\\). If <code>None</code>, uses grid values. <code>residual_oil_saturation_gas</code> <code>None</code> Residual oil to gas flood \\(S_{or,g}\\). If <code>None</code>, uses grid values. <code>residual_gas_saturation</code> <code>None</code> Trapped gas saturation \\(S_{gr}\\). If <code>None</code>, uses grid values. <code>oil_water_entry_pressure_water_wet</code> <code>5.0</code> Entry pressure for oil-water system, water-wet (psi) <code>oil_water_entry_pressure_oil_wet</code> <code>5.0</code> Entry pressure for oil-water system, oil-wet (psi) <code>oil_water_pore_size_distribution_index_water_wet</code> <code>2.0</code> Pore size distribution index \\(\\lambda\\) for oil-water, water-wet <code>oil_water_pore_size_distribution_index_oil_wet</code> <code>2.0</code> Pore size distribution index \\(\\lambda\\) for oil-water, oil-wet <code>gas_oil_entry_pressure</code> <code>1.0</code> Entry pressure for gas-oil system (psi) <code>gas_oil_pore_size_distribution_index</code> <code>2.0</code> Pore size distribution index \\(\\lambda\\) for gas-oil <code>wettability</code> <code>WATER_WET</code> Rock wettability (<code>WATER_WET</code>, <code>OIL_WET</code>, or <code>MIXED_WET</code>) <code>mixed_wet_water_fraction</code> <code>0.5</code> Fraction of pore space that is water-wet (for <code>MIXED_WET</code> only)"},{"location":"user-guide/capillary-pressure/#wettability-effects-on-capillary-pressure","title":"Wettability Effects on Capillary Pressure","text":"<p>Wettability fundamentally changes the sign and magnitude of capillary pressure. In a water-wet system, oil must overcome the capillary entry pressure to enter a pore, so \\(P_{cow} &gt; 0\\). In an oil-wet system, the rock surface prefers oil, and water must overcome an entry pressure to displace oil, so \\(P_{cow} &lt; 0\\). In a mixed-wet system, BORES computes a weighted average of the water-wet and oil-wet capillary pressures.</p> <pre><code>import bores\n\n# Water-wet system: positive Pcow\ncap_ww = bores.BrooksCoreyCapillaryPressureModel(\n    oil_water_entry_pressure_water_wet=5.0,\n    oil_water_pore_size_distribution_index_water_wet=2.5,\n    gas_oil_entry_pressure=1.0,\n    gas_oil_pore_size_distribution_index=2.0,\n    wettability=bores.Wettability.WATER_WET,\n)\n\n# Oil-wet system: negative Pcow\ncap_ow = bores.BrooksCoreyCapillaryPressureModel(\n    oil_water_entry_pressure_oil_wet=4.0,\n    oil_water_pore_size_distribution_index_oil_wet=2.0,\n    gas_oil_entry_pressure=1.0,\n    gas_oil_pore_size_distribution_index=2.0,\n    wettability=bores.Wettability.OIL_WET,\n)\n\n# Mixed-wet system: 60% water-wet, 40% oil-wet pore surfaces\ncap_mw = bores.BrooksCoreyCapillaryPressureModel(\n    oil_water_entry_pressure_water_wet=5.0,\n    oil_water_entry_pressure_oil_wet=4.0,\n    oil_water_pore_size_distribution_index_water_wet=2.5,\n    oil_water_pore_size_distribution_index_oil_wet=2.0,\n    gas_oil_entry_pressure=1.0,\n    gas_oil_pore_size_distribution_index=2.0,\n    wettability=bores.Wettability.MIXED_WET,\n    mixed_wet_water_fraction=0.6,\n)\n</code></pre> <p>The mixed-wet option is particularly useful for carbonate reservoirs and aged sandstones where the wettability is intermediate. The <code>mixed_wet_water_fraction</code> parameter controls the weighting: a value of 0.6 means 60% of the pore surface area is water-wet and 40% is oil-wet. The resulting capillary pressure is a linear combination of the two end-member curves, which can produce the characteristic \"crossover\" behavior seen in mixed-wet SCAL data where capillary pressure changes sign at intermediate saturations.</p> <p>Entry Pressure and Rock Quality</p> <p>Entry pressure correlates inversely with permeability. High-permeability sands (500+ mD) may have entry pressures below 1 psi, while tight sandstones (1-10 mD) can have entry pressures of 20-50 psi. A useful rule of thumb: \\(P_d \\approx C / \\sqrt{k}\\) where \\(C\\) is an empirical constant (roughly 3-10 depending on the rock type) and \\(k\\) is permeability in mD.</p>"},{"location":"user-guide/capillary-pressure/#the-van-genuchten-model","title":"The Van Genuchten Model","text":"<p>The Van Genuchten model is an alternative to Brooks-Corey that provides smoother capillary pressure curves, particularly near the residual saturations where Brooks-Corey produces infinite values. This smoothness makes the Van Genuchten model numerically better-behaved and is often preferred for simulations where convergence near residual saturation is important.</p> <p>The model is expressed as:</p> \\[P_c = \\frac{1}{\\alpha} \\left[ S_e^{-1/m} - 1 \\right]^{1/n}\\] <p>where \\(\\alpha\\) is an inverse pressure parameter (in 1/psi), \\(n\\) is a shape parameter that must be greater than 1, and \\(m = 1 - 1/n\\) is derived from \\(n\\). The parameter \\(\\alpha\\) is roughly the inverse of the entry pressure: larger \\(\\alpha\\) values produce lower capillary pressures. The parameter \\(n\\) controls the curve shape and has a similar role to the pore size distribution index in Brooks-Corey: higher values produce narrower transition zones.</p> <p>The key advantage of Van Genuchten over Brooks-Corey is its behavior at the endpoints. Brooks-Corey capillary pressure goes to infinity as saturation approaches the residual value (\\(S_e \\to 0\\)), which can cause numerical difficulties. Van Genuchten also approaches infinity but does so more gradually, which makes the transition smoother and reduces the risk of solver convergence issues.</p>"},{"location":"user-guide/capillary-pressure/#van-genuchten-usage","title":"Van Genuchten Usage","text":"<pre><code>import bores\n\ncapillary = bores.VanGenuchtenCapillaryPressureModel(\n    oil_water_alpha_water_wet=0.01,    # 1/psi (roughly: entry pressure ~ 1/alpha)\n    oil_water_n_water_wet=2.0,          # Shape parameter (must be &gt; 1)\n    gas_oil_alpha=0.02,                 # 1/psi\n    gas_oil_n=2.0,                      # Shape parameter\n)\n</code></pre> <p>The Van Genuchten model supports the same wettability options as Brooks-Corey, with separate parameters for the water-wet and oil-wet components. For water-wet systems, \\(P_{cow} &gt; 0\\); for oil-wet, \\(P_{cow} &lt; 0\\); and for mixed-wet, a weighted average is used.</p>"},{"location":"user-guide/capillary-pressure/#van-genuchten-parameters","title":"Van Genuchten Parameters","text":"Parameter Default Description <code>irreducible_water_saturation</code> <code>None</code> Connate water saturation \\(S_{wc}\\). <code>residual_oil_saturation_water</code> <code>None</code> Residual oil to waterflood \\(S_{or,w}\\). <code>residual_oil_saturation_gas</code> <code>None</code> Residual oil to gas flood \\(S_{or,g}\\). <code>residual_gas_saturation</code> <code>None</code> Trapped gas saturation \\(S_{gr}\\). <code>oil_water_alpha_water_wet</code> <code>0.01</code> Van Genuchten \\(\\alpha\\) for oil-water, water-wet (1/psi) <code>oil_water_alpha_oil_wet</code> <code>0.01</code> Van Genuchten \\(\\alpha\\) for oil-water, oil-wet (1/psi) <code>oil_water_n_water_wet</code> <code>2.0</code> Van Genuchten \\(n\\) for oil-water, water-wet <code>oil_water_n_oil_wet</code> <code>2.0</code> Van Genuchten \\(n\\) for oil-water, oil-wet <code>gas_oil_alpha</code> <code>0.01</code> Van Genuchten \\(\\alpha\\) for gas-oil (1/psi) <code>gas_oil_n</code> <code>2.0</code> Van Genuchten \\(n\\) for gas-oil <code>wettability</code> <code>WATER_WET</code> Rock wettability <code>mixed_wet_water_fraction</code> <code>0.5</code> Water-wet pore fraction (for <code>MIXED_WET</code>) <p>Converting Between Brooks-Corey and Van Genuchten</p> <p>There is no exact conversion between the two models, but approximate relationships exist. The Van Genuchten \\(\\alpha\\) is roughly the inverse of the Brooks-Corey entry pressure: \\(\\alpha \\approx 1 / P_d\\). The shape parameters are related by \\(n \\approx \\lambda + 1\\) for \\(\\lambda &gt; 1\\). These are rough guides for getting a starting point when switching between models.</p>"},{"location":"user-guide/capillary-pressure/#the-leverett-j-function-model","title":"The Leverett J-Function Model","text":"<p>The Leverett J-function is a dimensionless correlation that normalizes capillary pressure by rock and fluid properties. This makes it possible to transfer capillary pressure data measured on one core sample to other parts of the reservoir with different porosity and permeability, without needing separate measurements for each rock type.</p> <p>The J-function relates capillary pressure to rock quality through:</p> \\[P_c = \\sigma \\cos\\theta \\sqrt{\\frac{\\phi}{k}} \\cdot J(S_e)\\] <p>where \\(\\sigma\\) is the interfacial tension (dyne/cm), \\(\\theta\\) is the contact angle (degrees), \\(\\phi\\) is porosity, \\(k\\) is permeability (mD), and \\(J(S_e)\\) is the dimensionless J-function evaluated at effective saturation. The \\(\\sqrt{\\phi/k}\\) factor captures the relationship between rock quality and pore throat size: tight rocks (low \\(k\\), low \\(\\phi\\)) have smaller pores and therefore higher capillary pressures.</p> <p>In BORES, the J-function uses a power-law form: \\(J(S_e) = a \\cdot S_e^{-b}\\), where \\(a\\) is the <code>j_function_coefficient</code> and \\(b\\) is the <code>j_function_exponent</code>. These empirical parameters are typically calibrated by fitting the J-function model to laboratory capillary pressure data from one or more core plugs.</p> <p>The Leverett J-function approach is most valuable in heterogeneous reservoirs where porosity and permeability vary spatially. Because the model scales capillary pressure by the local \\(\\sqrt{\\phi/k}\\), it automatically produces higher capillary pressures in tight zones and lower values in high-permeability zones, without needing separate capillary pressure curves for each rock type.</p>"},{"location":"user-guide/capillary-pressure/#leverett-j-function-usage","title":"Leverett J-Function Usage","text":"<pre><code>import bores\n\ncapillary = bores.LeverettJCapillaryPressureModel(\n    permeability=100.0,                 # mD (reference permeability)\n    porosity=0.2,                        # Reference porosity\n    oil_water_interfacial_tension=30.0,  # dyne/cm\n    gas_oil_interfacial_tension=20.0,    # dyne/cm\n    contact_angle_oil_water=0.0,         # degrees (0 = water-wet)\n    contact_angle_gas_oil=0.0,           # degrees\n    j_function_coefficient=0.5,          # Empirical coefficient 'a'\n    j_function_exponent=0.5,             # Empirical exponent 'b'\n)\n</code></pre>"},{"location":"user-guide/capillary-pressure/#leverett-j-function-parameters","title":"Leverett J-Function Parameters","text":"Parameter Default Description <code>irreducible_water_saturation</code> <code>None</code> Connate water saturation \\(S_{wc}\\). <code>residual_oil_saturation_water</code> <code>None</code> Residual oil to waterflood \\(S_{or,w}\\). <code>residual_oil_saturation_gas</code> <code>None</code> Residual oil to gas flood \\(S_{or,g}\\). <code>residual_gas_saturation</code> <code>None</code> Trapped gas saturation \\(S_{gr}\\). <code>permeability</code> <code>100.0</code> Absolute permeability (mD) <code>porosity</code> <code>0.2</code> Porosity (fraction) <code>oil_water_interfacial_tension</code> <code>30.0</code> Oil-water IFT (dyne/cm) <code>gas_oil_interfacial_tension</code> <code>20.0</code> Gas-oil IFT (dyne/cm) <code>contact_angle_oil_water</code> <code>0.0</code> Oil-water contact angle (degrees) <code>contact_angle_gas_oil</code> <code>0.0</code> Gas-oil contact angle (degrees) <code>j_function_coefficient</code> <code>0.5</code> Coefficient \\(a\\) in \\(J = a \\cdot S_e^{-b}\\) <code>j_function_exponent</code> <code>0.5</code> Exponent \\(b\\) in \\(J = a \\cdot S_e^{-b}\\) <code>wettability</code> <code>WATER_WET</code> Rock wettability <code>mixed_wet_water_fraction</code> <code>0.5</code> Water-wet pore fraction (for <code>MIXED_WET</code>) <p>Contact Angle Convention</p> <p>A contact angle of 0 degrees means the wetting phase perfectly wets the rock (the interface is flat against the surface). A contact angle of 90 degrees means neutral wettability. Contact angles above 90 degrees indicate the non-wetting phase is actually more wetting. In practice, petroleum engineers often specify wettability through the <code>wettability</code> parameter rather than manipulating contact angles directly.</p>"},{"location":"user-guide/capillary-pressure/#tabular-capillary-pressure","title":"Tabular Capillary Pressure","text":"<p>When you have laboratory-measured capillary pressure data from mercury injection, centrifuge, or porous plate experiments, you can use tabular capillary pressure instead of an analytical model. BORES provides <code>TwoPhaseCapillaryPressureTable</code> for single phase-pair data and <code>ThreePhaseCapillaryPressureTable</code> for combining oil-water and gas-oil data into a complete three-phase model.</p> <p>Tabular capillary pressure is the preferred approach when you have high-quality SCAL data that does not fit well to a Brooks-Corey or Van Genuchten curve. Laboratory data often shows features that analytical models cannot capture: multiple inflection points from bimodal pore size distributions, sudden changes in slope at specific saturations, or asymmetric behavior at the drainage and imbibition endpoints. Using the raw data as a table preserves all of these features.</p>"},{"location":"user-guide/capillary-pressure/#twophasecapillarypressuretable","title":"TwoPhaseCapillaryPressureTable","text":"<p>A <code>TwoPhaseCapillaryPressureTable</code> stores wetting phase saturation values and the corresponding capillary pressure at each saturation. You specify which fluid is the wetting phase and which is the non-wetting phase.</p> <pre><code>import bores\nimport numpy as np\n\n# Oil-water capillary pressure from mercury injection data\now_pc_table = bores.TwoPhaseCapillaryPressureTable(\n    wetting_phase=bores.FluidPhase.WATER,\n    non_wetting_phase=bores.FluidPhase.OIL,\n    wetting_phase_saturation=np.array([0.20, 0.25, 0.30, 0.40, 0.50, 0.60, 0.70, 0.80]),\n    capillary_pressure=np.array([25.0, 12.0, 7.5, 4.2, 2.8, 1.8, 1.0, 0.3]),\n)\n</code></pre> <p>The <code>wetting_phase_saturation</code> array must be monotonically increasing and contain at least two points. Capillary pressure values should decrease as wetting phase saturation increases (more water means lower capillary pressure in a water-wet system). BORES uses <code>np.interp</code> for fast linear interpolation between table points, with constant extrapolation beyond the table endpoints.</p> <p>You can query the table at any saturation value or with grid arrays:</p> <pre><code># Single point query\npc_at_04 = ow_pc_table.get_capillary_pressure(0.4)\n\n# Grid array query\nSw_grid = np.random.uniform(0.2, 0.8, size=(20, 20, 5))\npc_grid = ow_pc_table.get_capillary_pressure(Sw_grid)\n</code></pre>"},{"location":"user-guide/capillary-pressure/#threephasecapillarypressuretable","title":"ThreePhaseCapillaryPressureTable","text":"<p>For three-phase simulation, combine two <code>TwoPhaseCapillaryPressureTable</code> objects into a <code>ThreePhaseCapillaryPressureTable</code>. This is the capillary pressure equivalent of the <code>ThreePhaseRelPermTable</code> and follows the same pattern.</p> <pre><code>import bores\nimport numpy as np\n\n# Oil-water capillary pressure (water is wetting phase)\now_pc = bores.TwoPhaseCapillaryPressureTable(\n    wetting_phase=bores.FluidPhase.WATER,\n    non_wetting_phase=bores.FluidPhase.OIL,\n    wetting_phase_saturation=np.array([0.20, 0.30, 0.40, 0.50, 0.60, 0.70, 0.80]),\n    capillary_pressure=np.array([20.0, 8.5, 4.5, 2.8, 1.5, 0.7, 0.1]),\n)\n\n# Gas-oil capillary pressure (oil is wetting phase)\ngo_pc = bores.TwoPhaseCapillaryPressureTable(\n    wetting_phase=bores.FluidPhase.OIL,\n    non_wetting_phase=bores.FluidPhase.GAS,\n    wetting_phase_saturation=np.array([0.15, 0.25, 0.40, 0.55, 0.70, 0.85]),\n    capillary_pressure=np.array([8.0, 4.5, 2.0, 1.0, 0.4, 0.05]),\n)\n\n# Combine into three-phase table\nthree_phase_pc = bores.ThreePhaseCapillaryPressureTable(\n    oil_water_table=ow_pc,\n    gas_oil_table=go_pc,\n)\n</code></pre> <p>The <code>ThreePhaseCapillaryPressureTable</code> validates the phase assignments on construction. The oil-water table must have water and oil as its phases, the gas-oil table must have oil and gas, and the gas-oil table must have oil as the wetting phase. If any of these constraints are violated, BORES raises a <code>ValidationError</code>.</p> <p>When computing capillary pressures during simulation, the three-phase table looks up \\(P_{cow}\\) from the oil-water table using the wetting phase saturation and \\(P_{cgo}\\) from the gas-oil table using the oil saturation. The two capillary pressures are independent (no mixing rule is needed, unlike relative permeability).</p> <p>When to Use Tables vs. Analytical Models</p> <p>Use tabular capillary pressure when you have high-quality laboratory SCAL data (mercury injection, centrifuge, or porous plate), when your pore size distribution is bimodal or otherwise poorly described by a single power law, or when you need to exactly reproduce measured capillary pressure curves for history matching. Use analytical models (Brooks-Corey or Van Genuchten) when lab data is unavailable, when you want to parametrically study the effect of entry pressure or pore size distribution, or when you need smooth derivatives for numerical stability.</p>"},{"location":"user-guide/capillary-pressure/#direct-usage-outside-simulation","title":"Direct Usage (Outside Simulation)","text":"<p>You do not need to run a full simulation to evaluate capillary pressure models. All models (analytical and tabular) can be called directly with saturation values, which is useful for plotting curves, comparing models, validating against laboratory data, or building custom analysis workflows. Every model supports both scalar and grid-array inputs.</p>"},{"location":"user-guide/capillary-pressure/#calling-analytical-models-directly","title":"Calling Analytical Models Directly","text":"<p>The <code>BrooksCoreyCapillaryPressureModel</code>, <code>VanGenuchtenCapillaryPressureModel</code>, and <code>LeverettJCapillaryPressureModel</code> all support the same calling interface. Use <code>get_capillary_pressures()</code> or <code>__call__</code> with water, oil, and gas saturations. They return a dictionary with <code>\"oil_water\"</code> and <code>\"gas_oil\"</code> keys.</p> <pre><code>import bores\nimport numpy as np\n\ncapillary = bores.BrooksCoreyCapillaryPressureModel(\n    irreducible_water_saturation=0.25,\n    residual_oil_saturation_water=0.25,\n    residual_oil_saturation_gas=0.15,\n    residual_gas_saturation=0.05,\n    oil_water_entry_pressure_water_wet=5.0,\n    oil_water_pore_size_distribution_index_water_wet=2.5,\n    gas_oil_entry_pressure=1.5,\n    gas_oil_pore_size_distribution_index=2.0,\n)\n\n# Scalar evaluation\nresult = capillary.get_capillary_pressures(\n    water_saturation=0.4,\n    oil_saturation=0.55,\n    gas_saturation=0.05,\n)\nprint(f\"Pcow = {result['oil_water']:.2f} psi\")\nprint(f\"Pcgo = {result['gas_oil']:.2f} psi\")\n\n# Using __call__ (same result)\nresult = capillary(\n    water_saturation=0.4,\n    oil_saturation=0.55,\n    gas_saturation=0.05,\n)\n\n# Grid array evaluation (3D)\nSw = bores.build_uniform_grid((20, 20, 5), value=0.4)\nSo = bores.build_uniform_grid((20, 20, 5), value=0.55)\nSg = bores.build_uniform_grid((20, 20, 5), value=0.05)\n\nresult = capillary(water_saturation=Sw, oil_saturation=So, gas_saturation=Sg)\npcow_grid = result[\"oil_water\"]  # Shape: (20, 20, 5)\npcgo_grid = result[\"gas_oil\"]    # Shape: (20, 20, 5)\n</code></pre> <p>The <code>get_capillary_pressures()</code> method also accepts optional residual saturation overrides that take precedence over the model defaults. This is useful when the simulator passes cell-level saturation endpoints from the grid:</p> <pre><code>result = capillary.get_capillary_pressures(\n    water_saturation=0.35,\n    oil_saturation=0.60,\n    gas_saturation=0.05,\n    irreducible_water_saturation=0.20,   # Override model default\n    residual_oil_saturation_water=0.30,  # Override model default\n)\n</code></pre> <p>The Van Genuchten and Leverett J-function models use the exact same calling convention:</p> <pre><code>vg = bores.VanGenuchtenCapillaryPressureModel(\n    irreducible_water_saturation=0.25,\n    residual_oil_saturation_water=0.25,\n    residual_oil_saturation_gas=0.15,\n    residual_gas_saturation=0.05,\n    oil_water_alpha_water_wet=0.01,\n    oil_water_n_water_wet=2.0,\n    gas_oil_alpha=0.02,\n    gas_oil_n=2.0,\n)\n\nresult = vg(water_saturation=0.4, oil_saturation=0.55, gas_saturation=0.05)\n</code></pre>"},{"location":"user-guide/capillary-pressure/#calling-tabular-models-directly","title":"Calling Tabular Models Directly","text":"<p>The <code>TwoPhaseCapillaryPressureTable</code> can be queried at any saturation using <code>get_capillary_pressure()</code> or <code>__call__</code>:</p> <pre><code># Using the ow_pc_table from earlier\npc_scalar = ow_pc_table.get_capillary_pressure(0.45)\nprint(f\"Pcow at Sw=0.45: {pc_scalar:.2f} psi\")\n\n# Using __call__\npc_scalar = ow_pc_table(wetting_phase_saturation=0.45)\n\n# Grid array query\nSw_grid = np.random.uniform(0.2, 0.8, size=(20, 20, 5))\npc_grid = ow_pc_table.get_capillary_pressure(Sw_grid)  # Shape: (20, 20, 5)\n</code></pre> <p>The <code>ThreePhaseCapillaryPressureTable</code> uses <code>get_capillary_pressures()</code> or <code>__call__</code> with all three saturations:</p> <pre><code># Using the three_phase_pc from earlier\nresult = three_phase_pc.get_capillary_pressures(\n    water_saturation=0.4,\n    oil_saturation=0.5,\n    gas_saturation=0.1,\n)\nprint(f\"Pcow = {result['oil_water']:.2f} psi\")\nprint(f\"Pcgo = {result['gas_oil']:.2f} psi\")\n\n# Using __call__\nresult = three_phase_pc(\n    water_saturation=Sw,\n    oil_saturation=So,\n    gas_saturation=Sg,\n)\n</code></pre> <p>This direct evaluation capability is essential for building capillary pressure curves for reports, comparing different models or parameter sets, and verifying that your model produces physically consistent pressures before running a simulation.</p>"},{"location":"user-guide/capillary-pressure/#integrating-with-rockfluidtables","title":"Integrating with RockFluidTables","text":"<p>Capillary pressure is passed to the simulation through the <code>RockFluidTables</code> object alongside the relative permeability model. You can mix analytical and tabular approaches freely: for example, you could use Brooks-Corey relative permeability with tabular capillary pressure, or tabular relative permeability with a Van Genuchten capillary pressure model.</p> <pre><code>import bores\n\n# Analytical relative permeability + analytical capillary pressure\nrock_fluid = bores.RockFluidTables(\n    relative_permeability_table=bores.BrooksCoreyThreePhaseRelPermModel(\n        water_exponent=2.5,\n        oil_exponent=2.0,\n        gas_exponent=2.0,\n    ),\n    capillary_pressure_table=bores.BrooksCoreyCapillaryPressureModel(\n        oil_water_entry_pressure_water_wet=5.0,\n        oil_water_pore_size_distribution_index_water_wet=2.5,\n        gas_oil_entry_pressure=1.0,\n        gas_oil_pore_size_distribution_index=2.0,\n    ),\n)\n</code></pre> <p>You can also combine tabular relative permeability with an analytical capillary pressure model, or vice versa:</p> <pre><code># Tabular capillary pressure with analytical relative permeability\nrock_fluid = bores.RockFluidTables(\n    relative_permeability_table=bores.BrooksCoreyThreePhaseRelPermModel(\n        water_exponent=2.0,\n        oil_exponent=2.0,\n        gas_exponent=2.0,\n    ),\n    capillary_pressure_table=three_phase_pc,  # ThreePhaseCapillaryPressureTable from lab data\n)\n</code></pre> <p>Pass the <code>RockFluidTables</code> to the <code>Config</code> to use it in simulation:</p> <pre><code>config = bores.Config(\n    timer=timer,\n    rock_fluid_tables=rock_fluid,\n    wells=wells,\n    scheme=\"impes\",\n)\n</code></pre> <p>Both analytical models and tabular data are serializable. When you save a <code>Config</code>, all capillary pressure parameters or table data are preserved and can be reloaded exactly.</p>"},{"location":"user-guide/capillary-pressure/#visualizing-capillary-pressure-curves","title":"Visualizing Capillary Pressure Curves","text":"<p>Visualizing your capillary pressure curves before running a simulation is essential for verifying that the model matches your physical expectations. The best approach is to create the actual model you plan to use and call it directly across a saturation sweep. This ensures the plotted curves are exactly what the simulator will use.</p>"},{"location":"user-guide/capillary-pressure/#oil-water-capillary-pressure","title":"Oil-Water Capillary Pressure","text":"<pre><code>import bores\nimport numpy as np\n\n# Create the model\ncapillary = bores.BrooksCoreyCapillaryPressureModel(\n    irreducible_water_saturation=0.25,\n    residual_oil_saturation_water=0.25,\n    residual_oil_saturation_gas=0.15,\n    residual_gas_saturation=0.05,\n    oil_water_entry_pressure_water_wet=5.0,\n    oil_water_pore_size_distribution_index_water_wet=2.5,\n    gas_oil_entry_pressure=1.5,\n    gas_oil_pore_size_distribution_index=2.0,\n)\n\n# Sweep water saturation across the mobile range (no free gas)\nSw_values = np.linspace(0.26, 0.75, 100)  # Slightly above Swc to avoid singularity\npcow_values = np.zeros_like(Sw_values)\n\nfor i, sw in enumerate(Sw_values):\n    so = 1.0 - sw  # No free gas\n    result = capillary.get_capillary_pressures(\n        water_saturation=sw, oil_saturation=so, gas_saturation=0.0,\n    )\n    pcow_values[i] = result[\"oil_water\"]\n\nfig = bores.make_series_plot(\n    data=np.column_stack([Sw_values, pcow_values]),\n    title=\"Brooks-Corey Oil-Water Capillary Pressure\",\n    x_label=\"Water Saturation (fraction)\",\n    y_label=\"Capillary Pressure (psi)\",\n)\nfig.show()\n# Output: [PLACEHOLDER: Insert capillary_pressure_curve.png]\n</code></pre> <p>This plot should show capillary pressure decreasing from a high value at low water saturation (near residual) toward zero as water saturation approaches the maximum mobile value. If the curve shows unexpected shapes (negative values in a water-wet system, or unreasonably high pressures), check your entry pressure and pore size distribution index.</p>"},{"location":"user-guide/capillary-pressure/#comparing-models","title":"Comparing Models","text":"<p>You can plot multiple capillary pressure models together to compare their behavior. This is useful when deciding between Brooks-Corey and Van Genuchten, or when evaluating how different wettability settings affect the curves:</p> <pre><code>import bores\nimport numpy as np\n\n# Brooks-Corey (water-wet)\nbc_ww = bores.BrooksCoreyCapillaryPressureModel(\n    irreducible_water_saturation=0.25,\n    residual_oil_saturation_water=0.25,\n    oil_water_entry_pressure_water_wet=5.0,\n    oil_water_pore_size_distribution_index_water_wet=2.5,\n)\n\n# Van Genuchten (water-wet)\nvg_ww = bores.VanGenuchtenCapillaryPressureModel(\n    irreducible_water_saturation=0.25,\n    residual_oil_saturation_water=0.25,\n    oil_water_alpha_water_wet=0.2,\n    oil_water_n_water_wet=2.5,\n)\n\n# Evaluate both across the same saturation range\nSw_range = np.linspace(0.26, 0.74, 80)\npcow_bc = np.zeros_like(Sw_range)\npcow_vg = np.zeros_like(Sw_range)\n\nfor i, sw in enumerate(Sw_range):\n    so = 1.0 - sw\n    result_bc = bc_ww.get_capillary_pressures(\n        water_saturation=sw, oil_saturation=so, gas_saturation=0.0,\n    )\n    result_vg = vg_ww.get_capillary_pressures(\n        water_saturation=sw, oil_saturation=so, gas_saturation=0.0,\n    )\n    pcow_bc[i] = result_bc[\"oil_water\"]\n    pcow_vg[i] = result_vg[\"oil_water\"]\n\nfig = bores.make_series_plot(\n    data={\n        \"Brooks-Corey\": np.column_stack([Sw_range, pcow_bc]),\n        \"Van Genuchten\": np.column_stack([Sw_range, pcow_vg]),\n    },\n    title=\"Capillary Pressure Model Comparison\",\n    x_label=\"Water Saturation (fraction)\",\n    y_label=\"Capillary Pressure (psi)\",\n)\nfig.show()\n# Output: [PLACEHOLDER: Insert capillary_pressure_comparison.png]\n</code></pre> <p>You should see that both models produce similar general shapes (high Pc at low Sw, low Pc at high Sw), but the Van Genuchten curve is smoother near the residual saturation where Brooks-Corey approaches infinity. This smoother behavior is why Van Genuchten is sometimes preferred for numerical stability.</p>"},{"location":"user-guide/capillary-pressure/#choosing-a-capillary-pressure-model","title":"Choosing a Capillary Pressure Model","text":"<p>The choice of capillary pressure model depends on the data available and the simulation objectives.</p> <p>Brooks-Corey is the most common starting point. It is simple, well-understood, and has only two fitting parameters per phase pair (entry pressure and pore size distribution index). Use it when you have limited data or need a quick, physically reasonable approximation. Its main limitation is the infinite capillary pressure at residual saturation, which can cause numerical issues in some cases.</p> <p>Van Genuchten is preferred when numerical stability near residual saturations is important. Its smoother curve shape avoids the singularity at \\(S_e = 0\\) and produces better convergence in implicit solvers. It is widely used in environmental and groundwater modeling and is increasingly common in petroleum applications. Use it when your simulation shows convergence difficulties near residual saturation with Brooks-Corey.</p> <p>Leverett J-function is the best choice when you have heterogeneous rock properties and want capillary pressure to scale automatically with local porosity and permeability. If your reservoir has significant spatial variation in rock quality (e.g., layered sandstone-shale sequences), the J-function approach produces physically consistent capillary pressure distributions without needing separate models for each rock type.</p> <p>Tabular data should be used when you have high-quality laboratory measurements that do not fit any analytical model well, or when you need exact reproduction of measured curves for regulatory or history-matching purposes.</p> <p>Quick Reference: Typical Parameter Sets</p> Consolidated SandstoneTight CarbonateHigh-Perm UnconsolidatedHeterogeneous with J-Function <pre><code>capillary = bores.BrooksCoreyCapillaryPressureModel(\n    oil_water_entry_pressure_water_wet=5.0,\n    oil_water_pore_size_distribution_index_water_wet=2.5,\n    gas_oil_entry_pressure=1.5,\n    gas_oil_pore_size_distribution_index=2.0,\n    wettability=bores.Wettability.WATER_WET,\n)\n</code></pre> <pre><code>capillary = bores.BrooksCoreyCapillaryPressureModel(\n    oil_water_entry_pressure_water_wet=25.0,\n    oil_water_pore_size_distribution_index_water_wet=1.2,\n    gas_oil_entry_pressure=10.0,\n    gas_oil_pore_size_distribution_index=1.5,\n    wettability=bores.Wettability.OIL_WET,\n    oil_water_entry_pressure_oil_wet=20.0,\n    oil_water_pore_size_distribution_index_oil_wet=1.0,\n)\n</code></pre> <pre><code>capillary = bores.VanGenuchtenCapillaryPressureModel(\n    oil_water_alpha_water_wet=0.5,     # Low capillary pressure\n    oil_water_n_water_wet=3.0,          # Narrow pore size distribution\n    gas_oil_alpha=0.8,\n    gas_oil_n=2.5,\n)\n</code></pre> <pre><code>capillary = bores.LeverettJCapillaryPressureModel(\n    permeability=150.0,\n    porosity=0.22,\n    oil_water_interfacial_tension=30.0,\n    gas_oil_interfacial_tension=20.0,\n    j_function_coefficient=0.4,\n    j_function_exponent=0.5,\n)\n</code></pre> <p>Capillary Pressure and Numerical Stability</p> <p>Very high capillary pressures (above 50 psi) can cause pressure oscillations and timestep cuts in explicit saturation schemes. If you encounter convergence problems, consider: (1) switching from Brooks-Corey to Van Genuchten for smoother behavior, (2) reducing entry pressure if the high values are not well-constrained by data, (3) using smaller timesteps in regions with high capillary gradients, or (4) using 64-bit precision via <code>bores.use_64bit_precision()</code> for better numerical accuracy.</p>"},{"location":"user-guide/config/","title":"Configuration","text":""},{"location":"user-guide/config/#overview","title":"Overview","text":"<p>The <code>Config</code> class holds every parameter that controls how a BORES simulation runs. It specifies the timer (time stepping behavior), the rock-fluid tables (relative permeability and capillary pressure models), the wells, the numerical scheme, the solvers, the preconditioners, the convergence tolerances, and all the physical constraints that keep the simulation stable and accurate.</p> <p><code>Config</code> is a frozen (immutable) attrs class. Once you create a <code>Config</code>, its fields cannot be changed in place. To modify a configuration, you create a new one using the <code>copy()</code> or <code>with_updates()</code> methods. This immutability prevents accidental modification of simulation parameters during a run and makes configurations safe to pass between functions without defensive copying.</p> <p>Every simulation in BORES requires a <code>Config</code>. You pass it (along with a reservoir model) to <code>bores.run()</code> to start the simulation. The <code>Config</code> is the single point of control for all numerical behavior. If two simulations use different schemes, solvers, or convergence criteria, those differences are captured entirely in their respective <code>Config</code> objects.</p>"},{"location":"user-guide/config/#creating-a-config","title":"Creating a Config","text":"<p>At minimum, a <code>Config</code> requires a <code>Timer</code> and a <code>RockFluidTables</code>:</p> <pre><code>import bores\n\nrock_fluid = bores.RockFluidTables(\n    relative_permeability_table=bores.BrooksCoreyThreePhaseRelPermModel(\n        water_exponent=2.5,\n        oil_exponent=2.0,\n        gas_exponent=2.0,\n    ),\n    capillary_pressure_table=bores.BrooksCoreyCapillaryPressureModel(),\n)\n\nconfig = bores.Config(\n    timer=bores.Timer(\n        initial_step_size=bores.Time(days=1),\n        max_step_size=bores.Time(days=10),\n        min_step_size=bores.Time(hours=1),\n        simulation_time=bores.Time(years=3),\n    ),\n    rock_fluid_tables=rock_fluid,\n)\n</code></pre> <p>This creates a valid configuration with all defaults. The IMPES scheme, BiCGSTAB solver with ILU preconditioning, and standard convergence tolerances are used automatically.</p>"},{"location":"user-guide/config/#adding-wells","title":"Adding Wells","text":"<p>Most simulations include wells. Pass them through the <code>wells</code> parameter:</p> <pre><code>wells = bores.wells_(injectors=[injector], producers=[producer])\n\nconfig = bores.Config(\n    timer=bores.Timer(\n        initial_step_size=bores.Time(days=1),\n        max_step_size=bores.Time(days=10),\n        min_step_size=bores.Time(hours=1),\n        simulation_time=bores.Time(years=3),\n    ),\n    rock_fluid_tables=rock_fluid,\n    wells=wells,\n)\n</code></pre>"},{"location":"user-guide/config/#adding-well-schedules","title":"Adding Well Schedules","text":"<p>For simulations with time-varying well controls, use <code>well_schedules</code>:</p> <pre><code>config = bores.Config(\n    timer=timer,\n    rock_fluid_tables=rock_fluid,\n    well_schedules=schedules,\n)\n</code></pre> <p>When <code>well_schedules</code> is provided, the simulator automatically switches well controls at the scheduled times. See the Well Scheduling page for details.</p>"},{"location":"user-guide/config/#adding-boundary-conditions","title":"Adding Boundary Conditions","text":"<p>Boundary conditions (aquifer support, constant pressure boundaries, etc.) are specified through the <code>boundary_conditions</code> parameter:</p> <pre><code>config = bores.Config(\n    timer=timer,\n    rock_fluid_tables=rock_fluid,\n    wells=wells,\n    boundary_conditions=boundary_conditions,\n)\n</code></pre>"},{"location":"user-guide/config/#all-config-parameters","title":"All Config Parameters","text":""},{"location":"user-guide/config/#required-parameters","title":"Required Parameters","text":"Parameter Type Description <code>timer</code> <code>Timer</code> Time stepping manager (initial/max/min step sizes, simulation time) <code>rock_fluid_tables</code> <code>RockFluidTables</code> Relative permeability and capillary pressure models"},{"location":"user-guide/config/#optional-model-parameters","title":"Optional Model Parameters","text":"Parameter Type Default Description <code>wells</code> <code>Wells</code> <code>None</code> Well configuration (injectors and producers) <code>well_schedules</code> <code>WellSchedules</code> <code>None</code> Dynamic well control schedules <code>boundary_conditions</code> <code>BoundaryConditions</code> <code>None</code> Boundary conditions (aquifers, constant pressure, etc.) <code>pvt_tables</code> <code>PVTTables</code> <code>None</code> Tabulated PVT properties (alternative to correlations) <code>constants</code> <code>Constants</code> Default Physical and conversion constants"},{"location":"user-guide/config/#numerical-scheme","title":"Numerical Scheme","text":"Parameter Type Default Description <code>scheme</code> <code>str</code> <code>\"impes\"</code> Evolution scheme: <code>\"impes\"</code>, <code>\"explicit\"</code>, or <code>\"implicit\"</code> <code>use_pseudo_pressure</code> <code>bool</code> <code>True</code> Use pseudo-pressure formulation for gas <p>See Schemes for detailed information on each evolution scheme.</p>"},{"location":"user-guide/config/#solver-configuration","title":"Solver Configuration","text":"Parameter Type Default Description <code>pressure_solver</code> <code>str</code> or list <code>\"bicgstab\"</code> Solver(s) for the pressure equation <code>saturation_solver</code> <code>str</code> or list <code>\"bicgstab\"</code> Solver(s) for the saturation equation <code>pressure_preconditioner</code> <code>str</code> or <code>None</code> <code>\"ilu\"</code> Preconditioner for pressure solvers <code>saturation_preconditioner</code> <code>str</code> or <code>None</code> <code>\"ilu\"</code> Preconditioner for saturation solvers <code>pressure_convergence_tolerance</code> <code>float</code> <code>1e-6</code> Relative convergence tolerance for pressure <code>saturation_convergence_tolerance</code> <code>float</code> <code>1e-4</code> Relative convergence tolerance for saturation <code>max_iterations</code> <code>int</code> <code>250</code> Maximum solver iterations per step (capped at 500) <p>See Solvers and Preconditioners for details.</p>"},{"location":"user-guide/config/#time-step-controls","title":"Time Step Controls","text":"Parameter Type Default Description <code>saturation_cfl_threshold</code> <code>float</code> <code>0.6</code> Maximum saturation CFL number <code>pressure_cfl_threshold</code> <code>float</code> <code>0.9</code> Maximum pressure CFL number <code>max_oil_saturation_change</code> <code>float</code> <code>0.2</code> Maximum oil saturation change per step <code>max_water_saturation_change</code> <code>float</code> <code>0.2</code> Maximum water saturation change per step <code>max_gas_saturation_change</code> <code>float</code> <code>0.1</code> Maximum gas saturation change per step <code>max_pressure_change</code> <code>float</code> <code>100.0</code> Maximum pressure change per step (psi) <p>Gas Saturation Change Limits</p> <p>The default <code>max_gas_saturation_change</code> of 0.1 is intentionally lenient. Gas saturation can change rapidly during solution gas liberation or gas injection, and tightening this limit forces very small timesteps that slow the simulation significantly without meaningful accuracy gains. Only lower this value when you specifically need fine resolution of gas saturation evolution, such as detailed gas coning studies or near-critical fluid behavior. For most simulations, leave it at the default or increase it further.</p> <p>See Time Step Control for guidance on adjusting these.</p>"},{"location":"user-guide/config/#physical-controls","title":"Physical Controls","text":"Parameter Type Default Description <code>capillary_strength_factor</code> <code>float</code> <code>1.0</code> Scale factor for capillary effects (0 to 1) <code>disable_capillary_effects</code> <code>bool</code> <code>False</code> Completely disable capillary pressure <code>disable_structural_dip</code> <code>bool</code> <code>False</code> Disable gravity/structural dip effects <code>miscibility_model</code> <code>str</code> <code>\"immiscible\"</code> Miscibility model: <code>\"immiscible\"</code> or <code>\"todd_longstaff\"</code> <code>freeze_saturation_pressure</code> <code>bool</code> <code>False</code> Keep bubble point pressure constant"},{"location":"user-guide/config/#fluid-mobility","title":"Fluid Mobility","text":"Parameter Type Default Description <code>relative_mobility_range</code> <code>RelativeMobilityRange</code> See below Min/max relative mobility per phase <code>total_compressibility_range</code> <code>Range</code> <code>(1e-24, 1e-2)</code> Min/max total compressibility <code>phase_appearance_tolerance</code> <code>float</code> <code>1e-6</code> Saturation below which a phase is absent <p>The default relative mobility ranges are:</p> <ul> <li>Oil: \\(10^{-9}\\) to \\(10^{6}\\)</li> <li>Water: \\(10^{-9}\\) to \\(10^{6}\\)</li> <li>Gas: \\(10^{-12}\\) to \\(10^{6}\\)</li> </ul> <p>These ranges prevent division by zero and numerical overflow in mobility calculations. You rarely need to change them.</p>"},{"location":"user-guide/config/#hysteresis","title":"Hysteresis","text":"Parameter Type Default Description <code>residual_oil_drainage_ratio_water_flood</code> <code>float</code> <code>0.6</code> Oil drainage residual ratio (waterflood) <code>residual_oil_drainage_ratio_gas_flood</code> <code>float</code> <code>0.6</code> Oil drainage residual ratio (gas flood) <code>residual_gas_drainage_ratio</code> <code>float</code> <code>0.5</code> Gas drainage residual ratio"},{"location":"user-guide/config/#output-and-logging","title":"Output and Logging","text":"Parameter Type Default Description <code>output_frequency</code> <code>int</code> <code>1</code> Yield a state every N steps <code>log_interval</code> <code>int</code> <code>5</code> Log progress every N steps <code>warn_well_anomalies</code> <code>bool</code> <code>True</code> Warn about anomalous well flow rates"},{"location":"user-guide/config/#modifying-a-config","title":"Modifying a Config","text":"<p>Since <code>Config</code> is immutable, you cannot modify fields directly. Use <code>copy()</code> or <code>with_updates()</code> to create modified versions:</p>"},{"location":"user-guide/config/#copy","title":"copy()","text":"<pre><code># Create a new config with a different scheme\nimplicit_config = config.copy(scheme=\"implicit\")\n\n# Multiple changes at once\ntuned_config = config.copy(\n    scheme=\"implicit\",\n    pressure_solver=\"gmres\",\n    pressure_preconditioner=\"amg\",\n    max_iterations=400,\n)\n</code></pre>"},{"location":"user-guide/config/#with_updates","title":"with_updates()","text":"<p><code>with_updates()</code> works the same way as <code>copy()</code> but validates that all provided keys are valid <code>Config</code> attributes:</p> <pre><code># This works\nupdated = config.with_updates(scheme=\"implicit\")\n\n# This raises AttributeError because \"schemee\" is not a valid field\nupdated = config.with_updates(schemee=\"implicit\")  # AttributeError\n</code></pre> <p>Use <code>with_updates()</code> when you want protection against typos in parameter names. Use <code>copy()</code> when you prefer the shorter name and are confident in the parameter names.</p>"},{"location":"user-guide/config/#freeze-saturation-pressure","title":"Freeze Saturation Pressure","text":"<p>The <code>freeze_saturation_pressure</code> flag controls whether the oil bubble point pressure (Pb) is recomputed at each time step or held constant at its initial value.</p> <pre><code># Keep Pb constant (standard black-oil assumption)\nconfig = bores.Config(\n    timer=timer,\n    rock_fluid_tables=rock_fluid,\n    wells=wells,\n    freeze_saturation_pressure=True,\n)\n</code></pre> <p>When <code>freeze_saturation_pressure=True</code>, the following properties are computed using the initial bubble point pressure rather than a dynamically updated value:</p> <ul> <li>Bubble point pressure (Pb) itself</li> <li>Solution gas-oil ratio (Rs)</li> <li>Oil formation volume factor (Bo)</li> <li>Oil compressibility (Co)</li> <li>Oil viscosity (indirectly through Rs)</li> <li>Oil density (indirectly through Rs and Bo)</li> </ul> <p>This is appropriate for natural depletion and waterflooding where oil composition remains constant. Set it to <code>False</code> (the default) for miscible injection or any process where dissolved gas content changes significantly during the simulation.</p>"},{"location":"user-guide/config/#capillary-strength-factor","title":"Capillary Strength Factor","text":"<p>The <code>capillary_strength_factor</code> scales capillary pressure effects without changing the capillary pressure model itself. It ranges from 0.0 (no capillary effects) to 1.0 (full capillary effects).</p> <pre><code># Reduce capillary effects by 50% for numerical stability\nconfig = bores.Config(\n    timer=timer,\n    rock_fluid_tables=rock_fluid,\n    wells=wells,\n    capillary_strength_factor=0.5,\n)\n</code></pre> <p>Capillary gradients can become numerically dominant in fine meshes or at sharp saturation fronts, causing oscillations or overshoot. Reducing the capillary strength factor damps these effects without removing them entirely. This is a common technique for improving convergence in difficult models while preserving the qualitative influence of capillary pressure on fluid distribution.</p> <p>Setting <code>disable_capillary_effects=True</code> is equivalent to <code>capillary_strength_factor=0.0</code> but is more explicit in intent.</p>"},{"location":"user-guide/config/#example-configurations","title":"Example Configurations","text":""},{"location":"user-guide/config/#simple-depletion-study","title":"Simple Depletion Study","text":"<pre><code>config = bores.Config(\n    timer=bores.Timer(\n        initial_step_size=bores.Time(days=2),\n        max_step_size=bores.Time(days=30),\n        min_step_size=bores.Time(days=1),\n        simulation_time=bores.Time(years=10),\n    ),\n    rock_fluid_tables=rock_fluid,\n    wells=wells,\n    freeze_saturation_pressure=True,\n)\n</code></pre>"},{"location":"user-guide/config/#high-resolution-waterflood","title":"High-Resolution Waterflood","text":"<pre><code>config = bores.Config(\n    timer=bores.Timer(\n        initial_step_size=bores.Time(days=0.5),\n        max_step_size=bores.Time(days=5),\n        min_step_size=bores.Time(hours=1),\n        simulation_time=bores.Time(years=5),\n    ),\n    rock_fluid_tables=rock_fluid,\n    wells=wells,\n    pressure_solver=\"gmres\",\n    pressure_preconditioner=\"amg\",\n    max_water_saturation_change=0.15,\n    max_pressure_change=50.0,\n)\n</code></pre>"},{"location":"user-guide/config/#miscible-gas-injection","title":"Miscible Gas Injection","text":"<pre><code>config = bores.Config(\n    timer=bores.Timer(\n        initial_step_size=bores.Time(hours=6),\n        max_step_size=bores.Time(days=3),\n        min_step_size=bores.Time(minutes=30),\n        simulation_time=bores.Time(years=3),\n    ),\n    rock_fluid_tables=rock_fluid,\n    wells=wells,\n    miscibility_model=\"todd_longstaff\",\n    freeze_saturation_pressure=False,\n    max_pressure_change=75.0,\n)\n</code></pre>"},{"location":"user-guide/constants/","title":"Constants","text":""},{"location":"user-guide/constants/#overview","title":"Overview","text":"<p>BORES uses a system of physical constants and unit conversion factors throughout its calculations. These constants cover standard conditions (pressure, temperature), fluid densities, molecular weights, conversion factors between SI and imperial units, and numerical thresholds that control simulation behavior. Rather than scattering magic numbers throughout the code, all constants are centralized in a <code>Constants</code> class that you can inspect, modify, and even temporarily override during a simulation.</p> <p>The constants system is designed around the reservoir engineering convention of using imperial (oilfield) units internally: pressures in psi, temperatures in Fahrenheit, permeabilities in millidarcies, viscosities in centipoise, and volumes in barrels and cubic feet. Conversion factors to SI units are provided for every quantity so you can work in whichever system you prefer for input and output.</p> <p>Understanding the constants is important for two reasons. First, if your reservoir uses non-standard conditions (for example, a different standard temperature or salinity), you can adjust the constants to match. Second, when debugging unexpected results, checking whether the correct constants are being used can quickly identify unit conversion errors.</p>"},{"location":"user-guide/constants/#the-global-constants-proxy","title":"The Global Constants Proxy","text":"<p>BORES provides a global constants proxy <code>c</code> that gives direct access to all default constant values. You can import and use it anywhere:</p> <pre><code>from bores.constants import c\n\n# Access constant values with dot notation\nprint(c.STANDARD_PRESSURE_IMPERIAL)       # 14.696\nprint(c.STANDARD_TEMPERATURE_IMPERIAL)    # 60.0\nprint(c.MOLECULAR_WEIGHT_CO2)             # 44.01\nprint(c.BARRELS_TO_CUBIC_FEET)            # 5.614583\n</code></pre> <p>The proxy automatically returns the unwrapped value of each constant. If you need the full <code>Constant</code> object (with description and unit metadata), use bracket notation:</p> <pre><code>from bores.constants import c\n\nconst = c[\"STANDARD_PRESSURE_IMPERIAL\"]\nprint(const.value)        # 14.696\nprint(const.description)  # \"Standard atmospheric pressure (Imperial units)\"\nprint(const.unit)         # \"psi\"\n</code></pre> <p>You can also use <code>get_constant()</code> for safe access with a default:</p> <pre><code>from bores.constants import get_constant\n\nconst = get_constant(\"STANDARD_PRESSURE_IMPERIAL\")\nif const is not None:\n    print(f\"{const.description}: {const.value} {const.unit}\")\n</code></pre>"},{"location":"user-guide/constants/#available-constants","title":"Available Constants","text":""},{"location":"user-guide/constants/#standard-conditions","title":"Standard Conditions","text":"Constant Value Unit Description <code>STANDARD_PRESSURE</code> 101325 Pa Standard atmospheric pressure (SI) <code>STANDARD_PRESSURE_IMPERIAL</code> 14.696 psi Standard atmospheric pressure (Imperial) <code>STANDARD_TEMPERATURE</code> 288.7056 K Standard temperature 15.6C (SI) <code>STANDARD_TEMPERATURE_IMPERIAL</code> 60.0 F Standard temperature (Imperial) <code>STANDARD_TEMPERATURE_RANKINE</code> 518.67 R Standard temperature (Rankine) <code>STANDARD_TEMPERATURE_CELSIUS</code> 15.6 C Standard temperature (Celsius)"},{"location":"user-guide/constants/#standard-densities","title":"Standard Densities","text":"Constant Value Unit Description <code>STANDARD_WATER_DENSITY</code> 998.2 kg/m3 Water density at standard conditions (SI) <code>STANDARD_WATER_DENSITY_IMPERIAL</code> 62.37 lb/ft3 Water density at standard conditions (Imperial) <code>STANDARD_AIR_DENSITY</code> 1.225 kg/m3 Air density at standard conditions (SI) <code>STANDARD_AIR_DENSITY_IMPERIAL</code> 0.0765 lb/ft3 Air density at standard conditions (Imperial)"},{"location":"user-guide/constants/#molecular-weights","title":"Molecular Weights","text":"Constant Value Unit Description <code>MOLECULAR_WEIGHT_WATER</code> 18.015 g/mol Water (H2O) <code>MOLECULAR_WEIGHT_CO2</code> 44.01 g/mol Carbon dioxide <code>MOLECULAR_WEIGHT_N2</code> 28.013 g/mol Nitrogen <code>MOLECULAR_WEIGHT_CH4</code> 16.042 g/mol Methane <code>MOLECULAR_WEIGHT_AIR</code> 28.964 g/mol Air <code>MOLECULAR_WEIGHT_H2</code> 2.016 g/mol Hydrogen <code>MOLECULAR_WEIGHT_O2</code> 31.999 g/mol Oxygen <code>MOLECULAR_WEIGHT_NACL</code> 58.44 g/mol Sodium chloride <code>MOLECULAR_WEIGHT_HELIUM</code> 4.003 g/mol Helium <code>MOLECULAR_WEIGHT_ARGON</code> 39.948 g/mol Argon"},{"location":"user-guide/constants/#thermal-and-compressibility-properties","title":"Thermal and Compressibility Properties","text":"Constant Value Unit Description <code>OIL_THERMAL_EXPANSION_COEFFICIENT</code> 9.7e-4 1/K Oil thermal expansion (SI) <code>OIL_THERMAL_EXPANSION_COEFFICIENT_IMPERIAL</code> 5.39e-4 1/F Oil thermal expansion (Imperial) <code>WATER_THERMAL_EXPANSION_COEFFICIENT</code> 3.0e-4 1/K Water thermal expansion (SI) <code>WATER_THERMAL_EXPANSION_COEFFICIENT_IMPERIAL</code> 1.67e-4 1/F Water thermal expansion (Imperial) <code>WATER_ISOTHERMAL_COMPRESSIBILITY</code> 4.6e-10 1/Pa Water compressibility (SI) <code>WATER_ISOTHERMAL_COMPRESSIBILITY_IMPERIAL</code> 3.17e-6 1/psi Water compressibility (Imperial)"},{"location":"user-guide/constants/#gas-constant","title":"Gas Constant","text":"Constant Value Unit Description <code>IDEAL_GAS_CONSTANT</code> 8.314 J/(mol K) Universal gas constant <code>IDEAL_GAS_CONSTANT_SI</code> 8.314e-3 kJ/(mol K) Gas constant (SI, kJ) <code>IDEAL_GAS_CONSTANT_IMPERIAL</code> 10.732 ft3 psi/(lb mol R) Gas constant (Imperial)"},{"location":"user-guide/constants/#pressure-conversions","title":"Pressure Conversions","text":"Constant Value Description <code>PSI_TO_PASCAL</code> 6894.757 psi to Pa <code>PASCAL_TO_PSI</code> 1.450e-4 Pa to psi <code>PSI_TO_BAR</code> 0.06895 psi to bar"},{"location":"user-guide/constants/#temperature-conversions","title":"Temperature Conversions","text":"Constant Value Description <code>RANKINE_TO_KELVIN</code> 0.5556 Rankine to Kelvin <code>KELVIN_TO_RANKINE</code> 1.8 Kelvin to Rankine"},{"location":"user-guide/constants/#viscosity-conversions","title":"Viscosity Conversions","text":"Constant Value Description <code>CENTIPOISE_TO_PASCAL_SECONDS</code> 0.001 cP to Pa s <code>PASCAL_SECONDS_TO_CENTIPOISE</code> 1000 Pa s to cP"},{"location":"user-guide/constants/#permeability-conversions","title":"Permeability Conversions","text":"Constant Value Description <code>MILLIDARCY_TO_SQUARE_METER</code> 9.869e-16 mD to m2"},{"location":"user-guide/constants/#volume-conversions","title":"Volume Conversions","text":"Constant Value Description <code>BARRELS_TO_CUBIC_FEET</code> 5.6146 BBL to ft3 <code>CUBIC_FEET_TO_BARRELS</code> 0.1781 ft3 to BBL <code>STB_TO_CUBIC_FEET</code> 5.6146 STB to ft3 <code>STB_TO_CUBIC_METER</code> 0.1590 STB to m3 <code>CUBIC_METER_TO_STB</code> 6.2898 m3 to STB <code>SCF_TO_BARRELS</code> 0.1781 SCF to BBL <code>CUBIC_METER_TO_SCF</code> 35.315 m3 to SCF <code>SCF_TO_SCM</code> 0.02832 SCF to m3 <code>ACRE_FOOT_TO_CUBIC_FEET</code> 43560 acre-ft to ft3 <code>ACRE_FOOT_TO_BARRELS</code> 7758 acre-ft to BBL <code>ACRES_TO_SQUARE_FEET</code> 43560 acres to ft2"},{"location":"user-guide/constants/#length-conversions","title":"Length Conversions","text":"Constant Value Description <code>FT_TO_METERS</code> 0.3048 ft to m <code>METERS_TO_FT</code> 3.2808 m to ft <code>INCHES_TO_METERS</code> 0.0254 in to m"},{"location":"user-guide/constants/#time-conversions","title":"Time Conversions","text":"Constant Value Description <code>SECONDS_PER_DAY</code> 86400 Seconds in a day <code>DAYS_PER_YEAR</code> 365.25 Days in a year <code>MONTHS_PER_YEAR</code> 12 Months in a year <code>SECONDS_PER_YEAR</code> 31557600 Seconds in a year"},{"location":"user-guide/constants/#flow-rate-conversions","title":"Flow Rate Conversions","text":"Constant Value Description <code>CUBIC_METER_PER_SECOND_TO_STB_PER_DAY</code> 543168.4 m3/s to STB/day <code>STB_PER_DAY_TO_CUBIC_METER_PER_SECOND</code> 1.841e-6 STB/day to m3/s"},{"location":"user-guide/constants/#transmissibility-conversions","title":"Transmissibility Conversions","text":"Constant Value Description <code>MILLIDARCIES_PER_CENTIPOISE_TO_SQUARE_FEET_PER_PSI_PER_DAY</code> 0.001127 Darcy transmissibility conversion"},{"location":"user-guide/constants/#gravity","title":"Gravity","text":"Constant Value Unit Description <code>ACCELERATION_DUE_TO_GRAVITY_METER_PER_SECONDS_SQUARE</code> 9.807 m/s2 Standard gravity (SI) <code>ACCELERATION_DUE_TO_GRAVITY_FEET_PER_SECONDS_SQUARE</code> 32.174 ft/s2 Standard gravity (Imperial) <code>GRAVITATIONAL_CONSTANT_LBM_FT_PER_LBF_S2</code> 32.174 lbm ft/(lbf s2) gc conversion factor"},{"location":"user-guide/constants/#numerical-thresholds","title":"Numerical Thresholds","text":"Constant Value Description <code>SATURATION_EPSILON</code> 1e-6 Prevents numerical issues at S=0 or S=1 <code>MINIMUM_TRANSMISSIBILITY_FACTOR</code> 1e-12 Floor for transmissibility values <code>GAS_SOLUBILITY_TOLERANCE</code> 1e-6 Tolerance for gas solubility calculations <code>GAS_PSEUDO_PRESSURE_THRESHOLD</code> 0.0 Pressure above which pseudo-pressure is used <code>GAS_PSEUDO_PRESSURE_POINTS</code> 200 Points in pseudo-pressure table <code>DEFAULT_WATER_SALINITY_PPM</code> 35000 Default water salinity (ppm NaCl) <code>MIN_OIL_ZONE_THICKNESS</code> 5 Minimum oil zone thickness warning (ft)"},{"location":"user-guide/constants/#valid-ranges","title":"Valid Ranges","text":"Constant Value Unit Description <code>MINIMUM_VALID_PRESSURE</code> 14.5 psi Floor for reservoir pressures <code>MAXIMUM_VALID_PRESSURE</code> 14700 psi Ceiling for reservoir pressures <code>MINIMUM_VALID_TEMPERATURE</code> 32 F Floor for reservoir temperatures <code>MAXIMUM_VALID_TEMPERATURE</code> 482 F Ceiling for reservoir temperatures"},{"location":"user-guide/constants/#the-constants-class","title":"The Constants Class","text":"<p>The <code>Constants</code> class is a dictionary-like container that stores all constants as <code>Constant</code> objects. Each <code>Constant</code> wraps a value with optional description and unit metadata.</p> <pre><code>from bores.constants import Constants, Constant\n\n# Create with default constants\nconstants = Constants()\n\n# Access a value\nprint(constants.STANDARD_PRESSURE_IMPERIAL)  # 14.696\n\n# Access the full Constant object\nconst = constants[\"STANDARD_PRESSURE_IMPERIAL\"]\nprint(const)  # Constant(value=14.696, description='...', unit='psi')\n</code></pre>"},{"location":"user-guide/constants/#modifying-constants","title":"Modifying Constants","text":"<p>You can modify constants at runtime using dot notation or bracket notation:</p> <pre><code>from bores.constants import Constants, Constant\n\nconstants = Constants()\n\n# Set a raw value (auto-wrapped in Constant)\nconstants.DEFAULT_WATER_SALINITY_PPM = 50000\n\n# Set with full metadata\nconstants[\"MY_CUSTOM_VALUE\"] = Constant(\n    value=42.0,\n    description=\"Custom parameter for my model\",\n    unit=\"psi\",\n)\n</code></pre>"},{"location":"user-guide/constants/#using-custom-constants-in-a-simulation","title":"Using Custom Constants in a Simulation","text":"<p>The <code>Config</code> accepts a <code>Constants</code> instance, allowing you to customize constants for a specific simulation:</p> <pre><code>from bores.constants import Constants\n\n# Create custom constants\ncustom = Constants()\ncustom.DEFAULT_WATER_SALINITY_PPM = 100000  # Very saline formation water\n\nconfig = bores.Config(\n    timer=timer,\n    rock_fluid_tables=rock_fluid,\n    wells=wells,\n    constants=custom,\n)\n</code></pre>"},{"location":"user-guide/constants/#temporary-constants-override","title":"Temporary Constants Override","text":"<p>For temporary overrides, use the <code>Constants</code> instance as a context manager. Within the context, the global proxy <code>c</code> points to your custom constants. Outside, the defaults are restored:</p> <pre><code>from bores.constants import Constants, c\n\n# Create custom constants\ncustom = Constants()\ncustom.STANDARD_TEMPERATURE_IMPERIAL = 70.0  # Different standard temp\n\n# Temporarily override global constants\nwith custom():\n    print(c.STANDARD_TEMPERATURE_IMPERIAL)  # 70.0\n    # All BORES functions called here use 70 F as standard temperature\n\n# Outside the context, original defaults are restored\nprint(c.STANDARD_TEMPERATURE_IMPERIAL)  # 60.0\n</code></pre> <p>This mechanism uses Python's <code>ContextVar</code> system and is thread-safe. Each thread maintains its own constants context, so overrides in one thread do not affect other threads.</p>"},{"location":"user-guide/constants/#iterating-over-constants","title":"Iterating Over Constants","text":"<p>The <code>Constants</code> class supports iteration, length, and containment checks:</p> <pre><code>from bores.constants import Constants\n\nconstants = Constants()\n\n# Count all constants\nprint(len(constants))  # Number of defined constants\n\n# Check if a constant exists\nif \"MOLECULAR_WEIGHT_CO2\" in constants:\n    print(\"CO2 molecular weight is defined\")\n\n# Iterate over all constant names\nfor name in constants:\n    print(name)\n\n# Iterate over name-value pairs\nfor name, const in constants.items():\n    print(f\"{name}: {const.value} {const.unit or ''}\")\n</code></pre>"},{"location":"user-guide/constants/#creating-custom-constants","title":"Creating Custom Constants","text":"<p>You can define your own <code>Constant</code> objects for project-specific parameters:</p> <pre><code>from bores.constants import Constant, Constants\n\n# Create a Constants instance with custom values\nproject_constants = Constants()\nproject_constants[\"FORMATION_WATER_VISCOSITY\"] = Constant(\n    value=0.7,\n    description=\"Measured formation water viscosity at reservoir conditions\",\n    unit=\"cP\",\n)\nproject_constants[\"INJECTION_WATER_VISCOSITY\"] = Constant(\n    value=0.5,\n    description=\"Treated injection water viscosity\",\n    unit=\"cP\",\n)\n</code></pre> <p>Custom constants coexist with the default constants. You can use them to store project-specific parameters alongside the standard physical constants, keeping all numerical values in one inspectable location.</p>"},{"location":"user-guide/fluid-properties/","title":"Fluid Properties","text":""},{"location":"user-guide/fluid-properties/#overview","title":"Overview","text":"<p>Fluid properties describe how oil, gas, and water behave at reservoir conditions. In petroleum engineering, these are called PVT (Pressure-Volume-Temperature) properties because they depend primarily on pressure and temperature. BORES computes most PVT properties automatically from a few key inputs using industry-standard correlations.</p> <p>You do not need to supply every fluid property manually. When you call <code>bores.reservoir_model()</code>, the factory estimates formation volume factors, solution gas-oil ratio, gas compressibility factor, densities, and other derived properties from the inputs you provide: pressure, temperature, oil specific gravity (or API gravity), and gas specific gravity. This design lets you build a complete model from commonly available field data without needing a full PVT laboratory report.</p> <p>If you do have laboratory PVT data or equation-of-state results, you can provide them as PVT tables instead of relying on correlations. See PVT Tables for that workflow.</p>"},{"location":"user-guide/fluid-properties/#oil-properties","title":"Oil Properties","text":"<p>Oil properties are the most complex because they depend on whether gas is dissolved in the oil (saturated) or all gas is in solution (undersaturated).</p>"},{"location":"user-guide/fluid-properties/#key-oil-inputs","title":"Key Oil Inputs","text":"Parameter Units Typical Range Description <code>oil_specific_gravity_grid</code> dimensionless 0.75 - 0.95 Oil specific gravity relative to water <code>oil_viscosity_grid</code> cP 0.5 - 100+ Dead oil viscosity at reservoir temperature <code>oil_bubble_point_pressure_grid</code> psi 500 - 5000 Pressure below which gas liberates from oil <pre><code>import bores\n\ngrid_shape = (20, 20, 5)\n\noil_sg = bores.build_uniform_grid(grid_shape, value=0.85)        # ~35 API\noil_visc = bores.build_uniform_grid(grid_shape, value=1.5)       # cP\nbubble_pt = bores.build_uniform_grid(grid_shape, value=2500.0)   # psi\n</code></pre> <p>The oil specific gravity of 0.85 corresponds to about 35 degrees API, which is a light crude oil. API gravity and specific gravity are related by:</p> \\[\\text{API} = \\frac{141.5}{\\gamma_o} - 131.5\\]"},{"location":"user-guide/fluid-properties/#properties-computed-by-the-factory","title":"Properties Computed by the Factory","text":"<p>From your oil inputs plus pressure and temperature, <code>bores.reservoir_model()</code> computes:</p> <ul> <li>Solution gas-oil ratio (\\(R_s\\)): Volume of gas dissolved per volume of oil at surface conditions (SCF/STB). Uses the Standing correlation.</li> <li>Oil formation volume factor (\\(B_o\\)): Ratio of oil volume at reservoir conditions to surface conditions (RB/STB). Accounts for dissolved gas expansion. Uses Standing or Vasquez-Beggs.</li> <li>Oil compressibility (\\(c_o\\)): Isothermal compressibility of oil (psi\\(^{-1}\\)).</li> <li>Oil density: Computed from specific gravity, \\(B_o\\), and \\(R_s\\).</li> <li>Live oil viscosity: Adjusted from dead oil viscosity for dissolved gas using the Beggs-Robinson correlation.</li> </ul>"},{"location":"user-guide/fluid-properties/#gas-properties","title":"Gas Properties","text":"<p>Gas behavior is described by the real gas law, where the compressibility factor \\(Z\\) accounts for deviations from ideal gas behavior.</p>"},{"location":"user-guide/fluid-properties/#key-gas-inputs","title":"Key Gas Inputs","text":"Parameter Units Typical Range Description <code>gas_specific_gravity</code> dimensionless 0.55 - 1.5 Gas gravity relative to air (methane ~ 0.55) <pre><code>model = bores.reservoir_model(\n    # ... other parameters ...\n    gas_specific_gravity=0.65,  # Light hydrocarbon gas\n)\n</code></pre>"},{"location":"user-guide/fluid-properties/#properties-computed-by-the-factory_1","title":"Properties Computed by the Factory","text":"<ul> <li>Gas compressibility factor (\\(Z\\)): Standing-Katz or Hall-Yarborough correlation.</li> <li>Gas formation volume factor (\\(B_g\\)): RB/SCF. Computed from \\(Z\\), \\(p\\), and \\(T\\).</li> <li>Gas viscosity (\\(\\mu_g\\)): Lee-Gonzalez-Eakin correlation.</li> <li>Gas density: Computed from molecular weight, \\(Z\\), \\(p\\), and \\(T\\).</li> </ul> <p>Gas Gravity Values</p> <p>Common gas specific gravities:</p> <ul> <li>Methane (CH4): 0.553</li> <li>Natural gas (typical): 0.60 - 0.75</li> <li>CO2: 1.52</li> <li>Nitrogen (N2): 0.967</li> </ul>"},{"location":"user-guide/fluid-properties/#water-properties","title":"Water Properties","text":"<p>Water is typically the simplest phase. BORES computes water properties from the water specific gravity and reservoir conditions.</p> <pre><code>model = bores.reservoir_model(\n    # ... other parameters ...\n    water_specific_gravity=1.02,  # Slightly saline formation water\n)\n</code></pre> <p>BORES computes water formation volume factor (\\(B_w\\)), water compressibility (\\(c_w\\)), water viscosity (\\(\\mu_w\\)), and water density from the specific gravity and reservoir conditions.</p> <p>Default Water Properties</p> <p>If you do not specify <code>water_specific_gravity</code>, BORES defaults to 1.0 (fresh water). For saline formation water, typical values range from 1.01 to 1.15 depending on salinity.</p>"},{"location":"user-guide/fluid-properties/#pvt-correlations","title":"PVT Correlations","text":"<p>BORES uses the following industry-standard correlations:</p> Property Correlation Reference Bubble point pressure Standing (1947) Standing, M.B. Solution GOR (\\(R_s\\)) Standing (1947) Standing, M.B. Oil FVF (\\(B_o\\)) Standing / Vasquez-Beggs Vasquez and Beggs (1980) Oil compressibility Vasquez-Beggs Vasquez and Beggs (1980) Dead oil viscosity Beggs-Robinson Beggs and Robinson (1975) Live oil viscosity Beggs-Robinson Beggs and Robinson (1975) Gas Z-factor Hall-Yarborough/Dranchuk-Abou-Kazeem Hall and Yarborough (1973) Gas viscosity Lee-Gonzalez-Eakin Lee, Gonzalez, Eakin (1966) Water properties McCain McCain (1990) <p>These correlations are implemented in <code>bores.correlations</code> as both scalar functions (in <code>core.py</code>) and vectorized array functions (in <code>arrays.py</code>) for grid-wide evaluation.</p>"},{"location":"user-guide/fluid-properties/#how-reservoir_model-works","title":"How reservoir_model() Works","text":"<p>The <code>bores.reservoir_model()</code> factory follows this sequence:</p> <ol> <li>Validate inputs: Check grid shapes match, saturations sum to 1, values are in physical ranges.</li> <li>Estimate missing oil properties: From oil specific gravity, viscosity, and bubble point, compute \\(R_s\\), \\(B_o\\), \\(c_o\\), density, and live oil viscosity using PVT correlations.</li> <li>Estimate gas properties: From gas specific gravity and reservoir conditions, compute \\(Z\\), \\(B_g\\), \\(\\mu_g\\), and gas density.</li> <li>Estimate water properties: From water specific gravity, compute \\(B_w\\), \\(c_w\\), \\(\\mu_w\\), and water density.</li> <li>Build the grid: Construct the internal grid data structure with transmissibilities and cell volumes.</li> <li>Return the model: An immutable <code>ReservoirModel</code> object.</li> </ol> <p>You can override any computed property by providing it explicitly. For example, if you have lab-measured gas viscosity, pass <code>gas_viscosity_grid</code> and BORES will use your values instead of the Lee-Gonzalez correlation.</p>"},{"location":"user-guide/fluid-properties/#accessing-fluid-properties","title":"Accessing Fluid Properties","text":"<p>After building the model, you can inspect all computed fluid properties:</p> <pre><code>import bores\n\nmodel = bores.reservoir_model(...)\n\n# Oil properties\nRs = model.fluid_properties.solution_gas_oil_ratio_grid    # SCF/STB\nBo = model.fluid_properties.oil_formation_volume_factor_grid  # RB/STB\noil_density = model.fluid_properties.oil_density_grid       # lbm/ft3\n\n# Gas properties\nBg = model.fluid_properties.gas_formation_volume_factor_grid  # RB/SCF\nz_factor = model.fluid_properties.gas_compressibility_factor_grid\n\n# Pressure and saturation\npressure = model.fluid_properties.pressure_grid\nSo = model.fluid_properties.oil_saturation_grid\nSw = model.fluid_properties.water_saturation_grid\nSg = model.fluid_properties.gas_saturation_grid\n</code></pre> <p>All properties are NumPy arrays with the same shape as your grid.</p> <p>Correlation Limitations</p> <p>PVT correlations are empirical fits to experimental data and have limited accuracy. They work well for conventional light-to-medium oils (25-45 API) with hydrocarbon gases. For heavy oils (below 20 API), CO2-rich systems, or near-critical fluids, consider using PVT tables from equation-of-state calculations or laboratory measurements. See PVT Tables for details.</p>"},{"location":"user-guide/grids/","title":"Grids","text":""},{"location":"user-guide/grids/#overview","title":"Overview","text":"<p>In BORES, the reservoir is divided into a structured Cartesian grid of rectangular cells. Each cell stores properties like porosity, permeability, pressure, and saturation at its center. Fluxes between cells are computed at the shared faces between adjacent cells. The grid is the foundation of every simulation - before you can run anything, you need to build property grids that describe your reservoir.</p> <p>BORES provides several utility functions for constructing grids. You can create uniform grids where every cell has the same value, layered grids where properties vary by geological layer, depth grids that track subsurface elevation, and saturation grids initialized from fluid contact depths. All grid functions return standard NumPy arrays, so you can also construct grids manually using any NumPy operation.</p> <p>The grid shape is always a tuple <code>(nx, ny, nz)</code> representing the number of cells in the x, y, and z directions. The z-axis points downward (depth increases with k-index), k=0 is the shallowest layer, and cell (0, 0, 0) is the top-left corner when viewed from above.</p>"},{"location":"user-guide/grids/#uniform-grids","title":"Uniform Grids","text":"<p>The simplest grid type fills every cell with the same value. Use <code>bores.build_uniform_grid()</code> for constant-property reservoirs or as a starting point that you modify later.</p> <pre><code>import bores\n\ngrid_shape = (20, 20, 5)\n\n# Every cell gets the same value\nporosity = bores.build_uniform_grid(grid_shape, value=0.22)\npressure = bores.build_uniform_grid(grid_shape, value=3500.0)  # psi\nthickness = bores.build_uniform_grid(grid_shape, value=15.0)   # ft per layer\n</code></pre> <p>The function returns a NumPy array of the specified shape, filled with the given value, using the currently active precision (float32 by default). You can also use the shorter alias <code>bores.uniform_grid()</code>.</p>"},{"location":"user-guide/grids/#layered-grids","title":"Layered Grids","text":"<p>Real reservoirs have properties that vary from layer to layer due to geological deposition. Use <code>bores.build_layered_grid()</code> to assign different values to each layer along a chosen axis.</p> <pre><code>import bores\n\ngrid_shape = (20, 20, 5)\n\n# Porosity decreasing with depth (5 layers along z)\nporosity = bores.build_layered_grid(\n    grid_shape,\n    layer_values=[0.25, 0.22, 0.20, 0.18, 0.15],\n    orientation=\"z\",\n)\n\n# Permeability varying along x-axis (20 layers along x)\nperm_x = bores.build_layered_grid(\n    grid_shape,\n    layer_values=[100 + i * 5 for i in range(20)],\n    orientation=\"x\",\n)\n</code></pre> <p>The <code>orientation</code> parameter selects the layering axis: <code>\"z\"</code> for vertical layering (most common), <code>\"x\"</code> for east-west variation, or <code>\"y\"</code> for north-south variation. The number of values in <code>layer_values</code> must match the number of cells along the chosen axis. You can also use the alias <code>bores.layered_grid()</code>.</p> <p>Combining Uniform and Layered</p> <p>You can build a base grid with <code>build_uniform_grid()</code> and then overwrite specific regions using NumPy slicing:</p> <pre><code>perm = bores.build_uniform_grid(grid_shape, value=100.0)\nperm[:, :, 3] = 10.0   # Low-permeability barrier in layer 3\nperm[:, :, 4] = 5.0    # Even tighter at the bottom\n</code></pre>"},{"location":"user-guide/grids/#depth-grids","title":"Depth Grids","text":"<p>A depth grid computes the true vertical depth of each cell center based on the thickness grid. BORES measures depth downward from the top of the reservoir.</p> <pre><code>import bores\n\ngrid_shape = (20, 20, 5)\nthickness = bores.build_uniform_grid(grid_shape, value=15.0)\n\n# Depth from top of reservoir (cell-center depths)\ndepth = bores.build_depth_grid(thickness)\n\n# For the top layer: depth = 15/2 = 7.5 ft\n# For layer 2: depth = 7.5 + 15/2 + 15/2 = 22.5 ft\n# And so on...\n</code></pre> <p>If you need absolute depths (referenced to a datum like sea level), add the top depth:</p> <pre><code>top_depth = 5000.0  # ft subsea\nabsolute_depth = depth + top_depth\n</code></pre> <p>For elevation measured upward from the base, use <code>bores.build_elevation_grid()</code> instead.</p> <p>Depth Convention</p> <p>BORES uses depth-positive convention: the z-axis points downward, k=0 is the shallowest layer, and depth increases with k-index. This matches the standard petroleum engineering convention.</p>"},{"location":"user-guide/grids/#structural-dip","title":"Structural Dip","text":"<p>Real reservoirs are rarely flat. Use <code>bores.apply_structural_dip()</code> to tilt an elevation or depth grid, simulating structural dip caused by tectonic forces.</p> <pre><code>import bores\nimport numpy as np\n\ngrid_shape = (20, 20, 5)\nthickness = bores.build_uniform_grid(grid_shape, value=15.0)\nelevation = bores.build_elevation_grid(thickness)\n\n# Apply a 5-degree dip toward the east (azimuth = 90 degrees)\ndipped = bores.apply_structural_dip(\n    elevation_grid=elevation,\n    dip_angle=5.0,           # degrees from horizontal\n    dip_azimuth=90.0,        # direction of dip (degrees from north)\n    cell_dimensions=(100.0, 100.0),  # (dx, dy) in feet\n)\n</code></pre> <p>The dip angle is measured from horizontal (0 = flat, 90 = vertical). The azimuth specifies the compass direction that the formation dips toward: 0 = north, 90 = east, 180 = south, 270 = west.</p> <p>Structural dip affects gravity-driven flow. In a dipping reservoir, gas migrates updip while water moves downdip. This is particularly important for gas injection simulations where gravity override interacts with the structural geometry.</p> <p>Dip and Grid Resolution</p> <p>Large dip angles with coarse grids can cause cells to have unrealistic geometry. Keep dip angles moderate (under 15-20 degrees) for standard Cartesian grids, or use finer grid resolution in the dip direction.</p>"},{"location":"user-guide/grids/#saturation-grids-from-fluid-contacts","title":"Saturation Grids from Fluid Contacts","text":"<p>The <code>bores.build_saturation_grids()</code> function computes physically consistent initial saturations from gas-oil contact (GOC) and oil-water contact (OWC) depths. This is the recommended way to initialize saturations because it ensures the constraint \\(S_o + S_w + S_g = 1.0\\) is satisfied everywhere and uses the correct residual saturations in each zone.</p> <pre><code>import bores\n\ngrid_shape = (20, 20, 5)\nthickness = bores.build_uniform_grid(grid_shape, value=15.0)\ndepth = bores.build_depth_grid(thickness) + 5000.0  # Absolute depth from datum\n\n# Residual saturation grids\nSwc  = bores.build_uniform_grid(grid_shape, value=0.25)\nSorw = bores.build_uniform_grid(grid_shape, value=0.30)\nSorg = bores.build_uniform_grid(grid_shape, value=0.15)\nSgr  = bores.build_uniform_grid(grid_shape, value=0.05)\nporosity = bores.build_uniform_grid(grid_shape, value=0.22)\n\n# Sharp contacts (no transition zones)\nSw, So, Sg = bores.build_saturation_grids(\n    depth_grid=depth,\n    gas_oil_contact=4950.0,       # GOC depth (ft)\n    oil_water_contact=5060.0,     # OWC depth (ft)\n    connate_water_saturation_grid=Swc,\n    residual_oil_saturation_water_grid=Sorw,\n    residual_oil_saturation_gas_grid=Sorg,\n    residual_gas_saturation_grid=Sgr,\n    porosity_grid=porosity,\n)\n</code></pre> <p>The function divides the reservoir into three zones based on depth:</p> <ul> <li>Gas cap (above GOC): \\(S_g = 1 - S_{or,g} - S_{wc}\\), \\(S_o = S_{or,g}\\), \\(S_w = S_{wc}\\)</li> <li>Oil zone (between GOC and OWC): \\(S_o = 1 - S_{wc} - S_{gr}\\), \\(S_w = S_{wc}\\), \\(S_g = S_{gr}\\)</li> <li>Water zone (below OWC): \\(S_w = 1 - S_{or,w}\\), \\(S_o = S_{or,w}\\), \\(S_g = 0\\)</li> </ul> <p>Notice that the function uses different residual oil saturations depending on the displacing fluid: \\(S_{or,g}\\) in the gas cap and \\(S_{or,w}\\) in the water zone.</p>"},{"location":"user-guide/grids/#transition-zones","title":"Transition Zones","text":"<p>For more realistic initialization, enable smooth saturation transitions at the contacts:</p> <pre><code>Sw, So, Sg = bores.build_saturation_grids(\n    depth_grid=depth,\n    gas_oil_contact=4950.0,\n    oil_water_contact=5060.0,\n    connate_water_saturation_grid=Swc,\n    residual_oil_saturation_water_grid=Sorw,\n    residual_oil_saturation_gas_grid=Sorg,\n    residual_gas_saturation_grid=Sgr,\n    porosity_grid=porosity,\n    use_transition_zones=True,\n    gas_oil_transition_thickness=10.0,   # ft\n    oil_water_transition_thickness=15.0, # ft\n    transition_curvature_exponent=2.0,   # Power-law shape\n)\n</code></pre> <p>The <code>transition_curvature_exponent</code> controls the shape of the saturation profile in the transition zone. Values less than 1 give abrupt transitions, 1 gives linear interpolation, and values greater than 1 give smoother S-shaped curves that better approximate capillary pressure effects.</p> <p>When to Use Transition Zones</p> <p>Transition zones are most important when your grid is fine enough to resolve the capillary fringe (cells smaller than the transition thickness). For coarse field-scale grids, sharp contacts are usually sufficient and avoid potential numerical artifacts from partially saturated cells.</p>"},{"location":"user-guide/grids/#grid-shape-conventions","title":"Grid Shape Conventions","text":"<p>BORES supports 1D, 2D, and 3D grids:</p> Dimensionality Grid Shape Example Use Case 1D <code>(100, 1, 1)</code> Buckley-Leverett displacement, core floods 2D areal <code>(50, 50, 1)</code> Pattern studies, sweep efficiency 2D cross-section <code>(100, 1, 10)</code> Gravity effects, layered reservoirs 3D <code>(30, 30, 10)</code> Full-field simulation <p>All property grids must have the same shape as the model's <code>grid_shape</code>. BORES validates this when you call <code>bores.reservoir_model()</code>.</p>"},{"location":"user-guide/grids/#visualizing-grids","title":"Visualizing Grids","text":"<p>You can visualize any property grid in 3D before running a simulation using the <code>bores.plotly3d.DataVisualizer</code> class. This is one of the most valuable debugging tools available to you, because it lets you catch setup errors before spending time on a simulation that will fail or produce nonsensical results.</p> <p>The <code>make_plot()</code> method accepts either a <code>ReservoirModel</code> (showing named properties like \"porosity\" or \"pressure\"), a <code>ModelState</code> (showing simulation results), or a raw NumPy array. When you pass a raw array, the visualizer renders it as a 3D volume with the grid geometry you provide. When you pass a model or state, you select the property by name.</p> <pre><code>import bores\n\n# Build a model first (see Rock Properties and Fluid Properties for full example)\nmodel = bores.reservoir_model(...)\n\n# Visualize a named property from the model\nviz = bores.plotly3d.DataVisualizer()\nfig = viz.make_plot(\n    source=model,\n    property=\"porosity\",\n    plot_type=\"volume\",\n    title=\"Porosity Distribution\",\n    opacity=0.7,\n)\nfig.show()\n# Output: [PLACEHOLDER: Insert porosity_3d_volume.png]\n</code></pre> <p>You can also visualize a raw grid array before you even build the model. This is useful for checking your porosity, permeability, or saturation grids during setup:</p> <pre><code>import bores\n\ngrid_shape = (20, 20, 5)\nthickness = bores.build_uniform_grid(grid_shape, value=15.0)\nporosity = bores.build_layered_grid(grid_shape, [0.25, 0.22, 0.18, 0.20, 0.15], \"z\")\n\nviz = bores.plotly3d.DataVisualizer()\nfig = viz.make_plot(\n    source=porosity,\n    plot_type=\"volume\",\n    title=\"Porosity Grid Check\",\n)\nfig.show()\n# Output: [PLACEHOLDER: Insert porosity_grid_check.png]\n</code></pre> <p>The 3D visualizer supports several plot types including <code>\"volume\"</code> (default, shows all cells as colored blocks), <code>\"isosurface\"</code> (shows surfaces of constant property value), and <code>\"slice\"</code> (shows a cross-section through the grid). For a complete guide to the visualization system, see the Visualization section.</p> <p>Always Visualize Before Running</p> <p>Before running any simulation, visualize at least your pressure, porosity, and permeability grids. Common mistakes include transposing dimensions, setting zero thickness in some cells, or placing wells outside the grid bounds. A few minutes of visual inspection can save hours of debugging cryptic simulation failures.</p>"},{"location":"user-guide/relative-permeability/","title":"Relative Permeability","text":""},{"location":"user-guide/relative-permeability/#what-is-relative-permeability","title":"What is Relative Permeability?","text":"<p>When a single fluid flows through porous rock, the flow rate is governed by Darcy's law and depends on the absolute permeability \\(k\\) of the rock. But real reservoirs contain multiple fluids - oil, water, and gas - competing for the same pore space. Each fluid does not have access to the full permeability of the rock. Instead, each phase flows through a fraction of the pore network, and the effective permeability available to each phase is lower than the absolute permeability. The ratio of a phase's effective permeability to the absolute permeability is called relative permeability.</p> <p>Relative permeability \\(k_{r\\alpha}\\) is a dimensionless number between 0 and 1 that describes how easily phase \\(\\alpha\\) flows relative to the rock's full permeability. It depends primarily on the saturation of each phase present in the pore space. When a phase's saturation is below its residual value, that phase is immobile and its relative permeability is zero. As the saturation increases, the phase gains access to more connected pathways through the pore network and its relative permeability increases. At very high saturation, the phase occupies most of the pore space and its relative permeability approaches its maximum (endpoint) value, which is typically less than 1.0 because even at high saturation, some pore throats remain occupied by the other phases.</p> <p>The mathematical form of relative permeability connects saturation to flow through the multiphase extension of Darcy's law:</p> \\[q_\\alpha = -\\frac{k \\cdot k_{r\\alpha}(S_\\alpha)}{\\mu_\\alpha} \\nabla p_\\alpha\\] <p>where \\(q_\\alpha\\) is the volumetric flux of phase \\(\\alpha\\), \\(k\\) is the absolute permeability, \\(k_{r\\alpha}\\) is the relative permeability of phase \\(\\alpha\\), \\(\\mu_\\alpha\\) is the viscosity, and \\(\\nabla p_\\alpha\\) is the pressure gradient. The ratio \\(k_{r\\alpha} / \\mu_\\alpha\\) is called the phase mobility \\(\\lambda_\\alpha\\), and it is this quantity that controls how fast each phase moves relative to the others. The mobility ratio between displacing and displaced fluids is the single most important number governing sweep efficiency in any displacement process.</p> <p>Relative permeability curves are among the most uncertain inputs to a reservoir simulation. They are measured in the laboratory using core flood experiments (steady-state or unsteady-state methods), but these measurements are expensive, time-consuming, and sensitive to experimental conditions. In practice, engineers often use analytical correlations (like Brooks-Corey) calibrated to a few measured endpoints, rather than full tabular curves. BORES supports both approaches.</p>"},{"location":"user-guide/relative-permeability/#saturation-endpoints","title":"Saturation Endpoints","text":"<p>Before configuring any relative permeability model, you need to understand the four critical saturation endpoints that define the boundaries of the mobile saturation range for each phase. These endpoints have a direct physical meaning tied to the pore-scale distribution of fluids.</p> <p>Irreducible water saturation (\\(S_{wc}\\) or \\(S_{wi}\\)) is the minimum water saturation that can exist in the reservoir. This water is trapped in the smallest pores and in thin films coating the rock grains (in water-wet rock). It cannot be displaced by oil or gas injection. Typical values range from 0.15 to 0.35, with lower values in well-sorted, coarse-grained rocks and higher values in fine-grained or shaly formations.</p> <p>Residual oil saturation to waterflood (\\(S_{or,w}\\)) is the oil left behind after water displaces oil. This oil is trapped as isolated ganglia in the pore network, held in place by capillary forces. Typical values range from 0.20 to 0.35 for water-wet sandstones. The residual oil saturation determines the maximum oil recovery achievable by waterflooding: \\(\\text{RF}_{max} = 1 - S_{wc} - S_{or,w}\\) as a fraction of original oil in place (assuming complete sweep).</p> <p>Residual oil saturation to gas flood (\\(S_{or,g}\\)) is the oil left behind after gas displaces oil. Gas typically achieves lower residual oil than water because of its lower viscosity and different pore-scale displacement mechanisms. Typical values range from 0.10 to 0.25.</p> <p>Residual gas saturation (\\(S_{gr}\\)) is the gas trapped after being displaced by liquid (oil or water). When rising oil or advancing water contacts a gas zone, some gas becomes trapped as disconnected bubbles. Typical values range from 0.03 to 0.10.</p> <p>Why Residual Oil Differs by Displacing Fluid</p> <p>Water and gas trap oil through different mechanisms. Water (in a water-wet rock) tends to imbibe into smaller pores first, bypassing and snapping off oil in larger pores. Gas, being less viscous, creates more uniform displacement fronts at the pore scale. This is why \\(S_{or,g}\\) is typically lower than \\(S_{or,w}\\).</p>"},{"location":"user-guide/relative-permeability/#the-brooks-corey-model","title":"The Brooks-Corey Model","text":"<p>The primary relative permeability model in BORES is <code>BrooksCoreyThreePhaseRelPermModel</code>. This is a power-law (Corey-type) model that computes two-phase relative permeability curves for each phase pair and then combines them into three-phase curves using a mixing rule.</p> <p>The Brooks-Corey model expresses relative permeability as a power function of normalized saturation. For water in a water-oil system:</p> \\[k_{rw} = k_{rw}^{max} \\left(\\frac{S_w - S_{wc}}{1 - S_{wc} - S_{or,w}}\\right)^{n_w}\\] <p>For oil in a water-oil system:</p> \\[k_{ro,w} = k_{ro}^{max} \\left(\\frac{1 - S_w - S_{or,w}}{1 - S_{wc} - S_{or,w}}\\right)^{n_o}\\] <p>where \\(n_w\\) and \\(n_o\\) are the Corey exponents for water and oil respectively, and \\(k_{rw}^{max}\\) and \\(k_{ro}^{max}\\) are the endpoint relative permeabilities (both default to 1.0 in BORES).</p>"},{"location":"user-guide/relative-permeability/#basic-usage","title":"Basic Usage","text":"<pre><code>import bores\n\nrelperm = bores.BrooksCoreyThreePhaseRelPermModel(\n    irreducible_water_saturation=0.25,\n    residual_oil_saturation_water=0.25,\n    residual_oil_saturation_gas=0.15,\n    residual_gas_saturation=0.05,\n    water_exponent=2.0,\n    oil_exponent=2.0,\n    gas_exponent=2.0,\n)\n</code></pre> <p>The model computes relative permeability at every grid cell from the current saturation state. You do not need to supply saturation endpoints separately to the model if you already specified them in the <code>reservoir_model()</code> call. When the endpoints in the model are set to <code>None</code> (the default), BORES uses the endpoint grids from the reservoir model. When you provide explicit values to the rel perm model, those values override the grid-level endpoints as defaults.</p>"},{"location":"user-guide/relative-permeability/#parameter-reference","title":"Parameter Reference","text":"Parameter Default Description <code>irreducible_water_saturation</code> <code>None</code> Connate water saturation \\(S_{wc}\\). If <code>None</code>, uses grid values. <code>residual_oil_saturation_water</code> <code>None</code> Residual oil to waterflood \\(S_{or,w}\\). If <code>None</code>, uses grid values. <code>residual_oil_saturation_gas</code> <code>None</code> Residual oil to gas flood \\(S_{or,g}\\). If <code>None</code>, uses grid values. <code>residual_gas_saturation</code> <code>None</code> Trapped gas saturation \\(S_{gr}\\). If <code>None</code>, uses grid values. <code>water_exponent</code> <code>2.0</code> Corey exponent for water phase \\(n_w\\) <code>oil_exponent</code> <code>2.0</code> Corey exponent for oil phase \\(n_o\\) <code>gas_exponent</code> <code>2.0</code> Corey exponent for gas phase \\(n_g\\) <code>wettability</code> <code>WATER_WET</code> Rock wettability (<code>WATER_WET</code> or <code>OIL_WET</code>) <code>mixing_rule</code> <code>eclipse_rule</code> Three-phase oil relative permeability mixing rule"},{"location":"user-guide/relative-permeability/#corey-exponents","title":"Corey Exponents","text":"<p>The Corey exponents (\\(n_w\\), \\(n_o\\), \\(n_g\\)) control the curvature of the relative permeability curves. They are the primary tuning parameters when matching laboratory data or calibrating simulation models to historical production data. Understanding what they control physically helps you choose appropriate values.</p> <p>Low exponents (1.0 - 1.5) produce nearly linear curves. This means relative permeability increases rapidly with saturation, giving high mobility at moderate saturations. Low exponents are typical of fractured or vuggy carbonates where flow channels are large and well-connected.</p> <p>Medium exponents (2.0 - 3.0) produce moderately curved relationships. An exponent of 2.0 is the most common default and is appropriate for many consolidated sandstones. This is a reasonable starting point when no laboratory data is available.</p> <p>High exponents (3.0 - 6.0) produce strongly concave curves where relative permeability stays low until saturation is quite high. These are typical of fine-grained rocks, mixed-wet systems, or situations where pore-scale heterogeneity creates tortuous flow paths.</p> <p>The practical effect on simulation results is significant. Higher water exponents delay water breakthrough because water relative permeability remains low until high water saturation develops. Higher oil exponents cause oil production to decline more gradually. The ratio of exponents affects the fractional flow curve and therefore the shape and speed of displacement fronts.</p> <p>Choosing Exponents Without Lab Data</p> <p>When you lack laboratory relative permeability measurements, start with exponents of 2.0 for all phases. If your waterflood history match shows water breaking through too early, increase the water exponent. If oil production declines too fast after breakthrough, increase the oil exponent. These adjustments change the fractional flow behavior without affecting the endpoint saturations.</p>"},{"location":"user-guide/relative-permeability/#wettability","title":"Wettability","text":"<p>Wettability describes which fluid preferentially coats the rock surface and occupies the smaller pores. It fundamentally changes the shape of relative permeability curves and has a major impact on recovery efficiency.</p> <p>In a water-wet rock (the default in BORES), water preferentially occupies the smaller pores and forms a continuous film along grain surfaces. Oil sits in the larger pores. During waterflooding, water advances through the smaller pores first (imbibition), efficiently displacing oil from the pore network. Water-wet rocks typically have:</p> <ul> <li>Lower \\(S_{or,w}\\) (better waterflood recovery)</li> <li>Higher \\(k_{rw}\\) at residual oil (water flows easily in its preferred small pores)</li> <li>Crossover point at \\(S_w &gt; 0.5\\) (water curve crosses oil curve at higher water saturation)</li> </ul> <p>In an oil-wet rock, oil preferentially coats the grain surfaces and occupies the smaller pores. Water sits in the larger, less well-connected pores. During waterflooding, water tends to channel through larger pores, bypassing oil in smaller ones. Oil-wet rocks typically have:</p> <ul> <li>Higher \\(S_{or,w}\\) (worse waterflood recovery)</li> <li>Lower \\(k_{rw}\\) at residual oil</li> <li>Crossover point at \\(S_w &lt; 0.5\\)</li> </ul> <pre><code>import bores\n\n# Water-wet system (default)\nrelperm_ww = bores.BrooksCoreyThreePhaseRelPermModel(\n    water_exponent=2.5,\n    oil_exponent=2.0,\n    gas_exponent=2.0,\n    wettability=bores.Wettability.WATER_WET,\n)\n\n# Oil-wet system\nrelperm_ow = bores.BrooksCoreyThreePhaseRelPermModel(\n    water_exponent=3.0,\n    oil_exponent=1.5,\n    gas_exponent=2.0,\n    wettability=bores.Wettability.OIL_WET,\n)\n</code></pre> <p>Most conventional sandstone reservoirs are water-wet or mixed-wet. Carbonate reservoirs are more commonly oil-wet or mixed-wet. If you are unsure, start with water-wet, which is the industry default.</p>"},{"location":"user-guide/relative-permeability/#mixed-wet-systems","title":"Mixed-Wet Systems","text":"<p>Many real reservoirs exhibit mixed wettability, where some pore surfaces are water-wet and others are oil-wet. This occurs naturally when crude oil contacts the rock surface over geological time: the larger pores that were originally oil-filled become oil-wet, while smaller pores that retained water films remain water-wet. Mixed-wet rock typically produces distinctive relative permeability curves that fall between the pure water-wet and oil-wet end members, often with relatively high mobility for both phases at intermediate saturations.</p> <p>The <code>BrooksCoreyThreePhaseRelPermModel</code> in BORES currently supports <code>WATER_WET</code> and <code>OIL_WET</code> wettability settings. It does not have a direct <code>MIXED_WET</code> mode for relative permeability. However, you can approximate mixed-wet relative permeability behavior through careful selection of Corey exponents. Mixed-wet systems typically have characteristics that lie between the two end members:</p> <ul> <li>Lower water exponents (1.5 to 2.5) compared to strongly water-wet systems, because oil-wet pores provide easier pathways for water</li> <li>Lower oil exponents (1.5 to 2.0) compared to strongly oil-wet systems, because water-wet pores keep some oil mobile</li> <li>Crossover point near \\(S_w = 0.5\\), between the high crossover of water-wet and low crossover of oil-wet</li> </ul> <pre><code>import bores\n\n# Approximate mixed-wet behavior using tuned exponents\nrelperm_mixed = bores.BrooksCoreyThreePhaseRelPermModel(\n    irreducible_water_saturation=0.20,\n    residual_oil_saturation_water=0.28,\n    residual_oil_saturation_gas=0.18,\n    residual_gas_saturation=0.05,\n    water_exponent=2.0,     # Lower than typical water-wet (2.5-3.0)\n    oil_exponent=1.8,       # Lower than typical oil-wet (2.0-2.5)\n    gas_exponent=2.0,\n    wettability=bores.Wettability.WATER_WET,\n)\n</code></pre> <p>If you have laboratory SCAL data from mixed-wet core plugs, the best approach is to use a <code>ThreePhaseRelPermTable</code> with the measured data directly. Tabular data can reproduce the exact curve shapes measured in the lab, including the subtle features characteristic of mixed-wet rock (gradual crossover, relatively high endpoint permeabilities for both phases, and S-shaped curve segments) that analytical models cannot easily capture.</p> <p>Mixed-Wet Capillary Pressure</p> <p>While the relative permeability model approximates mixed-wet behavior through exponent tuning, the capillary pressure models in BORES do support a direct <code>MIXED_WET</code> wettability mode with a <code>mixed_wet_water_fraction</code> parameter. See Capillary Pressure for details on configuring mixed-wet capillary pressure curves, which can produce the characteristic sign change at intermediate saturations.</p>"},{"location":"user-guide/relative-permeability/#three-phase-mixing-rules","title":"Three-Phase Mixing Rules","text":"<p>In a three-phase system (oil, water, and gas present simultaneously), BORES needs a way to compute the oil relative permeability \\(k_{ro}\\) from the two-phase curves \\(k_{ro,w}(S_w)\\) and \\(k_{ro,g}(S_g)\\). This is done through a mixing rule that interpolates between the two-phase oil curves.</p> <p>BORES provides several mixing rules, selectable by name or by passing the function directly. The choice of mixing rule can significantly affect results in regions where all three phases are mobile (near wells, at gas-oil-water contacts, and during WAG injection).</p>"},{"location":"user-guide/relative-permeability/#available-mixing-rules","title":"Available Mixing Rules","text":"Rule String Name Description Eclipse rule <code>\"eclipse_rule\"</code> Industry standard default. Conservative, well-tested. Stone I <code>\"stone_I_rule\"</code> Stone's first model. Good for water-wet systems. Stone II <code>\"stone_II_rule\"</code> Stone's second model. More conservative than Stone I. Baker linear <code>\"baker_linear_rule\"</code> Linear saturation-weighted interpolation. Simple and stable. Saturation weighted <code>\"saturation_weighted_interpolation_rule\"</code> Weighted by normalized saturations. Blunt rule <code>\"blunt_rule\"</code> Conservative, designed for strongly water-wet rocks. Harmonic mean <code>\"harmonic_mean_rule\"</code> Very conservative. Good for tight rocks, series flow. Geometric mean <code>\"geometric_mean_rule\"</code> Moderately conservative. General purpose. Arithmetic mean <code>\"arithmetic_mean_rule\"</code> Optimistic upper bound estimate. Min rule <code>\"min_rule\"</code> Most conservative. Lower bound on oil mobility. Max rule <code>\"max_rule\"</code> Most optimistic. Upper bound on oil mobility. Aziz-Settari <code>\"aziz_settari_rule\"</code> Empirical, tunable for specific reservoirs. <pre><code>import bores\n\n# Using the default Eclipse rule\nrelperm = bores.BrooksCoreyThreePhaseRelPermModel(\n    water_exponent=2.0,\n    oil_exponent=2.0,\n    gas_exponent=2.0,\n    mixing_rule=\"eclipse_rule\",\n)\n\n# Using Stone I for a water-wet carbonate\nrelperm_stone = bores.BrooksCoreyThreePhaseRelPermModel(\n    water_exponent=2.5,\n    oil_exponent=2.0,\n    gas_exponent=2.0,\n    mixing_rule=\"stone_I_rule\",\n)\n</code></pre> <p>The Eclipse rule is the default and recommended starting point. It is the same approach used by the Schlumberger Eclipse commercial simulator and has been validated against decades of field data. Stone I and Stone II are classical alternatives from the petroleum engineering literature and are appropriate when you need to match specific laboratory three-phase relative permeability data.</p> <p>Mixing Rule Sensitivity</p> <p>The choice of mixing rule primarily matters in regions where all three phases are simultaneously mobile. In a pure waterflood (no free gas) or pure gas injection (connate water only), the mixing rule has no effect because one of the two-phase curves is not active. However, in WAG injection, gas cap expansion into the oil zone, or near the gas-oil-water contact, the mixing rule can change oil recovery predictions by 5-15%.</p>"},{"location":"user-guide/relative-permeability/#tabular-relative-permeability","title":"Tabular Relative Permeability","text":"<p>While the Brooks-Corey model is convenient because it generates smooth curves from a small number of parameters, many engineers prefer to use tabular data from laboratory core flood experiments. BORES provides <code>TwoPhaseRelPermTable</code> and <code>ThreePhaseRelPermTable</code> for this purpose. These classes store measured saturation and relative permeability values as arrays and interpolate between them using fast linear interpolation (<code>np.interp</code>).</p> <p>Tabular relative permeability is the industry-standard approach when you have Special Core Analysis (SCAL) data from laboratory steady-state or unsteady-state experiments. In these experiments, two fluids are injected simultaneously through a core plug at different fractional flow rates, and the pressure drop and produced fluid volumes are used to back-calculate relative permeability at each saturation. The result is a table of saturation values paired with the corresponding relative permeability for each phase. Using these measured data directly avoids the approximation inherent in fitting an analytical model.</p>"},{"location":"user-guide/relative-permeability/#twophaserelpermtable","title":"TwoPhaseRelPermTable","text":"<p>A <code>TwoPhaseRelPermTable</code> stores one set of saturation values and the corresponding relative permeabilities for both phases. You specify which fluid is the wetting phase and which is the non-wetting phase, along with the saturation and permeability arrays.</p> <pre><code>import bores\nimport numpy as np\n\n# Oil-water relative permeability from lab data\now_table = bores.TwoPhaseRelPermTable(\n    wetting_phase=bores.FluidPhase.WATER,\n    non_wetting_phase=bores.FluidPhase.OIL,\n    wetting_phase_saturation=np.array([0.20, 0.25, 0.30, 0.40, 0.50, 0.60, 0.70, 0.75]),\n    wetting_phase_relative_permeability=np.array([0.0, 0.01, 0.03, 0.10, 0.22, 0.40, 0.65, 0.80]),\n    non_wetting_phase_relative_permeability=np.array([1.0, 0.85, 0.68, 0.40, 0.20, 0.08, 0.01, 0.0]),\n)\n</code></pre> <p>The <code>wetting_phase_saturation</code> array must be monotonically increasing and contain at least two points. BORES uses <code>np.interp</code> for interpolation, which means values outside the table range are clamped to the endpoint values (constant extrapolation). This is physically reasonable because relative permeability should be zero at or below residual saturation and at its maximum at or above the maximum saturation.</p> <p>You can query the table for relative permeability values at any saturation, including full 3D grid arrays:</p> <pre><code># Query at a single saturation\nkrw_at_05 = ow_table.get_wetting_phase_relative_permeability(0.5)\nkro_at_05 = ow_table.get_non_wetting_phase_relative_permeability(0.5)\n\n# Query with a grid array\nSw_grid = np.random.uniform(0.2, 0.75, size=(20, 20, 5))\nkrw_grid = ow_table.get_wetting_phase_relative_permeability(Sw_grid)\nkro_grid = ow_table.get_non_wetting_phase_relative_permeability(Sw_grid)\n</code></pre>"},{"location":"user-guide/relative-permeability/#threephaserelpermtable","title":"ThreePhaseRelPermTable","text":"<p>For three-phase simulation, you combine two <code>TwoPhaseRelPermTable</code> objects (one for oil-water and one for gas-oil) into a <code>ThreePhaseRelPermTable</code>. This table uses the same mixing rules as the Brooks-Corey model to compute three-phase oil relative permeability from the two two-phase curves.</p> <pre><code>import bores\nimport numpy as np\n\n# Oil-water table (water is wetting phase)\now_table = bores.TwoPhaseRelPermTable(\n    wetting_phase=bores.FluidPhase.WATER,\n    non_wetting_phase=bores.FluidPhase.OIL,\n    wetting_phase_saturation=np.array([0.20, 0.30, 0.40, 0.50, 0.60, 0.70, 0.75]),\n    wetting_phase_relative_permeability=np.array([0.0, 0.02, 0.08, 0.20, 0.38, 0.62, 0.80]),\n    non_wetting_phase_relative_permeability=np.array([1.0, 0.70, 0.42, 0.20, 0.07, 0.01, 0.0]),\n)\n\n# Gas-oil table (oil is wetting phase)\ngo_table = bores.TwoPhaseRelPermTable(\n    wetting_phase=bores.FluidPhase.OIL,\n    non_wetting_phase=bores.FluidPhase.GAS,\n    wetting_phase_saturation=np.array([0.15, 0.25, 0.35, 0.50, 0.65, 0.80, 0.85]),\n    wetting_phase_relative_permeability=np.array([0.0, 0.02, 0.08, 0.25, 0.50, 0.82, 1.0]),\n    non_wetting_phase_relative_permeability=np.array([0.90, 0.65, 0.40, 0.18, 0.05, 0.005, 0.0]),\n)\n\n# Combine into three-phase table with Eclipse mixing rule\nthree_phase = bores.ThreePhaseRelPermTable(\n    oil_water_table=ow_table,\n    gas_oil_table=go_table,\n    mixing_rule=bores.eclipse_rule,\n)\n</code></pre> <p>The <code>ThreePhaseRelPermTable</code> validates that the phase assignments are consistent: the oil-water table must involve water and oil, the gas-oil table must involve oil and gas, and the gas-oil table must have oil as the wetting phase. If these constraints are violated, BORES raises a <code>ValidationError</code> with a clear message explaining the issue.</p> <p>The mixing rule parameter accepts the same functions as the Brooks-Corey model. If you set <code>mixing_rule=None</code>, BORES defaults to a conservative <code>min(kro_w, kro_g)</code> rule. The available mixing rules are the same ones listed in the Three-Phase Mixing Rules section above.</p> <p>When to Use Tables vs. Correlations</p> <p>Use tabular relative permeability when you have laboratory SCAL data, when you need to match specific curve shapes that power-law models cannot reproduce (such as S-shaped curves or curves with inflection points), or when your curves come from pore-network modeling or digital rock analysis. Use the Brooks-Corey model when you lack lab data, when you want quick sensitivity studies by varying exponents, or when you need a smooth, well-behaved function for numerical stability.</p>"},{"location":"user-guide/relative-permeability/#direct-usage-outside-simulation","title":"Direct Usage (Outside Simulation)","text":"<p>You do not need to run a full simulation to evaluate relative permeability models. Both analytical and tabular models can be called directly with saturation values, which is useful for plotting curves, debugging, validating against lab data, or building custom workflows. Every model supports both scalar and grid-array inputs.</p>"},{"location":"user-guide/relative-permeability/#calling-the-brooks-corey-model-directly","title":"Calling the Brooks-Corey Model Directly","text":"<p>The <code>BrooksCoreyThreePhaseRelPermModel</code> can be called directly with <code>get_relative_permeabilities()</code> or using the <code>__call__</code> interface. Both accept water, oil, and gas saturations and return a dictionary with <code>\"water\"</code>, <code>\"oil\"</code>, and <code>\"gas\"</code> keys containing the computed relative permeabilities.</p> <pre><code>import bores\nimport numpy as np\n\nrelperm = bores.BrooksCoreyThreePhaseRelPermModel(\n    irreducible_water_saturation=0.25,\n    residual_oil_saturation_water=0.25,\n    residual_oil_saturation_gas=0.15,\n    residual_gas_saturation=0.05,\n    water_exponent=2.5,\n    oil_exponent=2.0,\n    gas_exponent=2.0,\n)\n\n# Scalar evaluation\nresult = relperm.get_relative_permeabilities(\n    water_saturation=0.4,\n    oil_saturation=0.55,\n    gas_saturation=0.05,\n)\nprint(f\"krw = {result['water']:.4f}\")\nprint(f\"kro = {result['oil']:.4f}\")\nprint(f\"krg = {result['gas']:.4f}\")\n\n# Using __call__ (same result)\nresult = relperm(\n    water_saturation=0.4,\n    oil_saturation=0.55,\n    gas_saturation=0.05,\n)\n\n# Grid array evaluation (3D)\nSw = bores.build_uniform_grid((20, 20, 5), value=0.4)\nSo = bores.build_uniform_grid((20, 20, 5), value=0.55)\nSg = bores.build_uniform_grid((20, 20, 5), value=0.05)\n\nresult = relperm(water_saturation=Sw, oil_saturation=So, gas_saturation=Sg)\nkrw_grid = result[\"water\"]  # Shape: (20, 20, 5)\nkro_grid = result[\"oil\"]    # Shape: (20, 20, 5)\nkrg_grid = result[\"gas\"]    # Shape: (20, 20, 5)\n</code></pre> <p>The returned dictionary uses string keys <code>\"water\"</code>, <code>\"oil\"</code>, and <code>\"gas\"</code>. Each value is either a float (for scalar inputs) or a NumPy array matching the shape of the input saturations (for array inputs). This makes it easy to sweep over saturations for plotting or to evaluate the model on a full simulation grid.</p>"},{"location":"user-guide/relative-permeability/#calling-the-threephaserelpermtable-directly","title":"Calling the ThreePhaseRelPermTable Directly","text":"<p>The tabular model works the same way. Use <code>get_relative_permeabilities()</code> or <code>__call__</code> with the three saturation values:</p> <pre><code># Using the three_phase table from earlier\nresult = three_phase.get_relative_permeabilities(\n    water_saturation=0.35,\n    oil_saturation=0.55,\n    gas_saturation=0.10,\n)\nprint(f\"krw = {result['water']:.4f}\")\nprint(f\"kro = {result['oil']:.4f}\")\nprint(f\"krg = {result['gas']:.4f}\")\n\n# Array evaluation works identically\nresult = three_phase(\n    water_saturation=Sw,\n    oil_saturation=So,\n    gas_saturation=Sg,\n)\n</code></pre>"},{"location":"user-guide/relative-permeability/#calling-a-twophaserelpermtable-directly","title":"Calling a TwoPhaseRelPermTable Directly","text":"<p>For the two-phase table, you query by wetting phase saturation using the dedicated methods:</p> <pre><code># Get individual phase relative permeabilities\nkrw = ow_table.get_wetting_phase_relative_permeability(0.45)\nkro = ow_table.get_non_wetting_phase_relative_permeability(0.45)\n\n# Get both at once\nkrw, kro = ow_table.get_relative_permeabilities(0.45)\n\n# Using __call__ (returns wetting phase kr only)\nkrw = ow_table(wetting_phase_saturation=0.45)\n</code></pre> <p>This direct evaluation capability is valuable for generating relative permeability curves for reports, comparing analytical and tabular models side by side, and verifying that your model parameters produce physically reasonable curves before committing to a full simulation run.</p>"},{"location":"user-guide/relative-permeability/#integrating-with-rockfluidtables","title":"Integrating with RockFluidTables","text":"<p>Relative permeability is passed to the simulation through the <code>RockFluidTables</code> object, which also holds the capillary pressure model. You then pass <code>RockFluidTables</code> to the <code>Config</code>. This works the same way whether you use the Brooks-Corey analytical model or a tabular approach:</p> <pre><code>import bores\n\nrelperm = bores.BrooksCoreyThreePhaseRelPermModel(\n    irreducible_water_saturation=0.25,\n    residual_oil_saturation_water=0.25,\n    residual_oil_saturation_gas=0.15,\n    residual_gas_saturation=0.05,\n    water_exponent=2.5,\n    oil_exponent=2.0,\n    gas_exponent=2.0,\n    mixing_rule=\"eclipse_rule\",\n)\n\nrock_fluid = bores.RockFluidTables(\n    relative_permeability_table=relperm,\n    capillary_pressure_table=bores.BrooksCoreyCapillaryPressureModel(),\n)\n\nconfig = bores.Config(\n    timer=timer,\n    rock_fluid_tables=rock_fluid,\n    wells=wells,\n    scheme=\"impes\",\n)\n</code></pre> <p>You can also pass a <code>ThreePhaseRelPermTable</code> instead of the Brooks-Corey model:</p> <pre><code>rock_fluid = bores.RockFluidTables(\n    relative_permeability_table=three_phase,  # ThreePhaseRelPermTable from lab data\n    capillary_pressure_table=bores.BrooksCoreyCapillaryPressureModel(),\n)\n</code></pre> <p>Both analytical models and tabular data are <code>RockFluidTables</code>-compatible and serializable. When you save a <code>Config</code> to disk, the relative permeability model (whether Brooks-Corey or tabular) and all its parameters or data are preserved and can be reloaded exactly.</p>"},{"location":"user-guide/relative-permeability/#visualizing-relative-permeability-curves","title":"Visualizing Relative Permeability Curves","text":"<p>Understanding what your relative permeability curves look like before running a simulation is critical for quality assurance. The best way to do this is to create the actual model you plan to use and call it directly across a saturation sweep. This ensures the plotted curves are exactly what the simulator will use.</p>"},{"location":"user-guide/relative-permeability/#water-oil-curves","title":"Water-Oil Curves","text":"<pre><code>import bores\nimport numpy as np\n\n# Create the model\nrelperm = bores.BrooksCoreyThreePhaseRelPermModel(\n    irreducible_water_saturation=0.25,\n    residual_oil_saturation_water=0.25,\n    residual_oil_saturation_gas=0.15,\n    residual_gas_saturation=0.05,\n    water_exponent=2.5,\n    oil_exponent=2.0,\n    gas_exponent=2.0,\n)\n\n# Sweep water saturation across the mobile range (no free gas)\nSw_values = np.linspace(0.25, 0.75, 50)\nkrw_values = np.zeros_like(Sw_values)\nkro_values = np.zeros_like(Sw_values)\n\nfor i, sw in enumerate(Sw_values):\n    so = 1.0 - sw  # No free gas: So = 1 - Sw\n    result = relperm.get_relative_permeabilities(\n        water_saturation=sw, oil_saturation=so, gas_saturation=0.0,\n    )\n    krw_values[i] = result[\"water\"]\n    kro_values[i] = result[\"oil\"]\n\n# Plot with BORES visualization\nfig = bores.make_series_plot(\n    data={\n        \"krw\": np.column_stack([Sw_values, krw_values]),\n        \"kro\": np.column_stack([Sw_values, kro_values]),\n    },\n    title=\"Brooks-Corey Water-Oil Relative Permeability\",\n    x_label=\"Water Saturation (fraction)\",\n    y_label=\"Relative Permeability\",\n)\nfig.show()\n# Output: [PLACEHOLDER: Insert relperm_water_oil_curves.png]\n</code></pre> <p>This visualization lets you verify that the curves match your expectations: endpoint values are correct, curvature is reasonable, and the crossover point is where you expect it. If the curves look wrong, adjust the exponents and endpoints before running the simulation.</p>"},{"location":"user-guide/relative-permeability/#gas-oil-curves","title":"Gas-Oil Curves","text":"<p>You can also plot the gas-oil relative permeability curves by sweeping gas saturation while keeping water at connate:</p> <pre><code># Sweep gas saturation (water at connate)\nSg_values = np.linspace(0.0, 0.55, 50)\nkrg_values = np.zeros_like(Sg_values)\nkro_g_values = np.zeros_like(Sg_values)\n\nfor i, sg in enumerate(Sg_values):\n    so = 1.0 - 0.25 - sg  # Sw = Swc = 0.25\n    result = relperm.get_relative_permeabilities(\n        water_saturation=0.25, oil_saturation=so, gas_saturation=sg,\n    )\n    krg_values[i] = result[\"gas\"]\n    kro_g_values[i] = result[\"oil\"]\n\nfig = bores.make_series_plot(\n    data={\n        \"krg\": np.column_stack([Sg_values, krg_values]),\n        \"kro\": np.column_stack([Sg_values, kro_g_values]),\n    },\n    title=\"Brooks-Corey Gas-Oil Relative Permeability\",\n    x_label=\"Gas Saturation (fraction)\",\n    y_label=\"Relative Permeability\",\n)\nfig.show()\n# Output: [PLACEHOLDER: Insert relperm_gas_oil_curves.png]\n</code></pre>"},{"location":"user-guide/relative-permeability/#comparing-tabular-and-analytical-curves","title":"Comparing Tabular and Analytical Curves","text":"<p>If you have both a tabular model from lab data and an analytical model, you can plot them together to assess how well the analytical fit matches the measurements:</p> <pre><code># Analytical model\nrelperm_bc = bores.BrooksCoreyThreePhaseRelPermModel(\n    irreducible_water_saturation=0.20,\n    residual_oil_saturation_water=0.25,\n    water_exponent=2.5,\n    oil_exponent=2.0,\n)\n\n# Tabular model from lab data\now_table = bores.TwoPhaseRelPermTable(\n    wetting_phase=bores.FluidPhase.WATER,\n    non_wetting_phase=bores.FluidPhase.OIL,\n    wetting_phase_saturation=np.array([0.20, 0.30, 0.40, 0.50, 0.60, 0.70, 0.75]),\n    wetting_phase_relative_permeability=np.array([0.0, 0.02, 0.08, 0.20, 0.38, 0.62, 0.80]),\n    non_wetting_phase_relative_permeability=np.array([1.0, 0.70, 0.42, 0.20, 0.07, 0.01, 0.0]),\n)\n\n# Evaluate both across the same saturation range\nSw_range = np.linspace(0.20, 0.75, 50)\nkrw_bc = np.zeros_like(Sw_range)\nkro_bc = np.zeros_like(Sw_range)\n\nfor i, sw in enumerate(Sw_range):\n    result = relperm_bc.get_relative_permeabilities(\n        water_saturation=sw, oil_saturation=1.0 - sw, gas_saturation=0.0,\n    )\n    krw_bc[i] = result[\"water\"]\n    kro_bc[i] = result[\"oil\"]\n\nkrw_tab = ow_table.get_wetting_phase_relative_permeability(Sw_range)\nkro_tab = ow_table.get_non_wetting_phase_relative_permeability(Sw_range)\n\nfig = bores.make_series_plot(\n    data={\n        \"krw (Brooks-Corey)\": np.column_stack([Sw_range, krw_bc]),\n        \"kro (Brooks-Corey)\": np.column_stack([Sw_range, kro_bc]),\n        \"krw (Lab Data)\": np.column_stack([Sw_range, krw_tab]),\n        \"kro (Lab Data)\": np.column_stack([Sw_range, kro_tab]),\n    },\n    title=\"Analytical vs. Tabular Relative Permeability\",\n    x_label=\"Water Saturation (fraction)\",\n    y_label=\"Relative Permeability\",\n)\nfig.show()\n# Output: [PLACEHOLDER: Insert relperm_comparison.png]\n</code></pre> <p>This kind of comparison is essential for calibration. If the analytical and tabular curves diverge significantly, you should either adjust the Corey exponents to improve the fit or use the tabular data directly for the simulation.</p>"},{"location":"user-guide/relative-permeability/#tips-for-selecting-parameters","title":"Tips for Selecting Parameters","text":"<p>Choosing relative permeability parameters is one of the most important decisions in reservoir simulation. Here are practical guidelines based on field experience:</p> <p>Start with the endpoints. Irreducible water saturation and residual oil saturation have a much larger impact on recovery predictions than the exponents. Get these right first from core analysis or analogous field data.</p> <p>Use exponents of 2.0 as a baseline. Adjust up or down based on history matching or laboratory data. Higher exponents mean more non-linear behavior and generally more pessimistic displacement efficiency.</p> <p>Match the fractional flow curve, not just the relative permeability. The fractional flow function \\(f_w = \\lambda_w / (\\lambda_w + \\lambda_o)\\) controls the displacement front shape and water cut evolution. You can have very different relative permeability curves that produce similar fractional flow behavior if the mobility ratio is similar.</p> <p>Be consistent with wettability. If you set oil-wet wettability, your endpoint saturations should also reflect oil-wet behavior (higher \\(S_{or,w}\\), lower crossover point). Mixing water-wet endpoints with oil-wet curve shapes produces physically inconsistent models.</p> <p>Quick Reference: Typical Parameter Sets</p> Water-Wet SandstoneOil-Wet CarbonateUnconsolidated Sand <pre><code>relperm = bores.BrooksCoreyThreePhaseRelPermModel(\n    irreducible_water_saturation=0.25,\n    residual_oil_saturation_water=0.25,\n    residual_oil_saturation_gas=0.15,\n    residual_gas_saturation=0.05,\n    water_exponent=2.5,\n    oil_exponent=2.0,\n    gas_exponent=2.0,\n    wettability=bores.Wettability.WATER_WET,\n)\n</code></pre> <pre><code>relperm = bores.BrooksCoreyThreePhaseRelPermModel(\n    irreducible_water_saturation=0.15,\n    residual_oil_saturation_water=0.35,\n    residual_oil_saturation_gas=0.20,\n    residual_gas_saturation=0.05,\n    water_exponent=3.5,\n    oil_exponent=1.5,\n    gas_exponent=2.5,\n    wettability=bores.Wettability.OIL_WET,\n)\n</code></pre> <pre><code>relperm = bores.BrooksCoreyThreePhaseRelPermModel(\n    irreducible_water_saturation=0.30,\n    residual_oil_saturation_water=0.20,\n    residual_oil_saturation_gas=0.12,\n    residual_gas_saturation=0.03,\n    water_exponent=1.5,\n    oil_exponent=1.5,\n    gas_exponent=1.5,\n)\n</code></pre>"},{"location":"user-guide/rock-properties/","title":"Rock Properties","text":""},{"location":"user-guide/rock-properties/#overview","title":"Overview","text":"<p>Rock properties define the static framework of your reservoir model. They control how much fluid the rock can store (porosity), how easily fluid flows through it (permeability), and how the pore volume changes with pressure (compressibility). In BORES, you specify these as NumPy arrays with one value per grid cell, then pass them to <code>bores.reservoir_model()</code>.</p> <p>Understanding rock properties is essential because they directly control sweep efficiency, pressure communication, and ultimately recovery. A high-permeability streak can channel injected water past oil-bearing zones. A low-porosity layer can act as a barrier to vertical flow. These effects cannot be captured without realistic rock property distributions.</p>"},{"location":"user-guide/rock-properties/#porosity","title":"Porosity","text":"<p>Porosity (\\(\\phi\\)) is the fraction of rock volume that is pore space, available to store fluids. Values range from 0 (solid rock) to roughly 0.35 for unconsolidated sands.</p> Rock Type Typical Porosity Tight sandstone 0.05 - 0.10 Consolidated sandstone 0.15 - 0.25 Unconsolidated sand 0.25 - 0.35 Carbonate (vuggy) 0.10 - 0.30 Shale (barrier) 0.01 - 0.05 <pre><code>import bores\n\ngrid_shape = (20, 20, 5)\n\n# Uniform porosity\nporosity = bores.build_uniform_grid(grid_shape, value=0.22)\n\n# Layered porosity (decreasing with depth)\nporosity = bores.build_layered_grid(\n    grid_shape,\n    layer_values=[0.25, 0.22, 0.20, 0.18, 0.15],\n    orientation=\"z\",\n)\n</code></pre> <p>Cells with zero or NaN porosity are treated as inactive by the simulator. You can use this to model impermeable boundaries or irregular reservoir shapes within the rectangular grid.</p>"},{"location":"user-guide/rock-properties/#permeability","title":"Permeability","text":"<p>Absolute permeability (\\(k\\)) measures how easily a single-phase fluid flows through the rock under a pressure gradient. BORES uses millidarcies (mD) as the unit. Permeability can vary by direction (anisotropy), which is extremely common in real reservoirs because of layered deposition.</p>"},{"location":"user-guide/rock-properties/#isotropic-permeability","title":"Isotropic Permeability","text":"<p>If permeability is the same in all directions, you can pass a single grid:</p> <pre><code>import bores\n\ngrid_shape = (20, 20, 5)\nperm_grid = bores.build_uniform_grid(grid_shape, value=100.0)  # 100 mD\n\n# Option 1: Just pass x, BORES copies to y and z\npermeability = bores.RockPermeability(x=perm_grid)\n\n# Option 2: Explicitly set all directions\npermeability = bores.RockPermeability(x=perm_grid, y=perm_grid, z=perm_grid)\n</code></pre>"},{"location":"user-guide/rock-properties/#anisotropic-permeability","title":"Anisotropic Permeability","text":"<p>In most sedimentary rocks, vertical permeability (\\(k_z\\)) is lower than horizontal permeability (\\(k_x\\), \\(k_y\\)) due to compaction and bedding planes. A typical \\(k_v/k_h\\) ratio is 0.1 to 0.3.</p> <pre><code>import bores\n\ngrid_shape = (20, 20, 5)\n\nkx = bores.build_uniform_grid(grid_shape, value=200.0)   # 200 mD horizontal\nky = bores.build_uniform_grid(grid_shape, value=200.0)   # Same in y\nkz = bores.build_uniform_grid(grid_shape, value=20.0)    # 20 mD vertical (kv/kh = 0.1)\n\npermeability = bores.RockPermeability(x=kx, y=ky, z=kz)\n</code></pre> <p>Anisotropy has a major impact on vertical sweep efficiency. Low vertical permeability limits gravity override in gas injection and reduces water coning near production wells.</p>"},{"location":"user-guide/rock-properties/#heterogeneous-permeability","title":"Heterogeneous Permeability","text":"<p>For realistic models, permeability varies spatially. You can build layered distributions or use random perturbations:</p> <pre><code>import bores\nimport numpy as np\n\ngrid_shape = (20, 20, 5)\n\n# Layer-by-layer permeability\nkx = bores.build_layered_grid(\n    grid_shape,\n    layer_values=[300.0, 150.0, 50.0, 200.0, 100.0],\n    orientation=\"z\",\n)\n\n# Add log-normal heterogeneity within each layer\nrng = np.random.default_rng(seed=42)\nnoise = np.exp(rng.normal(0, 0.3, grid_shape))  # Log-normal multiplier\nkx = kx * noise\n\n# Apply kv/kh ratio\nkz = kx * 0.1\n\npermeability = bores.RockPermeability(x=kx, y=kx, z=kz)\n</code></pre> <p>Permeability Range</p> <p>Realistic permeability values span many orders of magnitude: from 0.01 mD (tight rock) to 10,000 mD (highly permeable sand). High contrasts (ratios exceeding 1000:1) can cause solver convergence difficulties. Consider using 64-bit precision and stronger preconditioners (ILU or CPR) for such cases.</p>"},{"location":"user-guide/rock-properties/#rock-compressibility","title":"Rock Compressibility","text":"<p>Rock compressibility (\\(c_r\\)) describes how much the pore volume changes with pressure. It is specified in psi\\(^{-1}\\) and is typically much smaller than fluid compressibility.</p> Rock Type Typical \\(c_r\\) (psi\\(^{-1}\\)) Consolidated sandstone \\(3 \\times 10^{-6}\\) to \\(5 \\times 10^{-6}\\) Unconsolidated sand \\(10 \\times 10^{-6}\\) to \\(20 \\times 10^{-6}\\) Limestone \\(2 \\times 10^{-6}\\) to \\(4 \\times 10^{-6}\\) <p>You pass rock compressibility as a scalar to <code>bores.reservoir_model()</code>:</p> <pre><code>model = bores.reservoir_model(\n    # ... other parameters ...\n    rock_compressibility=3e-6,  # psi^-1\n)\n</code></pre> <p>Although small, rock compressibility contributes to total system compressibility and affects pressure diffusion. It becomes more important in tight formations where fluid compressibility is also low, making rock compressibility a larger fraction of the total.</p>"},{"location":"user-guide/rock-properties/#complete-example","title":"Complete Example","text":"<p>Here is a full example building a heterogeneous reservoir model with layered porosity, anisotropic permeability, and rock compressibility:</p> <pre><code>import bores\nimport numpy as np\n\nbores.use_32bit_precision()\n\ngrid_shape = (20, 20, 5)\ncell_dimensions = (200.0, 200.0)  # ft\n\n# Layered porosity\nporosity = bores.build_layered_grid(\n    grid_shape,\n    layer_values=[0.25, 0.22, 0.18, 0.20, 0.15],\n    orientation=\"z\",\n)\n\n# Heterogeneous permeability with kv/kh = 0.1\nrng = np.random.default_rng(seed=42)\nbase_perm = bores.build_layered_grid(\n    grid_shape,\n    layer_values=[300.0, 200.0, 50.0, 250.0, 100.0],\n    orientation=\"z\",\n)\nnoise = np.exp(rng.normal(0, 0.25, grid_shape)).astype(np.float32)\nkx = base_perm * noise\npermeability = bores.RockPermeability(x=kx, y=kx, z=kx * 0.1)\n\n# Other properties\nthickness = bores.build_uniform_grid(grid_shape, value=15.0)\npressure = bores.build_uniform_grid(grid_shape, value=3500.0)\ntemperature = bores.build_uniform_grid(grid_shape, value=200.0)\noil_sg = bores.build_uniform_grid(grid_shape, value=0.85)\noil_visc = bores.build_uniform_grid(grid_shape, value=1.5)\nbubble_pt = bores.build_uniform_grid(grid_shape, value=2800.0)\n\n# Saturations from fluid contacts\ndepth = bores.build_depth_grid(thickness) + 5000.0\nSwc  = bores.build_uniform_grid(grid_shape, value=0.25)\nSorw = bores.build_uniform_grid(grid_shape, value=0.25)\nSorg = bores.build_uniform_grid(grid_shape, value=0.15)\nSgr  = bores.build_uniform_grid(grid_shape, value=0.05)\n\nSw, So, Sg = bores.build_saturation_grids(\n    depth_grid=depth,\n    gas_oil_contact=4950.0,\n    oil_water_contact=5060.0,\n    connate_water_saturation_grid=Swc,\n    residual_oil_saturation_water_grid=Sorw,\n    residual_oil_saturation_gas_grid=Sorg,\n    residual_gas_saturation_grid=Sgr,\n    porosity_grid=porosity,\n)\n\n# Build the model\nmodel = bores.reservoir_model(\n    grid_shape=grid_shape,\n    cell_dimension=cell_dimensions,\n    thickness_grid=thickness,\n    pressure_grid=pressure,\n    rock_compressibility=3e-6,\n    absolute_permeability=permeability,\n    porosity_grid=porosity,\n    temperature_grid=temperature,\n    water_saturation_grid=Sw,\n    gas_saturation_grid=Sg,\n    oil_saturation_grid=So,\n    oil_viscosity_grid=oil_visc,\n    oil_specific_gravity_grid=oil_sg,\n    oil_bubble_point_pressure_grid=bubble_pt,\n    residual_oil_saturation_water_grid=Sorw,\n    residual_oil_saturation_gas_grid=Sorg,\n    residual_gas_saturation_grid=Sgr,\n    irreducible_water_saturation_grid=Swc,\n    connate_water_saturation_grid=Swc,\n)\n</code></pre> <p>Start Simple, Add Complexity</p> <p>Begin with uniform properties to verify your simulation runs correctly, then add heterogeneity layer by layer. This makes it much easier to isolate the effect of each property on the simulation results.</p>"},{"location":"user-guide/advanced/aquifers/","title":"Aquifer Models","text":""},{"location":"user-guide/advanced/aquifers/#overview","title":"Overview","text":"<p>Aquifers are large bodies of water-saturated rock connected to the reservoir that provide pressure support through water influx. When reservoir pressure drops due to production, the pressure differential drives water from the aquifer into the reservoir, partially replacing the produced fluid volume and slowing pressure decline. The strength and timing of this pressure support depend on the aquifer's size, permeability, compressibility, and geometry.</p> <p>BORES provides the Carter-Tracy aquifer model, which is the industry standard for modeling finite aquifer behavior in black-oil simulators. The Carter-Tracy model captures the transient nature of aquifer response: early in the aquifer's life, the pressure signal has not reached the outer boundary, so the aquifer behaves as if it were infinite. Later, the outer boundary begins to affect the response, and the influx rate declines as the aquifer's finite energy is depleted.</p> <p>The Carter-Tracy model sits between two simpler alternatives. A constant pressure boundary (Dirichlet condition) models an infinite aquifer that provides unlimited pressure support, which is overly optimistic for most real aquifers. A no-flow boundary models the complete absence of aquifer support, which is overly conservative when aquifer communication exists. The Carter-Tracy model provides a physically realistic middle ground.</p>"},{"location":"user-guide/advanced/aquifers/#carter-tracy-model","title":"Carter-Tracy Model","text":"<p>The Carter-Tracy model computes water influx using the Van Everdingen-Hurst dimensionless water influx solution combined with a superposition (convolution) integral over the pressure history:</p> \\[Q(t) = B \\cdot \\sum_{i} \\Delta P(t_i) \\cdot W_D'(t_D - t_{Di})\\] <p>where:</p> <ul> <li>\\(B\\) is the aquifer constant, computed from physical properties</li> <li>\\(\\Delta P(t_i)\\) is the pressure change at the reservoir-aquifer boundary at time \\(t_i\\)</li> <li>\\(W_D'(t_D)\\) is the dimensionless water influx derivative</li> <li>\\(t_D\\) is the dimensionless time</li> </ul> <p>The aquifer constant \\(B\\) captures the aquifer's total influx capacity:</p> \\[B = \\frac{1.119 \\cdot \\phi \\cdot c_t \\cdot (r_e^2 - r_w^2) \\cdot h \\cdot \\theta}{360 \\cdot \\mu_w}\\] <p>where \\(\\phi\\) is porosity, \\(c_t\\) is total compressibility, \\(r_e\\) and \\(r_w\\) are the outer and inner radii, \\(h\\) is thickness, \\(\\theta\\) is the angle of aquifer contact, and \\(\\mu_w\\) is water viscosity.</p>"},{"location":"user-guide/advanced/aquifers/#physical-properties-mode-recommended","title":"Physical Properties Mode (Recommended)","text":"<p>The recommended way to configure a Carter-Tracy aquifer is by specifying the physical properties of the aquifer rock and fluid:</p> <pre><code>from bores.boundary_conditions import (\n    CarterTracyAquifer,\n    GridBoundaryCondition,\n    BoundaryConditions,\n)\n\n# Edge water drive with known aquifer properties\nedge_aquifer = CarterTracyAquifer(\n    aquifer_permeability=500.0,        # mD\n    aquifer_porosity=0.25,             # fraction\n    aquifer_compressibility=3e-6,      # psi-1 (rock + water)\n    water_viscosity=0.5,               # cP\n    inner_radius=1000.0,               # ft (reservoir-aquifer contact)\n    outer_radius=10000.0,              # ft (aquifer outer boundary)\n    aquifer_thickness=50.0,            # ft\n    initial_pressure=2500.0,           # psi\n    angle=180.0,                       # degrees (half-circle, edge drive)\n)\n</code></pre> <p>In this mode, BORES computes the aquifer constant \\(B\\) and the dimensionless time \\(t_D\\) from first principles. This gives you physically meaningful parameters that you can vary independently for sensitivity analysis.</p>"},{"location":"user-guide/advanced/aquifers/#parameter-descriptions","title":"Parameter Descriptions","text":"Parameter Unit Description <code>aquifer_permeability</code> mD Aquifer rock permeability <code>aquifer_porosity</code> fraction Aquifer rock porosity <code>aquifer_compressibility</code> psi-1 Total compressibility (rock + water) <code>water_viscosity</code> cP Aquifer water viscosity <code>inner_radius</code> ft Radius at reservoir-aquifer contact <code>outer_radius</code> ft Outer radius of aquifer extent <code>aquifer_thickness</code> ft Net aquifer thickness <code>initial_pressure</code> psi Initial equilibrium pressure <code>angle</code> degrees Angular extent of aquifer contact"},{"location":"user-guide/advanced/aquifers/#aquifer-geometry","title":"Aquifer Geometry","text":"<p>The <code>angle</code> parameter controls how much of the reservoir perimeter is in contact with the aquifer:</p> <ul> <li>360 degrees: Full radial aquifer (reservoir surrounded by aquifer)</li> <li>180 degrees: Half-circle (edge water drive from one side)</li> <li>90 degrees: Quarter-circle (corner aquifer)</li> </ul> <p>The <code>inner_radius</code> should match the effective radius of the reservoir at the aquifer contact. For a rectangular reservoir, this is approximately \\(\\sqrt{A/\\pi}\\) where \\(A\\) is the reservoir area.</p>"},{"location":"user-guide/advanced/aquifers/#dimensionless-radius-ratio","title":"Dimensionless Radius Ratio","text":"<p>The ratio \\(r_D = r_e / r_w\\) (outer radius / inner radius) controls how quickly the aquifer's finite boundaries affect the response:</p> <ul> <li>Small \\(r_D\\) (2 to 5): Small aquifer, boundary effects appear early, influx declines quickly</li> <li>Large \\(r_D\\) (10 to 50): Large aquifer, behaves as infinite for a long time before declining</li> <li>Very large \\(r_D\\) (&gt; 100): Effectively infinite aquifer within the simulation timeframe</li> </ul>"},{"location":"user-guide/advanced/aquifers/#calibrated-constant-mode","title":"Calibrated Constant Mode","text":"<p>When the physical properties of the aquifer are uncertain (common in practice), you can specify a pre-computed aquifer constant from history matching:</p> <pre><code>calibrated_aquifer = CarterTracyAquifer(\n    aquifer_constant=5000.0,             # Pre-computed B value\n    dimensionless_radius_ratio=10.0,     # r_e / r_w\n    initial_pressure=2500.0,\n)\n</code></pre> <p>In this mode, the aquifer constant \\(B\\) is used directly without computing it from physical properties. This is useful when you have calibrated \\(B\\) from a history match but do not know the individual aquifer properties that produce that value.</p>"},{"location":"user-guide/advanced/aquifers/#applying-the-aquifer","title":"Applying the Aquifer","text":"<p>The aquifer is applied as a boundary condition on one or more grid faces. Since <code>BoundaryConditions</code> maps property names to <code>GridBoundaryCondition</code> objects, you assign the aquifer to the pressure boundary:</p> <pre><code>from bores.boundary_conditions import BoundaryConditions, GridBoundaryCondition\n\n# Edge aquifer on the left face\nboundary_conditions = BoundaryConditions(\n    conditions={\n        \"pressure\": GridBoundaryCondition(\n            left=edge_aquifer,\n        ),\n    },\n)\n\nconfig = bores.Config(\n    timer=timer,\n    rock_fluid_tables=rock_fluid,\n    wells=wells,\n    boundary_conditions=boundary_conditions,\n)\n</code></pre>"},{"location":"user-guide/advanced/aquifers/#bottom-water-drive","title":"Bottom Water Drive","text":"<p>For a bottom water drive (aquifer below the reservoir), apply the aquifer to the bottom face:</p> <pre><code>bottom_aquifer = CarterTracyAquifer(\n    aquifer_permeability=800.0,\n    aquifer_porosity=0.28,\n    aquifer_compressibility=4e-6,\n    water_viscosity=0.4,\n    inner_radius=2000.0,\n    outer_radius=15000.0,\n    aquifer_thickness=100.0,\n    initial_pressure=2800.0,\n    angle=360.0,  # Full contact from below\n)\n\nboundary_conditions = BoundaryConditions(\n    conditions={\n        \"pressure\": GridBoundaryCondition(\n            bottom=bottom_aquifer,\n        ),\n    },\n)\n</code></pre>"},{"location":"user-guide/advanced/aquifers/#aquifer-behavior-over-time","title":"Aquifer Behavior Over Time","text":"<p>The Carter-Tracy aquifer response has three characteristic phases:</p> <ol> <li> <p>Early time (infinite-acting): The pressure disturbance has not reached the outer boundary. All aquifer sizes produce the same influx rate at early time. The dimensionless influx function \\(W_D'\\) follows the infinite-acting solution.</p> </li> <li> <p>Transition: The pressure disturbance reaches the outer boundary. The influx rate begins to deviate from the infinite-acting solution. Smaller aquifers (smaller \\(r_D\\)) enter this phase sooner.</p> </li> <li> <p>Late time (boundary-dominated): The aquifer's finite energy is being depleted. The influx rate declines, and the aquifer pressure converges toward the reservoir pressure. Eventually, the aquifer can no longer provide meaningful pressure support.</p> </li> </ol> <p>The transition time scales approximately as \\(t_D \\propto r_D^2\\). A ten-fold increase in the radius ratio delays boundary effects by approximately 100 times.</p>"},{"location":"user-guide/advanced/aquifers/#comparison-of-aquifer-models","title":"Comparison of Aquifer Models","text":"Model Complexity Pressure Support Best For No-flow boundary None None Sealed reservoirs, initial screening Constant pressure Low Infinite Strong aquifers, short simulations Carter-Tracy Moderate Finite, declining Production forecasting, history matching <p>When to Use Carter-Tracy</p> <p>Use Carter-Tracy when:</p> <ul> <li>You need realistic pressure decline forecasts</li> <li>The aquifer has a known or estimated finite extent</li> <li>You are history matching production data and need pressure support calibration</li> <li>The simulation runs long enough for aquifer depletion to matter</li> </ul> <p>Use constant pressure when:</p> <ul> <li>The aquifer is very large relative to the reservoir</li> <li>The simulation period is short relative to the aquifer response time</li> <li>You want a simple upper bound on aquifer support</li> </ul>"},{"location":"user-guide/advanced/boundary-conditions/","title":"Boundary Conditions","text":""},{"location":"user-guide/advanced/boundary-conditions/#overview","title":"Overview","text":"<p>Boundary conditions define how the edges of your simulation grid interact with the outside world. By default, all grid boundaries are no-flow (closed), meaning no fluid enters or leaves through any face of the grid. This is appropriate for many reservoir simulations where the reservoir is bounded by impermeable rock, but many real reservoirs have open boundaries that communicate with aquifers, adjacent formations, or surface conditions.</p> <p>BORES provides several boundary condition types that model different physical situations. You can set different conditions on each face of the grid (left, right, front, back, top, bottom), and you can combine multiple boundary types to model complex reservoir geometries. Each boundary condition specifies the physical behavior at one or more grid faces.</p> <p>The boundary condition system follows the standard classification from partial differential equations: Dirichlet (fixed value), Neumann (fixed flux), and Robin (mixed) conditions. In reservoir simulation terms, these correspond to constant pressure boundaries, fixed injection/production rate boundaries, and boundaries with pressure-dependent flow, respectively.</p>"},{"location":"user-guide/advanced/boundary-conditions/#boundary-condition-types","title":"Boundary Condition Types","text":""},{"location":"user-guide/advanced/boundary-conditions/#no-flow-default","title":"No-Flow (Default)","text":"<p>No-flow boundaries prevent any fluid from crossing the boundary face. This is the default for all grid faces and represents impermeable rock surrounding the reservoir.</p> <pre><code>from bores.boundary_conditions import NoFlowBoundary\n\nno_flow = NoFlowBoundary()\n</code></pre> <p>You rarely need to create <code>NoFlowBoundary</code> objects explicitly because they are applied automatically to all faces that do not have another condition assigned.</p>"},{"location":"user-guide/advanced/boundary-conditions/#constant-pressure-dirichlet","title":"Constant Pressure (Dirichlet)","text":"<p>A constant pressure boundary maintains a fixed pressure on the boundary face. Fluid flows into or out of the reservoir to maintain this pressure. This models an infinite aquifer or a large connected volume that acts as a pressure source or sink.</p> <pre><code>from bores.boundary_conditions import ConstantBoundary\n\n# 2500 psi on the left face\nconstant_p = ConstantBoundary(value=2500.0)\n</code></pre> <p>Constant pressure boundaries provide infinite pressure support. If the reservoir pressure drops below the boundary pressure, water flows in. If it rises above, fluid flows out. This is the simplest aquifer model but is unrealistic for finite aquifers that lose pressure support over time.</p>"},{"location":"user-guide/advanced/boundary-conditions/#fixed-flux-neumann","title":"Fixed Flux (Neumann)","text":"<p>A flux boundary specifies a fixed volumetric flow rate across the boundary face. Positive values indicate inflow (injection), negative values indicate outflow (production).</p> <pre><code>from bores.boundary_conditions import FluxBoundary\n\n# Inject 100 RB/day through the bottom face\ninflux = FluxBoundary(value=100.0)\n\n# Produce 50 RB/day from the right face\noutflux = FluxBoundary(value=-50.0)\n</code></pre> <p>Sign Convention</p> <p>Throughout BORES, positive flow means injection (into the reservoir) and negative flow means production (out of the reservoir). This applies to wells, boundary conditions, and all flow terms.</p>"},{"location":"user-guide/advanced/boundary-conditions/#linear-gradient","title":"Linear Gradient","text":"<p>A linear gradient boundary applies a pressure that varies linearly across the boundary face:</p> <pre><code>from bores.boundary_conditions import LinearGradientBoundary\n\n# Pressure varies from 2500 to 2800 psi across the face\ngradient = LinearGradientBoundary(\n    base_value=2500.0,\n    gradient=0.5,  # psi per ft\n)\n</code></pre> <p>This is useful for modeling tilted aquifer contacts or regional pressure gradients.</p>"},{"location":"user-guide/advanced/boundary-conditions/#time-dependent-boundary","title":"Time-Dependent Boundary","text":"<p>A time-dependent boundary changes its value according to a function of time:</p> <pre><code>from bores.boundary_conditions import TimeDependentBoundary\n\n# Pressure that declines over time\ndef declining_pressure(t):\n    \"\"\"t is time in seconds.\"\"\"\n    return 2500.0 - 0.1 * (t / 86400.0)  # 0.1 psi/day decline\n\ntime_bc = TimeDependentBoundary(function=declining_pressure)\n</code></pre>"},{"location":"user-guide/advanced/boundary-conditions/#periodic-boundary","title":"Periodic Boundary","text":"<p>Periodic boundaries connect opposite faces of the grid, so fluid leaving one face enters the opposite face. This creates a repeating tile pattern and is useful for simulating a small section of a larger, repeating well pattern.</p> <pre><code>from bores.boundary_conditions import PeriodicBoundary\n\nperiodic = PeriodicBoundary()\n</code></pre> <p>Periodic Boundary Pairing</p> <p>Periodic boundaries must be applied to both opposite faces simultaneously. If the left face is periodic, the right face must also be periodic. BORES validates this during configuration and raises a <code>ValidationError</code> if periodic boundaries are not properly paired.</p>"},{"location":"user-guide/advanced/boundary-conditions/#robin-mixed-boundary","title":"Robin (Mixed) Boundary","text":"<p>A Robin boundary combines Dirichlet and Neumann conditions, specifying a relationship between the boundary value and the flux. This is useful for modeling semi-permeable barriers.</p> <pre><code>from bores.boundary_conditions import RobinBoundary\n\nrobin = RobinBoundary(alpha=1.0, beta=0.5, gamma=2500.0)\n</code></pre> <p>The Robin condition is: \\(\\alpha \\cdot u + \\beta \\cdot \\frac{\\partial u}{\\partial n} = \\gamma\\), where \\(u\\) is the variable (pressure), \\(n\\) is the outward normal, and \\(\\alpha\\), \\(\\beta\\), \\(\\gamma\\) are parameters.</p>"},{"location":"user-guide/advanced/boundary-conditions/#custom-boundary-functions","title":"Custom Boundary Functions","text":"<p>For complex boundary behavior that is not captured by the built-in types, you can define custom boundary functions and register them for serialization:</p> <pre><code>from bores.boundary_conditions import boundary_function, SpatialBoundary\n\n@boundary_function\ndef hydrostatic_pressure(x, y, depth):\n    \"\"\"Hydrostatic pressure gradient at the boundary.\"\"\"\n    return 14.696 + 0.433 * depth\n\nspatial_bc = SpatialBoundary(function=hydrostatic_pressure)\n</code></pre> <p>The <code>@boundary_function</code> decorator registers the function by name, enabling it to be serialized and loaded from disk. Without registration, custom boundary functions cannot be saved as part of a simulation configuration.</p>"},{"location":"user-guide/advanced/boundary-conditions/#applying-boundary-conditions","title":"Applying Boundary Conditions","text":"<p><code>BoundaryConditions</code> is a defaultdict that maps property names (strings) to <code>GridBoundaryCondition</code> objects. Each <code>GridBoundaryCondition</code> assigns a boundary type to each face of the grid. The property name tells BORES which equation the boundary applies to (for example, <code>\"pressure\"</code> for the pressure equation, <code>\"temperature\"</code> for heat transfer).</p> <pre><code>from bores.boundary_conditions import (\n    GridBoundaryCondition,\n    BoundaryConditions,\n    ConstantBoundary,\n    NoFlowBoundary,\n    FluxBoundary,\n)\n\nboundary_conditions = BoundaryConditions(\n    conditions={\n        \"pressure\": GridBoundaryCondition(\n            left=ConstantBoundary(constant=2500.0),\n            right=NoFlowBoundary(),\n            front=NoFlowBoundary(),\n            back=NoFlowBoundary(),\n            top=NoFlowBoundary(),\n            bottom=ConstantBoundary(constant=2600.0),\n        ),\n    },\n)\n\nconfig = bores.Config(\n    timer=timer,\n    rock_fluid_tables=rock_fluid,\n    wells=wells,\n    boundary_conditions=boundary_conditions,\n)\n</code></pre> <p>The six faces are <code>left</code> (x=0), <code>right</code> (x=max), <code>front</code> (y=0), <code>back</code> (y=max), <code>top</code> (z=0), and <code>bottom</code> (z=max). Any face without an explicit condition defaults to no-flow. Any property name not present in the dictionary also defaults to all no-flow through the defaultdict factory.</p>"},{"location":"user-guide/advanced/boundary-conditions/#multiple-property-boundaries","title":"Multiple Property Boundaries","text":"<p>You can define separate boundary conditions for different properties. For example, pressure and temperature may have different boundary behavior:</p> <pre><code>boundary_conditions = BoundaryConditions(\n    conditions={\n        \"pressure\": GridBoundaryCondition(\n            left=ConstantBoundary(constant=2500.0),\n            right=NoFlowBoundary(),\n        ),\n        \"temperature\": GridBoundaryCondition(\n            left=ConstantBoundary(constant=180.0),\n            right=NoFlowBoundary(),\n        ),\n    },\n)\n</code></pre>"},{"location":"user-guide/advanced/boundary-conditions/#default-factory","title":"Default Factory","text":"<p>You can provide a custom default factory that creates the <code>GridBoundaryCondition</code> used for any property not explicitly listed:</p> <pre><code>boundary_conditions = BoundaryConditions(\n    conditions={\n        \"pressure\": GridBoundaryCondition(\n            left=ConstantBoundary(constant=2500.0),\n        ),\n    },\n    factory=lambda: GridBoundaryCondition(\n        left=NoFlowBoundary(),\n        right=NoFlowBoundary(),\n        front=NoFlowBoundary(),\n        back=NoFlowBoundary(),\n    ),\n)\n</code></pre>"},{"location":"user-guide/advanced/boundary-conditions/#saturation-normalization","title":"Saturation Normalization","text":"<p>After applying boundary conditions at each time step, BORES normalizes saturations to ensure \\(S_o + S_w + S_g = 1.0\\) in every cell. Boundary conditions can inject or remove specific phases, which may temporarily violate the saturation sum constraint. The normalization step restores physical consistency using safe division to handle near-zero total saturations.</p>"},{"location":"user-guide/advanced/boundary-conditions/#carter-tracy-aquifer","title":"Carter-Tracy Aquifer","text":"<p>For a realistic finite aquifer model, see the dedicated Aquifers page, which covers the Carter-Tracy semi-analytical aquifer model in detail.</p>"},{"location":"user-guide/advanced/fractures/","title":"Faults and Fractures","text":""},{"location":"user-guide/advanced/fractures/#overview","title":"Overview","text":"<p>Faults and fractures are geological discontinuities that profoundly affect fluid flow in reservoirs. A fault is a surface along which rock layers have been displaced, often creating a barrier (or sometimes a conduit) to cross-fault flow. A fracture is a crack or opening in the rock that creates an enhanced permeability pathway. Both are modeled in BORES through transmissibility multipliers, following the same approach used by commercial simulators.</p> <p>The transmissibility multiplier approach works by scaling the inter-block flow transmissibility across fault or fracture planes. A multiplier of 0.0001 means the fault reduces cross-fault flow to 0.01% of what the matrix permeability alone would allow (a nearly sealing fault). A multiplier of 10.0 means the fracture enhances flow to 10 times the matrix value. A multiplier of 1.0 has no effect (no fault or fracture).</p> <p>This approach has several advantages. It does not require changes to the grid geometry, so wells, boundary conditions, and property distributions remain unaffected. The fault masks are computed once during model setup and apply minimal overhead at runtime. Multiple faults can be combined through vectorized operations, and the Numba JIT-compiled mask generation functions ensure fast setup even for large grids.</p>"},{"location":"user-guide/advanced/fractures/#factory-functions","title":"Factory Functions","text":"<p>BORES provides four factory functions for creating common fault and fracture configurations. These are the recommended entry points, as they handle geometry validation and mask generation automatically.</p>"},{"location":"user-guide/advanced/fractures/#vertical-sealing-faults","title":"Vertical Sealing Faults","text":"<p>The most common fault type is a vertical plane that acts as a barrier to cross-fault flow:</p> <pre><code>from bores.fractures import vertical_sealing_fault, apply_fracture\n\n# Vertical fault at x=25, spanning the entire grid\nfault = vertical_sealing_fault(\n    fault_id=\"main_fault\",\n    orientation=\"x\",\n    index=25,\n    permeability_multiplier=1e-4,  # 99.99% sealing\n)\n\nmodel = apply_fracture(model=reservoir_model, fracture=fault)\n</code></pre> <p>The <code>orientation</code> parameter specifies which axis the fault plane is perpendicular to. An <code>\"x\"</code>-oriented fault creates a plane in the y-z direction at the specified x-index, blocking flow in the x-direction across that plane.</p> <p>You can limit the fault extent using range parameters:</p> <pre><code># Fault in upper layers only\nshallow_fault = vertical_sealing_fault(\n    fault_id=\"shallow_fault\",\n    orientation=\"y\",\n    index=40,\n    z_range=(0, 15),         # Only in upper 16 layers\n    permeability_multiplier=5e-5,\n)\n\n# Fault with limited lateral extent\npartial_fault = vertical_sealing_fault(\n    fault_id=\"fault_f3\",\n    orientation=\"x\",\n    index=50,\n    permeability_multiplier=0.01,\n    y_range=(0, 60),          # Limited lateral extent\n    z_range=(10, 35),         # Offsetting layers 10-35\n)\n</code></pre>"},{"location":"user-guide/advanced/fractures/#inclined-faults","title":"Inclined Faults","text":"<p>Non-vertical faults are modeled using a slope parameter that tilts the fault plane:</p> <pre><code>from bores.fractures import inclined_sealing_fault\n\n# Fault dipping at 60 degrees (slope = tan(60) = 1.73)\ndipping_fault = inclined_sealing_fault(\n    fault_id=\"dipping_fault\",\n    orientation=\"y\",          # Strikes in y-direction\n    index=30,                 # Intersects at y=30\n    slope=1.73,               # dz/dx (eastward dip)\n    intercept=5.0,            # Fault at z=5 when x=0\n    permeability_multiplier=1e-4,\n)\n</code></pre> <p>The slope defines the fault plane equation. For y-oriented faults, the equation is \\(z = \\text{intercept} + \\text{slope} \\times x\\). The fault mask marks grid cells that intersect this plane.</p>"},{"location":"user-guide/advanced/fractures/#damage-zone-faults","title":"Damage Zone Faults","text":"<p>Major faults often have a zone of damaged rock with altered permeability and porosity:</p> <pre><code>from bores.fractures import damage_zone_fault\n\nfault_with_damage = damage_zone_fault(\n    fault_id=\"thrust_fault\",\n    orientation=\"x\",\n    cell_range=(48, 52),          # 5 cells wide\n    permeability_multiplier=1e-5, # Very low cross-fault flow\n    zone_permeability=10.0,       # Damaged rock: 10 mD (vs 100 mD matrix)\n    zone_porosity=0.12,           # Reduced porosity (vs 0.20 matrix)\n    z_range=(15, 45),\n)\n</code></pre> <p>The <code>cell_range</code> parameter specifies the width of the damage zone in grid cells. The <code>zone_permeability</code> and <code>zone_porosity</code> values are applied to all cells within the zone, overriding the original matrix properties.</p>"},{"location":"user-guide/advanced/fractures/#conductive-fracture-networks","title":"Conductive Fracture Networks","text":"<p>Natural or hydraulic fractures that enhance permeability are modeled with <code>conductive_fracture_network</code>:</p> <pre><code>from bores.fractures import conductive_fracture_network\n\nfracture_swarm = conductive_fracture_network(\n    fracture_id=\"fracture_corridor\",\n    orientation=\"y\",\n    cell_range=(15, 18),              # 3-cell-wide corridor\n    fracture_permeability=5000.0,     # High perm: 5 Darcy\n    fracture_porosity=0.01,           # Low storage (fractures)\n    permeability_multiplier=10.0,     # 10x enhanced cross-corridor flow\n    z_range=(20, 40),\n)\n</code></pre> <p>Unlike sealing faults where the multiplier reduces flow, conductive fractures use multipliers greater than 1.0 to enhance cross-fracture flow. The <code>fracture_permeability</code> and <code>fracture_porosity</code> are applied to cells within the fracture corridor.</p>"},{"location":"user-guide/advanced/fractures/#applying-faults-to-a-model","title":"Applying Faults to a Model","text":""},{"location":"user-guide/advanced/fractures/#single-fault","title":"Single Fault","text":"<pre><code>from bores.fractures import apply_fracture\n\nmodel = apply_fracture(model=reservoir_model, fracture=fault)\n</code></pre>"},{"location":"user-guide/advanced/fractures/#multiple-faults","title":"Multiple Faults","text":"<p>For compartmentalized reservoirs with multiple faults, use <code>apply_fractures</code> to apply them all at once:</p> <pre><code>from bores.fractures import apply_fractures, vertical_sealing_fault\n\nfaults = [\n    vertical_sealing_fault(\"fault_1\", \"x\", 25, permeability_multiplier=1e-4),\n    vertical_sealing_fault(\"fault_2\", \"y\", 35, permeability_multiplier=5e-4),\n    vertical_sealing_fault(\"fault_3\", \"x\", 60, permeability_multiplier=2e-4),\n]\n\nmodel = apply_fractures(reservoir_model, *faults)\n</code></pre> <p><code>apply_fractures</code> handles the efficient combination of multiple fault masks using vectorized operations.</p>"},{"location":"user-guide/advanced/fractures/#horizontal-barriers","title":"Horizontal Barriers","text":"<p>You can model horizontal barriers (shale layers, tight streaks, cemented zones) using the <code>\"z\"</code> orientation:</p> <pre><code>shale_barrier = vertical_sealing_fault(\n    fault_id=\"shale_layer\",\n    orientation=\"z\",          # Horizontal plane\n    index=12,                 # At layer 12\n    permeability_multiplier=1e-6,\n    x_range=(0, 80),\n    y_range=(0, 60),\n)\n</code></pre> <p>This creates a horizontal barrier that reduces vertical flow across layer 12 to 0.0001% of the matrix transmissibility. This is useful for modeling interbedded shales, tight carbonate stringers, or any low-permeability layer that compartmentalizes the reservoir vertically.</p>"},{"location":"user-guide/advanced/fractures/#fracture-geometry","title":"Fracture Geometry","text":"<p>The <code>FractureGeometry</code> class defines the spatial extent and orientation of a fault or fracture. The factory functions create this automatically, but you can also build it directly:</p> <pre><code>from bores.fractures import FractureGeometry\n\n# Vertical fault at x=25, limited extent\ngeom = FractureGeometry(\n    orientation=\"x\",\n    x_range=(25, 25),         # Single cell plane\n    y_range=(10, 40),         # Lateral extent\n    z_range=(0, 20),          # Vertical extent\n    slope=0.0,                # Vertical (no dip)\n    intercept=0.0,\n)\n</code></pre> <p>The range parameters use inclusive grid indices. Setting a range to <code>None</code> means the fault extends across the full grid dimension in that direction.</p>"},{"location":"user-guide/advanced/fractures/#validation","title":"Validation","text":"<p>Before applying faults, you can validate their configuration against the grid shape:</p> <pre><code>from bores.fractures import validate_fracture\n\nerrors = validate_fracture(fracture=fault, grid_shape=(100, 80, 50))\nif errors:\n    for error in errors:\n        print(f\"Validation error: {error}\")\n</code></pre> <p>Validation checks that all range indices are within the grid bounds and that the geometry is internally consistent (minimum index is less than or equal to maximum index, orientation has the required primary range).</p>"},{"location":"user-guide/advanced/fractures/#choosing-permeability-multipliers","title":"Choosing Permeability Multipliers","text":"Fault Type Multiplier Range Description Completely sealing 1e-6 to 1e-5 No cross-fault flow Highly sealing 1e-4 to 1e-3 Very little cross-fault flow Partially sealing 0.01 to 0.1 Some cross-fault flow Leaky fault 0.1 to 0.5 Significant cross-fault flow No barrier 1.0 No effect on flow Conductive fracture 1.0 to 100.0 Enhanced flow <p>In practice, fault transmissibility multipliers are calibrated through history matching. Start with estimates from geological interpretation (seismically mapped faults are often more sealing than sub-seismic fractures) and refine based on well test interference data, tracer studies, or production history.</p> <p>Damage Zone Properties</p> <p>For damage zone faults, typical property alterations are:</p> <ul> <li>Permeability reduction: 10x to 100x relative to matrix</li> <li>Porosity reduction: 20% to 40% of matrix values</li> <li>Zone width: 1% to 10% of fault displacement</li> </ul>"},{"location":"user-guide/advanced/miscibility/","title":"Miscible Flooding","text":""},{"location":"user-guide/advanced/miscibility/#overview","title":"Overview","text":"<p>Miscible flooding is an enhanced oil recovery (EOR) technique where the injected gas dissolves into and mixes with the reservoir oil at the molecular level, eliminating the interfacial tension between the gas and oil phases. When interfacial tension vanishes, residual oil trapping ceases, and the displacement efficiency approaches 100% in the swept zone. This makes miscible flooding dramatically more effective than immiscible gas injection, where gas bypasses trapped oil due to capillary forces.</p> <p>Miscibility occurs when the reservoir pressure exceeds the minimum miscibility pressure (MMP), a property that depends on the compositions of both the injection gas and the reservoir oil. Below the MMP, the gas and oil remain as distinct phases with a clear interface. Above the MMP, they mix freely. In real reservoirs, there is a transition zone near the MMP where the fluids are partially miscible.</p> <p>BORES implements miscible flooding through the Todd-Longstaff mixing model, which is the industry standard for black-oil simulators. The Todd-Longstaff model introduces a mixing parameter \\(\\omega\\) (omega) that controls the degree of mixing between the solvent (injected gas) and the oil. When \\(\\omega = 0\\), the phases are completely segregated (immiscible). When \\(\\omega = 1\\), they are fully mixed. Intermediate values represent partial mixing.</p> <p>The model computes effective viscosities and densities for the mixed fluid using the mixing parameter:</p> \\[\\mu_{\\text{eff}} = \\mu_{\\text{mix}}^{\\omega} \\cdot \\mu_{\\text{seg}}^{1-\\omega}\\] \\[\\rho_{\\text{eff}} = \\rho_{\\text{mix}}^{\\omega} \\cdot \\rho_{\\text{seg}}^{1-\\omega}\\] <p>where \\(\\mu_{\\text{mix}}\\) and \\(\\rho_{\\text{mix}}\\) are the fully mixed properties and \\(\\mu_{\\text{seg}}\\) and \\(\\rho_{\\text{seg}}\\) are the segregated (immiscible) properties.</p>"},{"location":"user-guide/advanced/miscibility/#enabling-miscible-flooding","title":"Enabling Miscible Flooding","text":"<p>To enable miscible flooding, you need two things: an <code>InjectedFluid</code> configured for miscibility and a <code>Config</code> that uses the Todd-Longstaff miscibility model.</p>"},{"location":"user-guide/advanced/miscibility/#configuring-the-injected-fluid","title":"Configuring the Injected Fluid","text":"<pre><code>import bores\n\nco2_fluid = bores.InjectedFluid(\n    name=\"CO2\",\n    phase=bores.FluidPhase.GAS,\n    specific_gravity=1.52,\n    molecular_weight=44.01,\n    is_miscible=True,\n    minimum_miscibility_pressure=1200.0,  # psi\n)\n</code></pre> <p>The key parameters are:</p> <ul> <li><code>is_miscible=True</code>: Enables miscibility calculations for this fluid</li> <li><code>minimum_miscibility_pressure</code>: The pressure above which the gas achieves first-contact miscibility with the oil. Below this pressure, miscibility effects are reduced through a smooth pressure-dependent transition.</li> </ul>"},{"location":"user-guide/advanced/miscibility/#configuring-the-simulation","title":"Configuring the Simulation","text":"<pre><code>config = bores.Config(\n    timer=bores.Timer(\n        initial_step_size=bores.Time(hours=6),\n        max_step_size=bores.Time(days=3),\n        min_step_size=bores.Time(minutes=30),\n        simulation_time=bores.Time(years=3),\n    ),\n    rock_fluid_tables=rock_fluid,\n    wells=wells,\n    miscibility_model=\"todd_longstaff\",\n    freeze_saturation_pressure=False,\n)\n</code></pre> <p>Setting <code>miscibility_model=\"todd_longstaff\"</code> activates the Todd-Longstaff mixing calculations. Setting <code>freeze_saturation_pressure=False</code> allows the bubble point pressure to update as the solvent dissolves into the oil, which is important for capturing the compositional effects of miscible flooding.</p>"},{"location":"user-guide/advanced/miscibility/#the-todd-longstaff-model","title":"The Todd-Longstaff Model","text":"<p>The Todd-Longstaff model tracks the solvent concentration \\(C\\) in each grid cell as a volume fraction (0 to 1). The concentration evolves through advection: solvent is transported with the oil-phase velocity, upwinding the concentration at cell faces based on the direction of oil flow.</p>"},{"location":"user-guide/advanced/miscibility/#mixing-parameter-omega","title":"Mixing Parameter (\\(\\omega\\))","text":"<p>The mixing parameter \\(\\omega\\) is set globally through the <code>InjectedFluid</code> configuration. The default value (when not explicitly set) depends on the pressure relative to the MMP:</p> <ul> <li>Above MMP: \\(\\omega\\) approaches 1.0 (fully miscible)</li> <li>Below MMP: \\(\\omega\\) approaches 0.0 (immiscible)</li> <li>Near MMP: Smooth transition using a hyperbolic tangent function</li> </ul> <p>This pressure-dependent miscibility means the simulation automatically handles situations where reservoir pressure drops below the MMP in some regions (for example, near a low-pressure producer), reducing miscibility in those regions while maintaining full miscibility where pressure is sufficient.</p>"},{"location":"user-guide/advanced/miscibility/#effective-viscosity","title":"Effective Viscosity","text":"<p>The effective oil-phase viscosity in each cell depends on the local solvent concentration and the mixing parameter:</p> \\[\\mu_{\\text{mix}} = \\mu_o^{1-C} \\cdot \\mu_s^{C}\\] \\[\\mu_{\\text{eff}} = \\mu_{\\text{mix}}^{\\omega} \\cdot \\mu_o^{1-\\omega}\\] <p>where \\(\\mu_o\\) is the oil viscosity, \\(\\mu_s\\) is the solvent viscosity, and \\(C\\) is the solvent concentration. When \\(\\omega = 1\\) and \\(C = 1\\) (fully mixed, pure solvent), the effective viscosity equals the solvent viscosity. When \\(\\omega = 0\\) (completely segregated), the effective viscosity equals the oil viscosity regardless of concentration.</p>"},{"location":"user-guide/advanced/miscibility/#effective-density","title":"Effective Density","text":"<p>The density mixing follows the same pattern:</p> \\[\\rho_{\\text{mix}} = \\rho_o^{1-C} \\cdot \\rho_s^{C}\\] \\[\\rho_{\\text{eff}} = \\rho_{\\text{mix}}^{\\omega} \\cdot \\rho_o^{1-\\omega}\\]"},{"location":"user-guide/advanced/miscibility/#custom-fluid-properties","title":"Custom Fluid Properties","text":"<p>For gases like CO2 that deviate significantly from standard correlations, you can provide override values for density and viscosity:</p> <pre><code>co2_fluid = bores.InjectedFluid(\n    name=\"CO2\",\n    phase=bores.FluidPhase.GAS,\n    specific_gravity=1.52,\n    molecular_weight=44.01,\n    is_miscible=True,\n    minimum_miscibility_pressure=1200.0,\n    density=35.0,      # lbm/ft3 from lab data or EOS\n    viscosity=0.05,    # cP from lab data or EOS\n)\n</code></pre> <p>CO2 density at reservoir conditions is typically around 35 lbm/ft3, while the standard gas correlations predict only 3 to 7 lbm/ft3. Similarly, CO2 viscosity is around 0.05 cP versus the correlation prediction of 0.01 to 0.02 cP. Using the override values improves accuracy by approximately 25%.</p>"},{"location":"user-guide/advanced/miscibility/#solvent-concentration-transport","title":"Solvent Concentration Transport","text":"<p>The solvent concentration is transported using pure advection (no diffusion). At each time step, the concentration in each cell is updated based on the oil-phase velocity at cell faces, using upwinding to ensure numerical stability:</p> <ol> <li>The oil velocity at each cell face determines the flow direction</li> <li>The upstream cell's concentration is used for the solvent flux</li> <li>The concentration is updated based on the net flux into each cell</li> <li>A dissolution limit prevents concentration from exceeding 1.0 in low-saturation cells</li> </ol> <p>The dissolution limit is physically important. In cells with very low oil saturation, a small volume of injected solvent could push the concentration above 1.0 (unphysical). BORES computes the maximum dissolvable volume before each update and caps the concentration accordingly.</p>"},{"location":"user-guide/advanced/miscibility/#time-step-considerations","title":"Time Step Considerations","text":"<p>Miscible flooding requires smaller time steps than immiscible injection for two reasons. First, the concentration transport equation is explicit and subject to CFL constraints. Second, the viscosity and density changes near the miscible front are large and rapid, requiring small steps to accurately capture the front shape.</p> <p>Recommended timer settings for miscible flooding:</p> <pre><code>timer = bores.Timer(\n    initial_step_size=bores.Time(hours=6),\n    max_step_size=bores.Time(days=3),\n    min_step_size=bores.Time(minutes=30),\n    simulation_time=bores.Time(years=3),\n)\n</code></pre> <p>If you encounter convergence issues, try reducing <code>max_step_size</code> to 1 to 2 days or tightening the gas saturation change limit:</p> <pre><code>config = bores.Config(\n    ...,\n    max_gas_saturation_change=0.5,\n    max_pressure_change=75.0,\n)\n</code></pre>"},{"location":"user-guide/advanced/miscibility/#comparison-immiscible-vs-miscible-gas-injection","title":"Comparison: Immiscible vs. Miscible Gas Injection","text":"Aspect Immiscible Miscible Gas-oil interfacial tension Non-zero Zero (above MMP) Residual oil in swept zone Sorg (typically 15-25%) Approaches 0% Microscopic displacement efficiency Moderate Near 100% Gravity override Severe Still present Viscosity reduction None Significant Required pressure Any Above MMP Config setting <code>miscibility_model=\"immiscible\"</code> <code>miscibility_model=\"todd_longstaff\"</code> <p>Sweep Efficiency vs. Displacement Efficiency</p> <p>Miscibility eliminates residual oil in the swept zone (high displacement efficiency), but it does not solve the gravity override problem (sweep efficiency). Gas is still lighter and more mobile than oil, so it preferentially flows through the upper part of the reservoir. The total recovery is the product of sweep efficiency and displacement efficiency. Miscible flooding with poor sweep can still underperform a well-designed waterflood.</p>"},{"location":"user-guide/advanced/model-analysis/","title":"Model Analysis","text":""},{"location":"user-guide/advanced/model-analysis/#overview","title":"Overview","text":"<p>After running a simulation, you need to evaluate how the reservoir performed: how much oil was recovered, which drive mechanisms dominated, how efficiently the waterflood swept the reservoir, whether wells are producing optimally, and what future production might look like. The <code>ModelAnalyst</code> class provides all of these analyses in a single, coherent API.</p> <p>The analyst accepts a collection of <code>ModelState</code> objects and indexes them by step number. From there, it can compute original oil and gas in place (STOIIP, STGIIP), cumulative production and injection volumes, instantaneous flow rates, material balance drive indices, sweep efficiency metrics, well productivity, voidage replacement ratios, decline curves, production forecasts, and estimated ultimate recovery. All computations use field units (STB for oil, SCF for gas, psi for pressure) and convert from internal simulator units automatically.</p> <p>Results from the analyst are returned as frozen attrs classes. Each result type is a self-documenting data container with named fields and units in the docstrings. This means you can inspect the result object to see exactly what each number represents, and you can pass result objects to downstream code without worrying about mutation.</p> <p>The analyst caches computed results internally. Repeated calls with the same parameters return cached values without recomputation. This makes it efficient to call multiple methods that depend on the same underlying production totals.</p>"},{"location":"user-guide/advanced/model-analysis/#creating-an-analyst","title":"Creating an Analyst","text":"<p>The <code>ModelAnalyst</code> class accepts any iterable of <code>ModelState</code> objects. You can pass a list collected from <code>bores.run()</code>, a replay from a <code>StateStream</code>, or states loaded from a store:</p> <pre><code>from bores.analyses import ModelAnalyst\n\n# From a list of states\nstates = list(bores.run(model, config))\nanalyst = ModelAnalyst(states)\n\n# From a stream replay\nanalyst = ModelAnalyst(stream.replay())\n\n# From a store directly\nfrom bores.states import ModelState\nanalyst = ModelAnalyst(store.load(ModelState))\n</code></pre> <p>The analyst stores all states internally in a dictionary keyed by step number. This means it needs to load all states into memory. For very large simulations, consider replaying only a subset of states (using <code>replay(steps=...)</code> or <code>replay(indices=...)</code>) to reduce memory.</p>"},{"location":"user-guide/advanced/model-analysis/#eor-and-continuation-scenarios","title":"EOR and Continuation Scenarios","text":"<p>When the earliest available state is not step 0, or when you want to override the initial volumes (for example, in an EOR simulation that starts from a depleted state), you can provide pre-calculated initial volumes:</p> <pre><code>analyst = ModelAnalyst(\n    states,\n    initial_stoiip=5_000_000.0,     # STB\n    initial_stgiip=2_000_000_000.0, # SCF\n    initial_stwiip=10_000_000.0,    # STB\n)\n</code></pre> <p>If you do not provide these values, the analyst computes them from the earliest available state using the hydrocarbon-in-place calculation with formation volume factors and pore volume.</p>"},{"location":"user-guide/advanced/model-analysis/#navigation-properties","title":"Navigation Properties","text":"<p>The analyst exposes several properties for navigating the state collection:</p> <pre><code>analyst.min_step          # Earliest step number\nanalyst.max_step          # Latest step number\nanalyst.available_steps   # Sorted list of all step numbers\n\n# Retrieve a specific state\nstate = analyst.get_state(50)  # Returns None if step 50 is not available\n</code></pre>"},{"location":"user-guide/advanced/model-analysis/#initial-volumes","title":"Initial Volumes","text":"<p>The analyst computes stock tank oil initially in place (STOIIP) and stock tank gas initially in place (STGIIP) from the earliest available state. These values serve as the denominators for recovery factor calculations.</p> <pre><code># Full property names\nprint(f\"STOIIP: {analyst.stock_tank_oil_initially_in_place:,.0f} STB\")\nprint(f\"STGIIP: {analyst.stock_tank_gas_initially_in_place:,.0f} SCF\")\nprint(f\"STWIIP: {analyst.stock_tank_water_initially_in_place:,.0f} STB\")\n\n# Short aliases\nprint(f\"STOIIP: {analyst.stoiip:,.0f} STB\")\nprint(f\"STGIIP: {analyst.stgiip:,.0f} SCF\")\n</code></pre> <p>The <code>stoiip</code> and <code>stgiip</code> aliases are convenient shorthand for the full property names. Both return the same value.</p>"},{"location":"user-guide/advanced/model-analysis/#fluids-in-place","title":"Fluids in Place","text":"<p>These methods compute the volume of each phase remaining in the reservoir at a given time step. They account for formation volume factors to convert from reservoir conditions to stock tank conditions.</p> <pre><code># Oil, gas, and water in place at the final step\noil_remaining = analyst.oil_in_place(step=-1)      # STB\ngas_remaining = analyst.gas_in_place(step=-1)       # SCF\nwater_in_place = analyst.water_in_place(step=-1)    # STB\n\n# At a specific step\noil_at_50 = analyst.oil_in_place(step=50)\n</code></pre> <p>All three methods accept a <code>step</code> parameter that defaults to <code>-1</code> (the last available step). Negative indices work like Python lists.</p>"},{"location":"user-guide/advanced/model-analysis/#in-place-history","title":"In-Place History","text":"<p>To track how fluids in place change over time, use the history generators:</p> <pre><code># Oil in place at every 10th step\nfor step, oil_ip in analyst.oil_in_place_history(from_step=0, to_step=-1, interval=10):\n    print(f\"Step {step}: {oil_ip:,.0f} STB remaining\")\n\n# Gas in place history\nfor step, gas_ip in analyst.gas_in_place_history(interval=5):\n    print(f\"Step {step}: {gas_ip:,.0f} SCF remaining\")\n\n# Water in place history\nfor step, water_ip in analyst.water_in_place_history():\n    print(f\"Step {step}: {water_ip:,.0f} STB\")\n</code></pre> <p>Each history method accepts <code>from_step</code>, <code>to_step</code>, and <code>interval</code> parameters and returns a generator of <code>(step, value)</code> tuples.</p>"},{"location":"user-guide/advanced/model-analysis/#cumulative-production-and-injection","title":"Cumulative Production and Injection","text":"<p>The analyst can compute cumulative production and injection between any two time steps. These methods sum the per-step volumes across the specified range, converting from reservoir cubic feet per day to stock tank barrels (for oil and water) or standard cubic feet (for gas) using the formation volume factor at each step.</p>"},{"location":"user-guide/advanced/model-analysis/#production","title":"Production","text":"<pre><code># Total oil produced over the entire simulation\ntotal_oil = analyst.oil_produced(from_step=0, to_step=-1)  # STB\n\n# Oil produced in a specific interval\noil_50_to_100 = analyst.oil_produced(from_step=50, to_step=100)\n\n# Gas and water\ngas_produced = analyst.free_gas_produced(from_step=0, to_step=-1)  # SCF\nwater_produced = analyst.water_produced(from_step=0, to_step=-1)   # STB\n</code></pre>"},{"location":"user-guide/advanced/model-analysis/#injection","title":"Injection","text":"<pre><code># Total injection volumes\noil_injected = analyst.oil_injected(from_step=0, to_step=-1)     # STB\nwater_injected = analyst.water_injected(from_step=0, to_step=-1) # STB\ngas_injected = analyst.gas_injected(from_step=0, to_step=-1)     # SCF\n</code></pre>"},{"location":"user-guide/advanced/model-analysis/#cell-filtering","title":"Cell Filtering","text":"<p>All production and injection methods accept a <code>cells</code> parameter that filters the calculation to specific cells, wells, or regions. The filter applies to the grid cells where production or injection occurs.</p> <pre><code># Production from a specific well (by name)\noil_from_well = analyst.oil_produced(0, -1, cells=\"PROD-1\")\n\n# Production from a single cell\noil_from_cell = analyst.oil_produced(0, -1, cells=(5, 5, 0))\n\n# Production from multiple cells\noil_from_cells = analyst.oil_produced(0, -1, cells=[(5, 5, 0), (6, 5, 0), (7, 5, 0)])\n\n# Production from a region (using slices)\noil_from_region = analyst.oil_produced(0, -1, cells=(slice(0, 10), slice(0, 10), slice(None)))\n</code></pre> <p>The <code>cells</code> parameter accepts:</p> Type Example Description <code>None</code> <code>cells=None</code> Entire reservoir (default) <code>str</code> <code>cells=\"PROD-1\"</code> Well name <code>tuple(int,int,int)</code> <code>cells=(5,5,0)</code> Single cell index <code>list[tuple]</code> <code>cells=[(5,5,0),(6,5,0)]</code> Multiple cell indices <code>tuple(slice,...)</code> <code>cells=(slice(0,10),...)</code> Grid region"},{"location":"user-guide/advanced/model-analysis/#cumulative-properties","title":"Cumulative Properties","text":"<p>For quick access to full-simulation cumulative values, the analyst provides read-only properties:</p> <pre><code>print(f\"Cumulative oil: {analyst.cumulative_oil_produced:,.0f} STB\")\nprint(f\"Cumulative gas: {analyst.cumulative_free_gas_produced:,.0f} SCF\")\nprint(f\"Cumulative water: {analyst.cumulative_water_produced:,.0f} STB\")\n</code></pre>"},{"location":"user-guide/advanced/model-analysis/#recovery-factors","title":"Recovery Factors","text":"<p>Recovery factors express cumulative production as a fraction of the original volume in place. The analyst provides several recovery factor properties:</p> <pre><code># Oil recovery factor (cumulative oil / STOIIP)\nprint(f\"Oil RF: {analyst.oil_recovery_factor:.2%}\")\n\n# Free gas recovery factor (free gas produced / STGIIP)\nprint(f\"Free gas RF: {analyst.free_gas_recovery_factor:.2%}\")\n\n# Total gas recovery factor (free gas + solution gas / STGIIP)\nprint(f\"Total gas RF: {analyst.total_gas_recovery_factor:.2%}\")\n\n# Alias for free_gas_recovery_factor\nprint(f\"Gas RF: {analyst.gas_recovery_factor:.2%}\")\n</code></pre> <p>The <code>total_gas_recovery_factor</code> includes solution gas that was dissolved in oil at initial conditions but has since come out of solution due to pressure decline. The <code>free_gas_recovery_factor</code> (aliased as <code>gas_recovery_factor</code>) only counts free gas that was initially in the gas cap.</p>"},{"location":"user-guide/advanced/model-analysis/#recovery-factor-history","title":"Recovery Factor History","text":"<p>To track recovery factors over time:</p> <pre><code>for step, rf in analyst.oil_recovery_factor_history(interval=10):\n    print(f\"Step {step}: RF = {rf:.2%}\")\n\nfor step, rf in analyst.free_gas_recovery_factor_history(interval=10):\n    print(f\"Step {step}: Gas RF = {rf:.2%}\")\n\nfor step, rf in analyst.total_gas_recovery_factor_history(interval=10):\n    print(f\"Step {step}: Total Gas RF = {rf:.2%}\")\n</code></pre>"},{"location":"user-guide/advanced/model-analysis/#production-and-injection-histories","title":"Production and Injection Histories","text":"<p>The history methods return generators of <code>(step, value)</code> tuples, which are efficient for building time series plots or feeding into numpy arrays. Each method supports <code>from_step</code>, <code>to_step</code>, <code>interval</code>, <code>cumulative</code>, and <code>cells</code> parameters.</p> <pre><code># Per-step oil production rate (STB at each step)\nfor step, rate in analyst.oil_production_history(interval=5):\n    print(f\"Step {step}: {rate:.0f} STB\")\n\n# Cumulative oil production\nfor step, cum in analyst.oil_production_history(cumulative=True):\n    print(f\"Step {step}: {cum:,.0f} STB cumulative\")\n\n# Gas production from a specific well\nfor step, rate in analyst.free_gas_production_history(cells=\"PROD-1\"):\n    print(f\"Step {step}: {rate:.0f} SCF\")\n\n# Water production\nfor step, rate in analyst.water_production_history(interval=10):\n    print(f\"Step {step}: {rate:.0f} STB\")\n</code></pre> <p>Injection histories follow the same pattern:</p> <pre><code>for step, rate in analyst.oil_injection_history(interval=5):\n    print(f\"Step {step}: {rate:.0f} STB injected\")\n\nfor step, rate in analyst.gas_injection_history(cumulative=True):\n    print(f\"Step {step}: {rate:,.0f} SCF cumulative\")\n\nfor step, rate in analyst.water_injection_history():\n    print(f\"Step {step}: {rate:.0f} STB injected\")\n</code></pre>"},{"location":"user-guide/advanced/model-analysis/#history-method-parameters","title":"History Method Parameters","text":"<p>All history methods share these parameters:</p> Parameter Default Description <code>from_step</code> 0 Starting step index (inclusive) <code>to_step</code> -1 Ending step index (inclusive, -1 for last) <code>interval</code> 1 Step sampling interval <code>cumulative</code> <code>False</code> If <code>True</code>, return running cumulative totals <code>cells</code> <code>None</code> Cell filter (well name, cell tuple, or region)"},{"location":"user-guide/advanced/model-analysis/#reservoir-volumetrics-analysis","title":"Reservoir Volumetrics Analysis","text":"<p>The <code>reservoir_volumetrics_analysis()</code> method computes a comprehensive volumetric snapshot at a single time step. It returns a <code>ReservoirVolumetrics</code> object containing oil, gas, and water in place, pore volume, and hydrocarbon pore volume.</p> <pre><code>vol = analyst.reservoir_volumetrics_analysis(step=-1)\nprint(f\"Oil in place: {vol.oil_in_place:,.0f} STB\")\nprint(f\"Gas in place: {vol.gas_in_place:,.0f} SCF\")\nprint(f\"Water in place: {vol.water_in_place:,.0f} STB\")\nprint(f\"Pore volume: {vol.pore_volume:,.0f} ft3\")\nprint(f\"HCPV: {vol.hydrocarbon_pore_volume:,.0f} ft3\")\n</code></pre> <p>The <code>ReservoirVolumetrics</code> result class contains:</p> Field Unit Description <code>oil_in_place</code> STB Total oil in place <code>gas_in_place</code> SCF Total gas in place <code>water_in_place</code> STB Total water in place <code>pore_volume</code> ft3 Total pore volume <code>hydrocarbon_pore_volume</code> ft3 Hydrocarbon-bearing pore volume"},{"location":"user-guide/advanced/model-analysis/#volumetrics-history","title":"Volumetrics History","text":"<pre><code>for step, vol in analyst.reservoir_volumetrics_history(interval=20):\n    print(f\"Step {step}: OIP={vol.oil_in_place:,.0f}, PV={vol.pore_volume:,.0f}\")\n</code></pre>"},{"location":"user-guide/advanced/model-analysis/#cumulative-production-analysis","title":"Cumulative Production Analysis","text":"<p>The <code>cumulative_production_analysis()</code> method provides a summary of cumulative production along with recovery factors in a single result object:</p> <pre><code>cum = analyst.cumulative_production_analysis(step=-1)\nprint(f\"Cumulative oil: {cum.cumulative_oil:,.0f} STB\")\nprint(f\"Cumulative gas: {cum.cumulative_free_gas:,.0f} SCF\")\nprint(f\"Cumulative water: {cum.cumulative_water:,.0f} STB\")\nprint(f\"Oil RF: {cum.oil_recovery_factor:.2%}\")\nprint(f\"Gas RF: {cum.gas_recovery_factor:.2%}\")\n</code></pre> <p>The <code>CumulativeProduction</code> result class contains:</p> Field Unit Description <code>cumulative_oil</code> STB Cumulative oil produced <code>cumulative_free_gas</code> SCF Cumulative free gas produced <code>cumulative_water</code> STB Cumulative water produced <code>oil_recovery_factor</code> fraction Oil recovery as fraction of STOIIP <code>gas_recovery_factor</code> fraction Gas recovery as fraction of STGIIP"},{"location":"user-guide/advanced/model-analysis/#cumulative-production-history","title":"Cumulative Production History","text":"<pre><code>for step, cum in analyst.cumulative_production_history(interval=10):\n    print(f\"Step {step}: Oil RF = {cum.oil_recovery_factor:.2%}\")\n</code></pre>"},{"location":"user-guide/advanced/model-analysis/#instantaneous-rates","title":"Instantaneous Rates","text":"<p>The <code>instantaneous_production_rates()</code> and <code>instantaneous_injection_rates()</code> methods compute snapshot rates at a single time step. Unlike the cumulative methods (which sum over a range), these methods report what is happening right now at the specified step. Rates are converted to surface conditions using formation volume factors.</p> <pre><code>rates = analyst.instantaneous_production_rates(step=-1)\nprint(f\"Oil rate: {rates.oil_rate:,.0f} STB/day\")\nprint(f\"Gas rate: {rates.gas_rate:,.0f} SCF/day\")\nprint(f\"Water rate: {rates.water_rate:,.0f} STB/day\")\nprint(f\"Total liquid: {rates.total_liquid_rate:,.0f} STB/day\")\nprint(f\"Water cut: {rates.water_cut:.2%}\")\nprint(f\"GOR: {rates.gas_oil_ratio:,.0f} SCF/STB\")\n</code></pre> <p>Both methods accept an optional <code>cells</code> parameter for filtering by well or region:</p> <pre><code># Rates for a specific well\nwell_rates = analyst.instantaneous_production_rates(step=-1, cells=\"PROD-1\")\n\n# Injection rates\ninj_rates = analyst.instantaneous_injection_rates(step=-1, cells=\"INJ-1\")\n</code></pre> <p>The <code>InstantaneousRates</code> result class contains:</p> Field Unit Description <code>oil_rate</code> STB/day Oil production/injection rate <code>gas_rate</code> SCF/day Gas production/injection rate <code>water_rate</code> STB/day Water production/injection rate <code>total_liquid_rate</code> STB/day Oil + water rate <code>gas_oil_ratio</code> SCF/STB Producing GOR <code>water_cut</code> fraction Water cut (0 to 1)"},{"location":"user-guide/advanced/model-analysis/#instantaneous-rates-history","title":"Instantaneous Rates History","text":"<pre><code>for step, rates in analyst.instantaneous_rates_history(interval=5):\n    print(f\"Step {step}: Oil={rates.oil_rate:.0f}, WC={rates.water_cut:.2%}\")\n</code></pre>"},{"location":"user-guide/advanced/model-analysis/#material-balance-analysis","title":"Material Balance Analysis","text":"<p>The <code>material_balance_analysis()</code> method identifies and quantifies the drive mechanisms in your reservoir using the generalized material balance equation. The drive indices sum to 1.0 and indicate the relative contribution of each mechanism to production.</p> <pre><code>mbal = analyst.material_balance_analysis(step=-1)\nprint(f\"Reservoir pressure: {mbal.pressure:.0f} psi\")\nprint(f\"Oil expansion: {mbal.oil_expansion_factor:.4f}\")\nprint(f\"Solution gas drive: {mbal.solution_gas_drive_index:.2%}\")\nprint(f\"Gas cap drive: {mbal.gas_cap_drive_index:.2%}\")\nprint(f\"Water drive: {mbal.water_drive_index:.2%}\")\nprint(f\"Compaction drive: {mbal.compaction_drive_index:.2%}\")\nprint(f\"Aquifer influx: {mbal.aquifer_influx:,.0f} STB\")\n</code></pre> <p>The short alias <code>analyst.mbal(step=-1)</code> is equivalent to <code>analyst.material_balance_analysis(step=-1)</code>.</p> <p>The <code>MaterialBalanceAnalysis</code> result class contains:</p> Field Unit Description <code>pressure</code> psia Average reservoir pressure <code>oil_expansion_factor</code> dimensionless Oil expansion relative to initial conditions <code>solution_gas_drive_index</code> fraction Fraction of production from solution gas expansion <code>gas_cap_drive_index</code> fraction Fraction from gas cap expansion <code>water_drive_index</code> fraction Fraction from water influx <code>compaction_drive_index</code> fraction Fraction from pore compaction and fluid expansion <code>aquifer_influx</code> STB Estimated cumulative aquifer water influx"},{"location":"user-guide/advanced/model-analysis/#material-balance-history","title":"Material Balance History","text":"<pre><code>for step, mbal in analyst.material_balance_history(interval=20):\n    print(f\"Step {step}: P={mbal.pressure:.0f}, SGD={mbal.solution_gas_drive_index:.2%}\")\n</code></pre>"},{"location":"user-guide/advanced/model-analysis/#sweep-efficiency-analysis","title":"Sweep Efficiency Analysis","text":"<p>The <code>sweep_efficiency_analysis()</code> method evaluates how effectively the displacing phase has contacted and displaced oil in the reservoir. It decomposes recovery into the product of volumetric sweep efficiency (what fraction of the original oil was reached) and displacement efficiency (how much oil was removed from the contacted zones).</p> <pre><code>sweep = analyst.sweep_efficiency_analysis(\n    step=-1,\n    displacing_phase=\"water\",\n    delta_water_saturation_threshold=0.02,\n)\nprint(f\"Volumetric sweep: {sweep.volumetric_sweep_efficiency:.2%}\")\nprint(f\"Displacement efficiency: {sweep.displacement_efficiency:.2%}\")\nprint(f\"Recovery efficiency: {sweep.recovery_efficiency:.2%}\")\nprint(f\"Areal sweep: {sweep.areal_sweep_efficiency:.2%}\")\nprint(f\"Vertical sweep: {sweep.vertical_sweep_efficiency:.2%}\")\nprint(f\"Contacted oil: {sweep.contacted_oil:,.0f} STB\")\nprint(f\"Uncontacted oil: {sweep.uncontacted_oil:,.0f} STB\")\n</code></pre> <p>The method determines which cells have been \"contacted\" by comparing the current displacing phase saturation to the initial saturation. A cell is contacted if the saturation change exceeds the threshold. For gas injection or miscible flooding, set <code>displacing_phase=\"gas\"</code>. In miscible floods, cells where the solvent concentration exceeds <code>solvent_concentration_threshold</code> are also counted as contacted.</p>"},{"location":"user-guide/advanced/model-analysis/#parameters","title":"Parameters","text":"Parameter Default Description <code>step</code> -1 Time step to analyze <code>displacing_phase</code> <code>\"water\"</code> Phase doing the displacing: <code>\"water\"</code>, <code>\"gas\"</code>, or <code>\"oil\"</code> <code>delta_water_saturation_threshold</code> 0.02 Minimum water saturation increase to declare contact <code>delta_gas_saturation_threshold</code> 0.01 Minimum gas saturation increase to declare contact <code>solvent_concentration_threshold</code> 0.01 Minimum solvent concentration for miscible contact"},{"location":"user-guide/advanced/model-analysis/#result-fields","title":"Result Fields","text":"<p>The <code>SweepEfficiencyAnalysis</code> result class contains:</p> Field Unit Description <code>volumetric_sweep_efficiency</code> fraction Fraction of initial oil contacted <code>displacement_efficiency</code> fraction Oil removal efficiency in contacted zones <code>recovery_efficiency</code> fraction Product of volumetric and displacement efficiency <code>contacted_oil</code> STB Initial oil in contacted zones <code>uncontacted_oil</code> STB Initial oil in uncontacted zones <code>areal_sweep_efficiency</code> fraction Fraction of planform area contacted <code>vertical_sweep_efficiency</code> fraction Saturation-weighted vertical contact fraction"},{"location":"user-guide/advanced/model-analysis/#sweep-efficiency-history","title":"Sweep Efficiency History","text":"<pre><code>for step, sweep in analyst.sweep_efficiency_history(\n    displacing_phase=\"water\",\n    interval=20,\n):\n    print(f\"Step {step}: Sweep={sweep.volumetric_sweep_efficiency:.2%}\")\n</code></pre>"},{"location":"user-guide/advanced/model-analysis/#well-productivity-analysis","title":"Well Productivity Analysis","text":"<p>The <code>productivity_analysis()</code> method evaluates well performance using actual flow rates and reservoir properties at the perforation intervals. It does not require bottom-hole pressure data. Instead, it computes metrics from production rates, formation permeability, relative mobility, and the skin factor assigned to each well.</p> <pre><code>prod = analyst.productivity_analysis(step=-1, phase=\"oil\", cells=\"PROD-1\")\nprint(f\"Flow rate: {prod.total_flow_rate:,.0f} STB/day\")\nprint(f\"Avg pressure: {prod.average_reservoir_pressure:.0f} psi\")\nprint(f\"Skin factor: {prod.skin_factor:.2f}\")\nprint(f\"Flow efficiency: {prod.flow_efficiency:.2%}\")\nprint(f\"Well index: {prod.well_index:.4f} rb/day/psi\")\nprint(f\"Avg mobility: {prod.average_mobility:.4f} 1/cP\")\n</code></pre>"},{"location":"user-guide/advanced/model-analysis/#parameters_1","title":"Parameters","text":"Parameter Default Description <code>step</code> -1 Time step to analyze <code>phase</code> <code>\"oil\"</code> Phase to analyze: <code>\"oil\"</code>, <code>\"gas\"</code>, or <code>\"water\"</code> <code>cells</code> <code>None</code> Filter: well name, cell tuple, or region"},{"location":"user-guide/advanced/model-analysis/#result-fields_1","title":"Result Fields","text":"<p>The <code>ProductivityAnalysis</code> result class contains:</p> Field Unit Description <code>total_flow_rate</code> STB/day or SCF/day Total flow rate across all matched cells <code>average_reservoir_pressure</code> psia Average pressure at perforation intervals <code>skin_factor</code> dimensionless Average skin factor across active wells <code>flow_efficiency</code> fraction Flow efficiency accounting for skin <code>well_index</code> rb/day/psi Average geometric well index <code>average_mobility</code> 1/cP Average phase mobility at perforations"},{"location":"user-guide/advanced/model-analysis/#productivity-history","title":"Productivity History","text":"<pre><code>for step, prod in analyst.productivity_history(phase=\"oil\", cells=\"PROD-1\", interval=10):\n    print(f\"Step {step}: Rate={prod.total_flow_rate:.0f}, FE={prod.flow_efficiency:.2%}\")\n</code></pre>"},{"location":"user-guide/advanced/model-analysis/#voidage-replacement-ratio","title":"Voidage Replacement Ratio","text":"<p>The <code>voidage_replacement_ratio()</code> method computes the ratio of injected reservoir volumes to produced reservoir volumes. This is a key metric for pressure maintenance programs. The VRR accounts for formation volume factors at current reservoir conditions to convert between stock tank and reservoir volumes.</p> \\[VRR = \\frac{W_i \\cdot B_{wi} + G_{gi} \\cdot B_{gi}}{N_p \\cdot B_o + W_p \\cdot B_w + (GOR - R_s) \\cdot N_p \\cdot B_g}\\] <pre><code>vrr = analyst.voidage_replacement_ratio(step=-1)\nprint(f\"VRR: {vrr:.3f}\")\n</code></pre> <p>Interpretation:</p> <ul> <li>VRR &gt; 1.0: Injection exceeds production, pressure is increasing</li> <li>VRR = 1.0: Balanced reservoir, pressure is maintained</li> <li>VRR &lt; 1.0: Production exceeds injection, pressure is declining</li> </ul> <p>The method accepts an optional <code>cells</code> parameter for computing VRR for a specific well pattern or region.</p> <p>Short aliases: <code>analyst.vrr(step=-1)</code> and <code>analyst.VRR(step=-1)</code>.</p>"},{"location":"user-guide/advanced/model-analysis/#vrr-history","title":"VRR History","text":"<pre><code>for step, vrr_val in analyst.voidage_replacement_ratio_history(interval=10):\n    print(f\"Step {step}: VRR = {vrr_val:.3f}\")\n</code></pre> <p>The alias <code>analyst.vrr_history(...)</code> is also available.</p>"},{"location":"user-guide/advanced/model-analysis/#mobility-ratio","title":"Mobility Ratio","text":"<p>The <code>mobility_ratio()</code> method calculates the mobility ratio between the displacing and displaced phases. Mobility is defined as relative permeability divided by viscosity (\\(\\lambda = k_r / \\mu\\)), and the mobility ratio is the ratio of the displacing phase mobility to the displaced phase mobility.</p> \\[M = \\frac{\\lambda_{displacing}}{\\lambda_{displaced}} = \\frac{k_{r,displacing} / \\mu_{displacing}}{k_{r,displaced} / \\mu_{displaced}}\\] <pre><code>M = analyst.mobility_ratio(\n    displaced_phase=\"oil\",\n    displacing_phase=\"water\",\n    step=-1,\n)\nprint(f\"Mobility ratio: {M:.3f}\")\n</code></pre> <p>A mobility ratio less than 1.0 indicates a stable displacement (the displacing fluid moves slower than the displaced fluid). A mobility ratio greater than 1.0 indicates an unstable displacement where the displacing fluid tends to finger through the displaced fluid.</p> Parameter Default Description <code>displaced_phase</code> <code>\"oil\"</code> Phase being displaced: <code>\"oil\"</code> or <code>\"water\"</code> <code>displacing_phase</code> <code>\"water\"</code> Phase doing the displacing: <code>\"oil\"</code>, <code>\"water\"</code>, or <code>\"gas\"</code> <code>step</code> -1 Time step to analyze <p>The short alias <code>analyst.mr(...)</code> is also available.</p>"},{"location":"user-guide/advanced/model-analysis/#mobility-ratio-history","title":"Mobility Ratio History","text":"<pre><code>for step, M in analyst.mobility_ratio_history(\n    displaced_phase=\"oil\",\n    displacing_phase=\"water\",\n    interval=10,\n):\n    print(f\"Step {step}: M = {M:.3f}\")\n</code></pre> <p>The alias <code>analyst.mr_history(...)</code> is also available.</p>"},{"location":"user-guide/advanced/model-analysis/#decline-curve-analysis","title":"Decline Curve Analysis","text":"<p>Decline curve analysis (DCA) fits production data to standard decline models to characterize production trends and forecast future behavior. The analyst supports three decline types: exponential, harmonic, and hyperbolic.</p>"},{"location":"user-guide/advanced/model-analysis/#fitting-decline-curves","title":"Fitting Decline Curves","text":"<p>The <code>decline_curve_analysis()</code> method fits a single decline model to the production history:</p> <pre><code>result = analyst.decline_curve_analysis(\n    from_step=50,       # Skip early transient\n    to_step=-1,\n    phase=\"oil\",\n    decline_type=\"exponential\",\n)\nprint(f\"Initial rate: {result.initial_rate:,.0f} STB/day\")\nprint(f\"Decline rate: {result.decline_rate_per_timestep:.6f}\")\nprint(f\"b-factor: {result.b_factor:.3f}\")\nprint(f\"R-squared: {result.r_squared:.4f}\")\n</code></pre> <p>The <code>DeclineCurveResult</code> result class contains:</p> Field Unit Description <code>decline_type</code> string <code>\"exponential\"</code>, <code>\"hyperbolic\"</code>, or <code>\"harmonic\"</code> <code>initial_rate</code> STB/day or SCF/day Fitted initial production rate <code>decline_rate_per_timestep</code> fraction/step Decline rate per simulation time step <code>b_factor</code> dimensionless Hyperbolic exponent (0 for exponential, 1 for harmonic) <code>r_squared</code> dimensionless Goodness of fit (0 to 1) <code>phase</code> string Phase analyzed <code>error</code> string or None Error message if fitting failed <code>steps</code> list[int] Time steps used in the fit <code>actual_rates</code> list[float] Historical rates <code>predicted_rates</code> list[float] Fitted rates"},{"location":"user-guide/advanced/model-analysis/#recommending-the-best-model","title":"Recommending the Best Model","text":"<p>The <code>recommend_decline_model()</code> method fits all three decline types and recommends the best one based on statistical fit quality and physical reasonableness:</p> <pre><code>best_model, all_results = analyst.recommend_decline_model(\n    from_step=50,\n    to_step=-1,\n    phase=\"oil\",\n    max_decline_per_year=2.0,\n)\nprint(f\"Recommended: {best_model}\")\n\n# Access individual results\nfor name, result in all_results.items():\n    print(f\"  {name}: R2={result.r_squared:.4f}, qi={result.initial_rate:.0f}\")\n</code></pre> <p>The method returns a tuple of (best model name, dictionary of all results). The selection criteria include R-squared, physical reasonableness of the b-factor, and whether the decline rate exceeds <code>max_decline_per_year</code>.</p> <p>The short alias <code>analyst.dca(...)</code> is equivalent to <code>analyst.decline_curve_analysis(...)</code>.</p>"},{"location":"user-guide/advanced/model-analysis/#forecasting-production","title":"Forecasting Production","text":"<p>The <code>forecast_production()</code> method extrapolates future rates from a fitted decline curve:</p> <pre><code>result = analyst.decline_curve_analysis(\n    from_step=50, to_step=-1, phase=\"oil\", decline_type=\"exponential\"\n)\n\n# Forecast 200 steps into the future\nforecast = analyst.forecast_production(\n    decline_result=result,\n    steps=200,\n    economic_limit=10.0,  # Stop when rate drops below 10 STB/day\n)\n\nfor step, rate in forecast:\n    print(f\"Step {step}: {rate:.0f} STB/day (forecast)\")\n</code></pre> <p>The forecast uses the fitted decline equations:</p> <ul> <li>Exponential: \\(q(t) = q_i \\cdot e^{-D_i \\cdot t}\\)</li> <li>Harmonic: \\(q(t) = q_i / (1 + D_i \\cdot t)\\)</li> <li>Hyperbolic: \\(q(t) = q_i / (1 + b \\cdot D_i \\cdot t)^{1/b}\\)</li> </ul> <p>The <code>economic_limit</code> parameter stops the forecast when the predicted rate drops below the specified value.</p>"},{"location":"user-guide/advanced/model-analysis/#estimated-ultimate-recovery","title":"Estimated Ultimate Recovery","text":"<p>The <code>estimate_economic_ultimate_recovery()</code> method calculates the total cumulative production expected over the economic life of the well or reservoir:</p> <pre><code>eur = analyst.estimate_economic_ultimate_recovery(\n    decline_result=result,\n    forecast_steps=500,\n    economic_limit=5.0,  # STB/day\n)\nprint(f\"EUR: {eur:,.0f} STB\")\n</code></pre> <p>EUR is computed using analytical integration of the decline curve equations rather than numerical summation, giving exact results regardless of time step size.</p>"},{"location":"user-guide/advanced/model-analysis/#complete-workflow","title":"Complete Workflow","text":"<p>A typical post-simulation analysis workflow combines several of these methods:</p> <pre><code>import bores\nfrom bores.analyses import ModelAnalyst\nfrom bores.states import ModelState\nfrom bores.stores import ZarrStore\nfrom bores.streams import StateStream\n\n# Run and save\nstore = ZarrStore(\"simulation.zarr\")\nwith StateStream(\n    states=bores.run(model, config),\n    store=store,\n    background_io=True,\n) as stream:\n    stream.consume()\n\n# Create analyst from saved states\nanalyst = ModelAnalyst(store.load(ModelState))\n\n# Summary\nprint(f\"STOIIP: {analyst.stoiip:,.0f} STB\")\nprint(f\"Recovery factor: {analyst.oil_recovery_factor:.2%}\")\n\n# Material balance\nmbal = analyst.mbal(step=-1)\nprint(f\"Primary drive: solution gas = {mbal.solution_gas_drive_index:.1%}\")\n\n# Sweep efficiency\nsweep = analyst.sweep_efficiency_analysis(step=-1)\nprint(f\"Volumetric sweep: {sweep.volumetric_sweep_efficiency:.1%}\")\n\n# Well productivity\nprod = analyst.productivity_analysis(step=-1, cells=\"PROD-1\")\nprint(f\"Well rate: {prod.total_flow_rate:.0f} STB/day\")\n\n# VRR (if injection is active)\nprint(f\"VRR: {analyst.vrr(step=-1):.3f}\")\n\n# Decline curve and forecast\nbest, results = analyst.recommend_decline_model(from_step=50, phase=\"oil\")\nforecast = analyst.forecast_production(results[best], steps=200, economic_limit=10.0)\neur = analyst.estimate_economic_ultimate_recovery(results[best], forecast_steps=500)\nprint(f\"Best decline model: {best}, EUR: {eur:,.0f} STB\")\n</code></pre>"},{"location":"user-guide/advanced/pvt-tables/","title":"PVT Tables","text":""},{"location":"user-guide/advanced/pvt-tables/#overview","title":"Overview","text":"<p>By default, BORES computes fluid properties (viscosity, density, formation volume factor, compressibility, and solution gas-oil ratio) at each time step using empirical correlations. These correlations are fast and cover a wide range of conditions, but they are general-purpose approximations. When you have laboratory PVT data from your specific reservoir fluids, you can provide that data as tabulated properties and BORES will interpolate directly from your measurements instead of using correlations.</p> <p>PVT tables offer several advantages over correlations. They capture the specific behavior of your reservoir fluids, including any non-ideal interactions between components that correlations miss. They eliminate the uncertainty inherent in choosing among different correlation families (Standing vs. Vasquez-Beggs vs. Glaso for bubble point, for example). And they allow you to incorporate laboratory measurements, equation-of-state results, or data from specialized PVT analysis software directly into your simulation.</p> <p>The PVT table system in BORES consists of two classes: <code>PVTTableData</code> stores the raw tabulated data, and <code>PVTTables</code> builds fast interpolators from that data for runtime lookups. Once the interpolators are built, the raw data can be discarded to save memory.</p>"},{"location":"user-guide/advanced/pvt-tables/#building-pvt-table-data","title":"Building PVT Table Data","text":"<p>The simplest way to create PVT tables is using <code>build_pvt_table_data()</code>, which generates tables from correlations over a specified pressure and temperature range. This gives you a baseline that you can then replace with laboratory data for specific properties.</p> <pre><code>import bores\nimport numpy as np\nfrom bores.tables.pvt import build_pvt_table_data, PVTTables\n\nbores.use_32bit_precision()\n\n# Define pressure and temperature grids\npressures = np.linspace(500, 5000, 50)      # 500 to 5000 psi\ntemperatures = np.linspace(100, 250, 30)    # 100 to 250 F\n\n# Build table data from correlations\npvt_data = build_pvt_table_data(\n    pressures=pressures,\n    temperatures=temperatures,\n    oil_specific_gravity=0.85,\n)\n</code></pre> <p>The <code>build_pvt_table_data()</code> function computes all oil, water, and gas properties over the specified pressure-temperature grid using BORES's internal correlations. The result is a <code>PVTTableData</code> object containing 2D arrays (pressure x temperature) for each property.</p>"},{"location":"user-guide/advanced/pvt-tables/#specifying-fluid-properties","title":"Specifying Fluid Properties","text":"<p>You can customize the fluid characterization by providing additional parameters:</p> <pre><code>pvt_data = build_pvt_table_data(\n    pressures=pressures,\n    temperatures=temperatures,\n    oil_specific_gravity=0.87,\n    gas_gravity=0.65,                  # Gas specific gravity (air = 1.0)\n    water_salinity=50000.0,            # ppm NaCl\n    estimated_solution_gor=500.0,      # SCF/STB estimate\n)\n</code></pre> <p>The gas gravity affects gas density, viscosity, and z-factor calculations. The water salinity affects water density, viscosity, and formation volume factor. The estimated solution GOR provides a starting point for bubble point pressure estimation.</p>"},{"location":"user-guide/advanced/pvt-tables/#providing-laboratory-data","title":"Providing Laboratory Data","text":"<p>If you have laboratory measurements for specific properties, pass them directly as pre-computed tables:</p> <pre><code># Lab-measured oil viscosity (n_pressures x n_temperatures)\nlab_oil_viscosity = np.loadtxt(\"lab_viscosity.csv\")\n\npvt_data = build_pvt_table_data(\n    pressures=pressures,\n    temperatures=temperatures,\n    oil_specific_gravity=0.87,\n    oil_viscosity_table=lab_oil_viscosity,        # Use lab data\n    oil_density_table=lab_oil_density,             # Use lab data\n    # Other properties still computed from correlations\n)\n</code></pre> <p>Any property table you provide directly overrides the corresponding correlation-computed table. Properties you do not provide are computed from correlations as usual. This lets you mix laboratory data (for the properties you have measured) with correlation estimates (for the rest).</p>"},{"location":"user-guide/advanced/pvt-tables/#salinity-dependent-water-properties","title":"Salinity-Dependent Water Properties","text":"<p>Water properties depend on salinity in addition to pressure and temperature. If your reservoir has varying formation water salinity, provide a salinity grid:</p> <pre><code>salinities = np.array([10000, 50000, 100000, 200000])  # ppm NaCl\n\npvt_data = build_pvt_table_data(\n    pressures=pressures,\n    temperatures=temperatures,\n    oil_specific_gravity=0.87,\n    salinities=salinities,\n)\n</code></pre> <p>With a salinity grid, water property tables become 3D arrays (pressure x temperature x salinity), enabling interpolation across all three dimensions.</p>"},{"location":"user-guide/advanced/pvt-tables/#creating-pvt-tables-interpolators","title":"Creating PVT Tables (Interpolators)","text":"<p>Once you have a <code>PVTTableData</code> object, wrap it in <code>PVTTables</code> to build the interpolators:</p> <pre><code>pvt_tables = PVTTables(\n    data=pvt_data,\n    interpolation_method=\"linear\",\n    validate=True,\n    warn_on_extrapolation=False,\n)\n</code></pre> <p>The <code>PVTTables</code> constructor validates the data (grid monotonicity, physical consistency) and builds fast interpolators using <code>scipy.interpolate.RectBivariateSpline</code> for 2D properties and <code>scipy.interpolate.RegularGridInterpolator</code> for 3D properties. The interpolators provide O(1) lookup performance.</p>"},{"location":"user-guide/advanced/pvt-tables/#interpolation-methods","title":"Interpolation Methods","text":"Method Speed Accuracy Minimum Points <code>\"linear\"</code> Fast 1<sup>st</sup> order 2 per dimension <code>\"cubic\"</code> Slower 3<sup>rd</sup> order, smooth derivatives 4 per dimension <p>Linear interpolation is recommended for most cases. Use cubic interpolation when you need smooth derivatives (for example, in Newton iterations where property derivatives affect convergence) and have enough data points (at least 4 per dimension).</p>"},{"location":"user-guide/advanced/pvt-tables/#memory-management","title":"Memory Management","text":"<p>After building the interpolators, the raw table data is no longer needed. You can discard it to save approximately 50% of the memory used by the PVT system:</p> <pre><code>import gc\n\npvt_data = build_pvt_table_data(...)\npvt_tables = PVTTables(pvt_data)\n\ndel pvt_data\ngc.collect()  # Optional: force garbage collection\n</code></pre>"},{"location":"user-guide/advanced/pvt-tables/#physical-consistency-validation","title":"Physical Consistency Validation","text":"<p>When <code>validate=True</code> (the default), <code>PVTTables</code> checks that:</p> <ul> <li>All viscosities are positive</li> <li>All densities are positive</li> <li>All formation volume factors are positive</li> <li>Gas density is less than oil density at all conditions</li> <li>2D tables have shape (n_pressures, n_temperatures)</li> <li>3D tables have shape (n_pressures, n_temperatures, n_salinities)</li> </ul> <p>If any check fails, a <code>ValidationError</code> is raised with a descriptive message. Set <code>validate=False</code> to skip these checks for faster initialization when you are confident in your data quality.</p>"},{"location":"user-guide/advanced/pvt-tables/#property-clamping","title":"Property Clamping","text":"<p>By default, interpolated values are clamped to physically reasonable ranges to prevent unphysical extrapolation artifacts:</p> Property Minimum Maximum Oil viscosity 1e-6 cP 10,000 cP Oil compressibility 0 0.1 psi-1 Oil density 1.0 lb/ft3 80.0 lb/ft3 Oil FVF 0.5 bbl/STB 5.0 bbl/STB Solution GOR 0 SCF/STB 5,000 SCF/STB Gas viscosity 1e-6 cP 100 cP Gas z-factor 0.1 3.0 Water viscosity 1e-6 cP 10.0 cP Water FVF 0.9 bbl/STB 2.0 bbl/STB <p>You can provide custom clamp ranges:</p> <pre><code>custom_clamps = {\n    \"oil_viscosity\": (0.1, 500.0),\n    \"oil_density\": (30.0, 60.0),\n}\n\npvt_tables = PVTTables(\n    data=pvt_data,\n    clamps=custom_clamps,\n)\n</code></pre>"},{"location":"user-guide/advanced/pvt-tables/#using-pvt-tables-in-a-simulation","title":"Using PVT Tables in a Simulation","text":"<p>Pass the <code>PVTTables</code> object to the <code>Config</code>:</p> <pre><code>config = bores.Config(\n    timer=timer,\n    rock_fluid_tables=rock_fluid,\n    wells=wells,\n    pvt_tables=pvt_tables,\n)\n\nstates = list(bores.run(model, config))\n</code></pre> <p>When <code>pvt_tables</code> is provided, BORES uses the tabulated data for all fluid property lookups instead of correlations. This affects pressure equation coefficients, mobility calculations, well rate conversions, and all other computations that depend on fluid properties.</p>"},{"location":"user-guide/advanced/pvt-tables/#extrapolation-behavior","title":"Extrapolation Behavior","text":"<p>When the simulation encounters conditions outside the table bounds (pressure or temperature beyond the defined range), the interpolators extrapolate using the same method (linear or cubic) used for interpolation. This can produce physically unreasonable values if the extrapolation extends far beyond the data.</p> <p>To detect extrapolation, set <code>warn_on_extrapolation=True</code>:</p> <pre><code>pvt_tables = PVTTables(\n    data=pvt_data,\n    warn_on_extrapolation=True,\n)\n</code></pre> <p>This logs a warning each time a query falls outside the table bounds, helping you identify whether your pressure and temperature ranges are sufficient for the simulation conditions.</p> <p>Choosing Table Ranges</p> <p>Build your PVT tables with pressure and temperature ranges that extend slightly beyond the expected simulation conditions. If your initial pressure is 3,000 psi and you expect it to decline to 500 psi, define your pressure grid from 400 to 3,500 psi. This margin prevents extrapolation during normal operation while keeping the table compact.</p>"},{"location":"user-guide/advanced/serialization/","title":"Serialization and Storage","text":""},{"location":"user-guide/advanced/serialization/#overview","title":"Overview","text":"<p>BORES provides a comprehensive serialization system for saving and loading simulation data. You can save reservoir models, configurations, simulation states, and analysis results to disk in multiple formats, then load them later to continue a simulation, reproduce results, or share data with collaborators.</p> <p>The serialization system has two layers. The base layer (<code>Serializable</code>) handles conversion between Python objects and dictionaries. The storage layer (<code>StoreSerializable</code>) adds the ability to write those dictionaries to various file backends. Most BORES objects inherit from both, so they support both in-memory round-tripping and file-based persistence.</p>"},{"location":"user-guide/advanced/serialization/#storage-backends","title":"Storage Backends","text":"<p>BORES supports four storage backends, each with different trade-offs:</p> Backend Format Append Best For <code>ZarrStore</code> Zarr (chunked arrays) Yes Large simulations, streaming, array-heavy data <code>HDF5Store</code> HDF5 Yes Interoperability, scientific data exchange <code>JSONStore</code> JSON No Small configs, human-readable, debugging <code>YAMLStore</code> YAML No Configuration files, human-readable"},{"location":"user-guide/advanced/serialization/#zarrstore","title":"ZarrStore","text":"<p>Zarr is the recommended backend for simulation state data. It stores arrays in a chunked, compressed format that is fast to write and read, supports appending without rewriting existing data, and handles large datasets efficiently.</p> <pre><code>from bores.stores import ZarrStore\n\nstore = ZarrStore(\"simulation.zarr\")\n\n# Save states\nstore.dump(states)\n\n# Load states\nfrom bores.states import ModelState\nloaded_states = list(store.load(ModelState))\n</code></pre>"},{"location":"user-guide/advanced/serialization/#hdf5store","title":"HDF5Store","text":"<p>HDF5 is widely supported in the scientific computing ecosystem. Use it when you need to share data with other tools (MATLAB, Paraview, commercial simulators) or when your organization has standardized on HDF5.</p> <pre><code>from bores.stores import HDF5Store\n\nstore = HDF5Store(\"simulation.h5\")\nstore.dump(states)\nloaded_states = list(store.load(ModelState))\n</code></pre>"},{"location":"user-guide/advanced/serialization/#jsonstore","title":"JSONStore","text":"<p>JSON is human-readable and useful for saving small objects like configurations. It does not handle large numpy arrays efficiently, so avoid using it for state data.</p> <pre><code>from bores.stores import JSONStore\n\nstore = JSONStore(\"config.json\")\nstore.dump([config])\nloaded_config = next(store.load(type(config)))\n</code></pre>"},{"location":"user-guide/advanced/serialization/#yamlstore","title":"YAMLStore","text":"<p>YAML is similar to JSON but more human-friendly. Use it for configuration files that you want to edit by hand.</p> <pre><code>from bores.stores import YAMLStore\n\nstore = YAMLStore(\"config.yaml\")\nstore.dump([config])\n</code></pre>"},{"location":"user-guide/advanced/serialization/#creating-stores-with-new_store","title":"Creating Stores with <code>new_store</code>","text":"<p>The <code>new_store</code> factory function creates the appropriate store based on the file extension:</p> <pre><code>from bores.stores import new_store\n\nstore = new_store(\"output.zarr\")   # ZarrStore\nstore = new_store(\"output.h5\")    # HDF5Store\nstore = new_store(\"output.json\")  # JSONStore\nstore = new_store(\"output.yaml\")  # YAMLStore\n</code></pre>"},{"location":"user-guide/advanced/serialization/#store-operations","title":"Store Operations","text":""},{"location":"user-guide/advanced/serialization/#dumping-data","title":"Dumping Data","text":"<p>The <code>dump()</code> method writes an iterable of serializable objects to the store, overwriting any existing content:</p> <pre><code>store.dump(states)\n</code></pre> <p>You can optionally provide a validator (called on each item before writing) and a metadata function (for lightweight filtering without deserializing):</p> <pre><code>store.dump(\n    states,\n    validator=lambda s: validate_state(s, dtype=\"global\"),\n    meta=lambda s: {\"step\": s.step, \"time\": s.time_in_days},\n)\n</code></pre>"},{"location":"user-guide/advanced/serialization/#loading-data","title":"Loading Data","text":"<p>The <code>load()</code> method returns a generator that yields deserialized objects:</p> <pre><code>from bores.states import ModelState\n\n# Load all states\nfor state in store.load(ModelState):\n    process(state)\n\n# Load specific indices\nfor state in store.load(ModelState, indices=[0, 50, 99]):\n    analyze(state)\n\n# Load with a predicate on metadata\nfor state in store.load(ModelState, predicate=lambda e: e.idx &lt; 10):\n    plot_early(state)\n</code></pre> <p>The <code>indices</code> parameter loads only the items at the specified positions (zero-based). The <code>predicate</code> parameter filters based on <code>EntryMeta</code> objects, which contain the index and any metadata stored during <code>dump()</code>. Both options avoid deserializing items that you do not need.</p>"},{"location":"user-guide/advanced/serialization/#appending-data","title":"Appending Data","text":"<p>Stores that support appending (<code>ZarrStore</code>, <code>HDF5Store</code>) can add items without rewriting existing content:</p> <pre><code>if store.supports_append:\n    entry_meta = store.append(new_state)\n    print(f\"Appended at index {entry_meta.idx}\")\n</code></pre>"},{"location":"user-guide/advanced/serialization/#inspecting-entries","title":"Inspecting Entries","text":"<p>The <code>entries()</code> method returns metadata for all stored items without deserializing any array data:</p> <pre><code>entries = store.entries()\nprint(f\"Store contains {len(entries)} items\")\nfor entry in entries:\n    print(f\"  Index {entry.idx}: {entry.group_name}\")\n</code></pre>"},{"location":"user-guide/advanced/serialization/#serializable-protocol","title":"Serializable Protocol","text":"<p>All BORES objects that support serialization inherit from the <code>Serializable</code> base class. This class provides <code>dump()</code> and <code>load()</code> methods for dictionary round-tripping:</p> <pre><code># Serialize to dictionary\ndata = config.dump()\n\n# Deserialize from dictionary\nrestored_config = type(config).load(data)\n</code></pre>"},{"location":"user-guide/advanced/serialization/#custom-serialization","title":"Custom Serialization","text":"<p>If you create custom classes that need to be serialized, you can implement the <code>__dump__</code> and <code>__load__</code> methods:</p> <pre><code>from bores.serialization import Serializable\n\nclass MyData(Serializable):\n    def __init__(self, values):\n        self.values = values\n\n    def __dump__(self, recurse=True):\n        return {\"values\": self.values.tolist()}\n\n    @classmethod\n    def __load__(cls, data):\n        import numpy as np\n        return cls(values=np.array(data[\"values\"]))\n</code></pre>"},{"location":"user-guide/advanced/serialization/#custom-storage-backends","title":"Custom Storage Backends","text":"<p>You can register custom storage backends using the <code>@storage_backend</code> decorator:</p> <pre><code>from bores.stores import storage_backend, DataStore\n\n@storage_backend(name=\"parquet\")\nclass ParquetStore(DataStore):\n    def dump(self, data, **kwargs):\n        ...\n\n    def load(self, typ, **kwargs):\n        ...\n\n    def entries(self):\n        ...\n\n    def flush(self):\n        ...\n</code></pre>"},{"location":"user-guide/advanced/serialization/#file-based-persistence","title":"File-Based Persistence","text":"<p>Most BORES objects inherit from <code>StoreSerializable</code>, which provides convenient methods for saving and loading directly to and from files. The file extension determines which storage backend is used automatically.</p>"},{"location":"user-guide/advanced/serialization/#to_file-and-from_file","title":"<code>to_file</code> and <code>from_file</code>","text":"<p>The <code>to_file()</code> method saves any serializable object to a file. The <code>from_file()</code> class method loads it back. The file extension determines the storage format: <code>.zarr</code> uses ZarrStore, <code>.h5</code> uses HDF5Store, <code>.json</code> uses JSONStore, and <code>.yaml</code> uses YAMLStore.</p> <pre><code>import bores\nfrom bores.models import ReservoirModel\n\n# Save a model to HDF5\nmodel.to_file(\"my_model.h5\")\n\n# Load it back\nloaded_model = ReservoirModel.from_file(\"my_model.h5\")\n</code></pre> <p>The <code>save</code> method is an alias for <code>to_file</code>, so you can use whichever reads better in your code:</p> <pre><code>model.save(\"my_model.h5\")  # Same as model.to_file(\"my_model.h5\")\n</code></pre>"},{"location":"user-guide/advanced/serialization/#to_store-and-from_store","title":"<code>to_store</code> and <code>from_store</code>","text":"<p>When you already have a store object (for example, because you want to reuse a connection or configure specific options), use <code>to_store()</code> and <code>from_store()</code> directly:</p> <pre><code>from bores.stores import ZarrStore\n\nstore = ZarrStore(\"models.zarr\")\n\n# Save to an existing store\nmodel.to_store(store)\n\n# Load from an existing store\nloaded_model = ReservoirModel.from_store(store)\n</code></pre> <p>The <code>from_store()</code> method returns the first item in the store (or <code>None</code> if the store is empty). If the store contains multiple items, only the first is returned.</p>"},{"location":"user-guide/advanced/serialization/#saving-and-loading-configurations","title":"Saving and Loading Configurations","text":"<p>Configurations are best saved as YAML or JSON for human readability. You can edit the YAML file by hand and reload it:</p> <pre><code># Save config to YAML\nconfig.to_file(\"simulation_config.yaml\")\n\n# Edit the YAML file by hand, then reload\nloaded_config = bores.Config.from_file(\"simulation_config.yaml\")\n</code></pre>"},{"location":"user-guide/advanced/serialization/#saving-and-loading-models","title":"Saving and Loading Models","text":"<p>Reservoir models contain large arrays (porosity, permeability, saturations), so HDF5 or Zarr are the best formats:</p> <pre><code># Save model to HDF5\nmodel.to_file(\"reservoir_model.h5\")\n\n# Load model\nfrom bores.models import ReservoirModel\nloaded_model = ReservoirModel.from_file(\"reservoir_model.h5\")\n</code></pre>"},{"location":"user-guide/advanced/serialization/#timer-state","title":"Timer State","text":"<p>The timer supports its own state serialization for checkpointing mid-simulation:</p> <pre><code># Save timer state\ntimer_state = timer.dump_state()\n\n# Restore timer\nrestored_timer = bores.Timer.load_state(timer_state)\n</code></pre>"},{"location":"user-guide/advanced/serialization/#run-objects","title":"Run Objects","text":"<p>The <code>Run</code> class bundles a reservoir model and a simulation configuration into a single, serializable unit. You can think of a <code>Run</code> as a simulation definition: it contains everything needed to reproduce a simulation. Because <code>Run</code> inherits from <code>StoreSerializable</code>, you can save and load entire simulation setups with a single call.</p>"},{"location":"user-guide/advanced/serialization/#creating-a-run","title":"Creating a Run","text":"<pre><code>import bores\n\nrun = bores.Run(\n    model=model,\n    config=config,\n    name=\"Base Case Waterflood\",\n    description=\"5-spot pattern, 1000 STB/day injection\",\n    tags=(\"waterflood\", \"base-case\", \"field-A\"),\n)\n</code></pre> <p>The <code>name</code>, <code>description</code>, and <code>tags</code> fields are optional metadata for organizing your simulation library. The <code>created_at</code> field is set automatically to the current UTC timestamp.</p>"},{"location":"user-guide/advanced/serialization/#executing-a-run","title":"Executing a Run","text":"<p>A <code>Run</code> is callable and iterable. Calling it returns a generator of <code>ModelState</code> objects, exactly like <code>bores.run(model, config)</code>. Iterating over it does the same thing.</p> <pre><code># As a callable\nfor state in run():\n    process(state)\n\n# As an iterable\nfor state in run:\n    process(state)\n\n# With bores.run() (accepts Run objects directly)\nfor state in bores.run(run):\n    process(state)\n\n# Override config at execution time\nnew_config = config.with_updates(output_frequency=5)\nfor state in bores.run(run, config=new_config):\n    process(state)\n</code></pre>"},{"location":"user-guide/advanced/serialization/#saving-and-loading-runs","title":"Saving and Loading Runs","text":"<p>Because <code>Run</code> is a <code>StoreSerializable</code>, you can save and load complete simulation definitions:</p> <pre><code># Save run to HDF5\nrun.to_file(\"base_case.h5\")\n\n# Load run later\nloaded_run = bores.Run.from_file(\"base_case.h5\")\nprint(f\"Run: {loaded_run.name}\")\nprint(f\"Created: {loaded_run.created_at}\")\n\n# Execute the loaded run\nfor state in loaded_run:\n    process(state)\n</code></pre>"},{"location":"user-guide/advanced/serialization/#loading-from-separate-files","title":"Loading from Separate Files","text":"<p>When your model and config are stored in separate files, use the <code>from_files()</code> class method:</p> <pre><code>run = bores.Run.from_files(\n    model_path=\"reservoir_model.h5\",\n    config_path=\"simulation_config.yaml\",\n    pvt_table_path=\"pvt_tables.h5\",  # Optional\n)\n</code></pre> <p>The <code>pvt_table_path</code> parameter is optional. When provided, the PVT tables are loaded and attached to the config automatically. This is useful when PVT data comes from a separate laboratory analysis file.</p>"},{"location":"user-guide/advanced/serialization/#complete-workflows","title":"Complete Workflows","text":""},{"location":"user-guide/advanced/serialization/#run-save-states-and-analyze-later","title":"Run, Save States, and Analyze Later","text":"<p>The most common workflow is to run a simulation with streaming persistence, then analyze the saved results in a separate session:</p> <pre><code>import bores\nfrom bores.stores import ZarrStore\nfrom bores.streams import StateStream\n\n# Session 1: Run and save\nstore = ZarrStore(\"simulation.zarr\")\nwith StateStream(\n    states=bores.run(model, config),\n    store=store,\n    checkpoint_store=ZarrStore(\"checkpoints.zarr\"),\n    checkpoint_interval=50,\n) as stream:\n    stream.consume()\n\n# Session 2: Analyze saved results (no re-simulation needed)\nfrom bores.states import ModelState\nfrom bores.analyses import ModelAnalyst\n\nstore = ZarrStore(\"simulation.zarr\")\nanalyst = ModelAnalyst(store.load(ModelState))\nprint(f\"Recovery factor: {analyst.oil_recovery_factor:.2%}\")\n</code></pre>"},{"location":"user-guide/advanced/serialization/#save-and-reproduce-a-simulation","title":"Save and Reproduce a Simulation","text":"<p>Package a simulation as a <code>Run</code> object so anyone can reproduce it:</p> <pre><code># Save the simulation definition\nrun = bores.Run(\n    model=model,\n    config=config,\n    name=\"SPE1 Benchmark\",\n    tags=(\"benchmark\", \"spe1\"),\n)\nrun.to_file(\"spe1_run.h5\")\n\n# Later (or on another machine): reproduce exactly\nloaded_run = bores.Run.from_file(\"spe1_run.h5\")\nstates = list(bores.run(loaded_run))\n</code></pre>"},{"location":"user-guide/advanced/serialization/#load-just-the-final-state","title":"Load Just the Final State","text":"<p>When you only need the end result from a previously saved simulation:</p> <pre><code>store = ZarrStore(\"simulation.zarr\")\nentries = store.entries()\nfinal_state = next(store.load(ModelState, indices=[entries[-1].idx]))\nprint(f\"Final pressure: {final_state.model.fluid_properties.pressure_grid.mean():.1f} psi\")\n</code></pre>"},{"location":"user-guide/advanced/states-streams/","title":"States and Streams","text":""},{"location":"user-guide/advanced/states-streams/#overview","title":"Overview","text":"<p>When you run a BORES simulation, the simulator produces a sequence of <code>ModelState</code> objects, one for each accepted time step. Each state captures a complete snapshot of the reservoir at that moment: pressures, saturations, well rates, relative permeabilities, mobilities, and capillary pressures. Understanding how to work with states is essential for analyzing simulation results.</p> <p>For large simulations, holding all states in memory simultaneously can be expensive. A 100,000-cell model with 500 time steps generates roughly 2 GB of state data at 32-bit precision. The <code>StateStream</code> class solves this by persisting states to disk as they are produced and optionally replaying them later, keeping memory usage constant regardless of simulation length.</p> <p>Beyond just collecting and storing states, BORES provides <code>ModelAnalyst</code> for post-processing simulation results. The analyst accepts states (from a list, a stream, or a store replay) and computes volumetrics, recovery factors, production histories, material balance drive indices, sweep efficiency, decline curves, and well productivity metrics. See the Model Analysis page for full details on the analyst API.</p>"},{"location":"user-guide/advanced/states-streams/#model-state","title":"Model State","text":"<p>The <code>ModelState</code> class is a frozen (immutable) attrs class that captures the reservoir state at a single time step. Every field on a <code>ModelState</code> is a snapshot in time. Because the class is frozen, you cannot mutate any field after creation. If you need a modified version, use <code>attrs.evolve()</code> to create a copy with selected fields changed.</p> <pre><code>states = list(bores.run(model, config))\nstate = states[-1]  # Last time step\n\n# Time information\nprint(state.step)              # Time step index (0-based)\nprint(state.step_size)         # Step size in seconds\nprint(state.time)              # Elapsed time in seconds\nprint(state.time_in_days)      # Elapsed time in days\nprint(state.time_in_years)     # Elapsed time in years\n</code></pre>"},{"location":"user-guide/advanced/states-streams/#accessing-reservoir-properties","title":"Accessing Reservoir Properties","text":"<p>The <code>model</code> field contains the full reservoir model with all property grids. The model itself is also frozen, so you always get a consistent snapshot of the reservoir at that moment.</p> <pre><code># Pressure and saturation grids (3D numpy arrays matching grid shape)\npressure = state.model.fluid_properties.pressure_grid\nSw = state.model.fluid_properties.water_saturation_grid\nSo = state.model.fluid_properties.oil_saturation_grid\nSg = state.model.fluid_properties.gas_saturation_grid\n\n# PVT properties\noil_visc = state.model.fluid_properties.oil_viscosity_grid\nwater_visc = state.model.fluid_properties.water_viscosity_grid\noil_fvf = state.model.fluid_properties.oil_formation_volume_factor_grid\ngas_fvf = state.model.fluid_properties.gas_formation_volume_factor_grid\nRs = state.model.fluid_properties.solution_gas_to_oil_ratio_grid\nPb = state.model.fluid_properties.oil_bubble_point_pressure_grid\n\n# Rock properties\nporosity = state.model.rock_properties.porosity_grid\nperm_x = state.model.rock_properties.absolute_permeability.x\nperm_y = state.model.rock_properties.absolute_permeability.y\nperm_z = state.model.rock_properties.absolute_permeability.z\n</code></pre>"},{"location":"user-guide/advanced/states-streams/#accessing-flow-properties","title":"Accessing Flow Properties","text":"<p>Injection and production rates, relative permeabilities, and mobilities are stored directly on the state rather than nested inside the model. Rates are in reservoir cubic feet per day at the cell level.</p> <pre><code># Injection and production rates (ft3/day per cell)\noil_injection = state.injection.oil\nwater_injection = state.injection.water\ngas_injection = state.injection.gas\n\noil_production = state.production.oil\nwater_production = state.production.water\ngas_production = state.production.gas\n\n# Relative permeabilities (dimensionless, 0 to 1)\nkro = state.relative_permeabilities.oil\nkrw = state.relative_permeabilities.water\nkrg = state.relative_permeabilities.gas\n\n# Relative mobilities (1/cP, kr/mu)\nlambda_o = state.relative_mobilities.oil\nlambda_w = state.relative_mobilities.water\nlambda_g = state.relative_mobilities.gas\n\n# Capillary pressures (psi)\npcow = state.capillary_pressures.oil_water\npcog = state.capillary_pressures.oil_gas\n</code></pre>"},{"location":"user-guide/advanced/states-streams/#well-information","title":"Well Information","text":"<p>The well configuration at each state is accessible through the <code>wells</code> field. The <code>wells_exists()</code> method checks whether any wells are defined without loading the full well data structure.</p> <pre><code>if state.wells_exists():\n    wells = state.wells\n    for well in wells.production_wells:\n        print(f\"Well {well.name}: skin={well.skin_factor}\")\n</code></pre>"},{"location":"user-guide/advanced/states-streams/#timer-state","title":"Timer State","text":"<p>The timer's internal state (step count, proposed next step size, performance history) is optionally captured when <code>Config.capture_timer_state</code> is enabled.</p> <pre><code>if state.timer_state is not None:\n    ts = state.timer_state\n    print(f\"Next proposed step: {ts['next_step_size']:.2f} seconds\")\n    print(f\"Steps since failure: {ts['steps_since_last_failure']}\")\n</code></pre>"},{"location":"user-guide/advanced/states-streams/#collecting-states","title":"Collecting States","text":"<p>The simplest approach is to collect all states in a list. The <code>bores.run()</code> function returns a generator, so calling <code>list()</code> forces the entire simulation to run and stores every state in memory.</p> <pre><code>states = list(bores.run(model, config))\n\n# Extract time series data\nimport numpy as np\n\ntime_days = np.array([s.time_in_days for s in states])\navg_pressure = np.array([\n    s.model.fluid_properties.pressure_grid.mean() for s in states\n])\navg_So = np.array([\n    s.model.fluid_properties.oil_saturation_grid.mean() for s in states\n])\n</code></pre> <p>This is fine for simulations that produce a manageable number of states (up to a few hundred). For longer runs, consider using <code>output_frequency</code> in the <code>Config</code> to reduce the number of states, or use <code>StateStream</code> for disk-backed persistence.</p>"},{"location":"user-guide/advanced/states-streams/#output-frequency","title":"Output Frequency","text":"<p>The <code>output_frequency</code> parameter in <code>Config</code> controls how often states are yielded:</p> <pre><code>config = bores.Config(\n    timer=timer,\n    rock_fluid_tables=rock_fluid,\n    wells=wells,\n    output_frequency=10,  # Yield every 10th step\n)\n</code></pre> <p>With <code>output_frequency=10</code>, the simulator still runs all time steps internally but only yields a state every 10<sup>th</sup> step, reducing memory usage by 10x. The intermediate steps are computed but not stored.</p>"},{"location":"user-guide/advanced/states-streams/#state-stream","title":"State Stream","text":"<p><code>StateStream</code> provides memory-efficient state iteration with optional disk persistence. It wraps the simulation generator and writes states to a <code>DataStore</code> as they are produced, immediately freeing the memory used by each state. The stream acts as both a context manager and an iterator, and offers several methods for controlling how you consume and replay states.</p> <p>The core idea is that you iterate through states exactly once during the simulation. As each state passes through, the stream optionally persists it to a store. After the simulation is exhausted, you can replay any or all of the saved states from the store without re-running the simulation. This keeps peak memory usage proportional to <code>batch_size</code> rather than the total number of states.</p> <pre><code>from bores.streams import StateStream\nfrom bores.stores import ZarrStore\n\nstore = ZarrStore(\"simulation_run.zarr\")\n\nwith StateStream(\n    states=bores.run(model, config),\n    store=store,\n    batch_size=10,\n) as stream:\n    for state in stream:\n        print(f\"Step {state.step}: P_avg = {state.model.fluid_properties.pressure_grid.mean():.1f}\")\n</code></pre>"},{"location":"user-guide/advanced/states-streams/#configuration-options","title":"Configuration Options","text":"Parameter Default Description <code>states</code> (required) Generator or iterator of <code>ModelState</code> instances <code>store</code> <code>None</code> Storage backend for persistence. Must support appending <code>batch_size</code> 10 States accumulated before flushing to disk <code>validate</code> <code>False</code> Validate states before saving (checks grid shapes, dtype consistency) <code>auto_save</code> <code>True</code> Flush remaining states on context exit <code>auto_replay</code> <code>True</code> Replay from store when iterating after consumption <code>save</code> <code>True</code> Boolean or filter function for selective saving <code>background_io</code> <code>False</code> Write to disk in a background thread <code>max_queue_size</code> 50 Back-pressure limit for background I/O queue <code>checkpoint_interval</code> <code>None</code> Create a checkpoint every N states <code>checkpoint_store</code> <code>None</code> Separate store for checkpoints <code>max_batch_memory_usage</code> <code>None</code> Force flush when batch exceeds this size (MB)"},{"location":"user-guide/advanced/states-streams/#stream-methods","title":"Stream Methods","text":""},{"location":"user-guide/advanced/states-streams/#iterating-with-for","title":"Iterating with <code>for</code>","text":"<p>The most common way to use a stream is the <code>for</code> loop. On the first pass, the stream consumes the underlying generator, yielding each state and persisting it to the store according to the <code>save</code> and <code>batch_size</code> settings. If you iterate again after the generator is exhausted, the stream automatically replays from the store (if <code>auto_replay=True</code>).</p> <pre><code>with StateStream(states=bores.run(model, config), store=store) as stream:\n    # First pass: runs the simulation, saves states\n    for state in stream:\n        process(state)\n\n    # Second pass: replays from store (no re-simulation)\n    for state in stream:\n        plot(state)\n</code></pre> <p>If <code>auto_replay</code> is <code>False</code>, iterating a second time raises a <code>StreamError</code>. In that case, you must call <code>replay()</code> explicitly.</p>"},{"location":"user-guide/advanced/states-streams/#consume","title":"consume()","text":"<p>The <code>consume()</code> method exhausts the entire stream without yielding any states to your code. All configured side effects (persistence, checkpointing, validation) still occur normally. This is useful when you want to run a simulation purely for the purpose of saving its output to disk.</p> <pre><code>stream = StateStream(\n    states=bores.run(model, config),\n    store=ZarrStore(\"run.zarr\"),\n    checkpoint_store=ZarrStore(\"checkpoints.zarr\"),\n    checkpoint_interval=100,\n)\nstream.consume()  # States saved and checkpointed, nothing returned\n</code></pre> <p>After calling <code>consume()</code>, the stream is marked as consumed. Calling <code>consume()</code> again has no effect. You can still call <code>replay()</code> to load the saved states.</p>"},{"location":"user-guide/advanced/states-streams/#last","title":"last()","text":"<p>The <code>last()</code> method returns the final state from the stream. If the stream has not been consumed yet, it iterates through the entire simulation (triggering all side effects) and returns the last state yielded. If the stream has already been consumed and a store is available, it loads only the last entry from the store without replaying everything.</p> <pre><code>with StateStream(states=bores.run(model, config), store=store) as stream:\n    final_state = stream.last()\n    print(f\"Final pressure: {final_state.model.fluid_properties.pressure_grid.mean():.1f}\")\n</code></pre> <p>This is particularly useful when you only need the end result of a simulation but still want all intermediate states saved to disk.</p>"},{"location":"user-guide/advanced/states-streams/#untilcondition","title":"until(condition)","text":"<p>The <code>until()</code> method iterates through the stream, yielding states one at a time, until the <code>condition</code> function returns <code>True</code>. The state that satisfies the condition is yielded as well, then iteration stops. All configured side effects (persistence, checkpointing) apply to every state that passes through, including those before the stop condition is met.</p> <pre><code>with StateStream(states=bores.run(model, config), store=store) as stream:\n    # Run until average pressure drops below 1500 psi\n    for state in stream.until(\n        lambda s: s.model.fluid_properties.pressure_grid.mean() &lt; 1500.0\n    ):\n        print(f\"Step {state.step}: P = {state.model.fluid_properties.pressure_grid.mean():.1f}\")\n</code></pre> <p>The condition receives a <code>ModelState</code> and returns a boolean. Use <code>until()</code> when you have a physical stopping criterion (\"stop when water cut exceeds 95%\") rather than a fixed number of steps. Note that the remaining states in the underlying generator are not consumed, so the simulation stops early. If the condition never becomes <code>True</code>, the entire stream is consumed.</p>"},{"location":"user-guide/advanced/states-streams/#while_condition","title":"while_(condition)","text":"<p>The <code>while_()</code> method is the complement of <code>until()</code>. It iterates as long as the <code>condition</code> returns <code>True</code>, and stops when the condition becomes <code>False</code>. The final state (where the condition failed) is also yielded.</p> <pre><code>with StateStream(states=bores.run(model, config), store=store) as stream:\n    # Run while oil saturation is above residual\n    for state in stream.while_(\n        lambda s: s.model.fluid_properties.oil_saturation_grid.mean() &gt; 0.15\n    ):\n        analyze(state)\n</code></pre> <p>Like <code>until()</code>, all side effects apply to every state that passes through. The key difference is the semantics: <code>until()</code> runs until something happens, <code>while_()</code> runs while something holds. Choose whichever reads more naturally for your use case.</p>"},{"location":"user-guide/advanced/states-streams/#replayindices-predicate-steps-validator","title":"replay(indices, predicate, steps, validator)","text":"<p>The <code>replay()</code> method loads previously saved states from the store. It returns an iterator, so you can process states one at a time without loading everything into memory. Filtering happens before deserialization, so skipped entries have no I/O cost.</p> <pre><code># Replay all saved states\nfor state in stream.replay():\n    plot(state)\n\n# Replay specific entries by insertion-order index\nfor state in stream.replay(indices=[0, 50, 99]):\n    compare(state)\n\n# Replay by simulation step number\nfor state in stream.replay(steps=[0, 100, 200, 300]):\n    analyze(state)\n\n# Replay using a step filter function\nfor state in stream.replay(steps=lambda s: s % 50 == 0):\n    log(state)\n\n# Replay with metadata predicate\nfor state in stream.replay(predicate=lambda e: e.meta.get(\"step\", 0) &gt; 100):\n    late_analysis(state)\n</code></pre> <p>The parameters can be combined. <code>indices</code> takes priority and bypasses <code>steps</code> and <code>predicate</code>. When both <code>steps</code> and <code>predicate</code> are provided, they are composed with a logical AND (both must pass for a state to be yielded).</p> Parameter Type Description <code>indices</code> <code>Sequence[int]</code> Zero-based insertion-order positions to load <code>steps</code> <code>Sequence[int]</code> or <code>Callable[[int], bool]</code> Filter by simulation step number <code>predicate</code> <code>Callable[[EntryMeta], bool]</code> Filter on stored entry metadata <code>validator</code> <code>Callable[[ModelState], ModelState]</code> Post-load validation/transformation"},{"location":"user-guide/advanced/states-streams/#flushblock","title":"flush(block)","text":"<p>The <code>flush()</code> method manually writes the current batch buffer to the store. In normal operation, flushing happens automatically when the batch reaches <code>batch_size</code> or when the stream exits its context manager. Call <code>flush()</code> explicitly when you need to guarantee that data has been written at a specific point.</p> <pre><code>with StateStream(states=bores.run(model, config), store=store, batch_size=50) as stream:\n    for state in stream:\n        if state.step % 100 == 0:\n            stream.flush(block=True)  # Ensure data is on disk now\n            print(f\"Flushed through step {state.step}\")\n</code></pre> <p>The <code>block</code> parameter controls behavior when <code>background_io=True</code>. With <code>block=False</code> (the default), the batch is enqueued and the method returns immediately. With <code>block=True</code>, the method waits until all pending writes have completed.</p>"},{"location":"user-guide/advanced/states-streams/#progress","title":"progress()","text":"<p>The <code>progress()</code> method returns a <code>StreamProgress</code> dictionary with real-time statistics about the stream's state. Use this for monitoring long-running simulations or building progress bars.</p> <pre><code>with StateStream(states=bores.run(model, config), store=store) as stream:\n    for state in stream:\n        if state.step % 50 == 0:\n            p = stream.progress()\n            print(\n                f\"Yielded: {p['yield_count']}, \"\n                f\"Saved: {p['saved_count']}, \"\n                f\"Checkpoints: {p['checkpoints_count']}, \"\n                f\"Pending: {p['batch_pending']}, \"\n                f\"Memory: {p['memory_usage']:.1f} MB\"\n            )\n</code></pre> <p>The returned dictionary contains:</p> Key Type Description <code>yield_count</code> <code>int</code> Total states yielded (including replays) <code>saved_count</code> <code>int</code> Total states written to store <code>checkpoints_count</code> <code>int</code> Total checkpoints created <code>batch_pending</code> <code>int</code> States in current batch (not yet flushed) <code>store_backend</code> <code>str</code> or <code>None</code> Name of the store class being used <code>memory_usage</code> <code>float</code> Estimated batch memory in MB <p>When <code>background_io=True</code>, two additional keys are available: <code>io_queue_size</code> (current items in the I/O queue) and <code>io_thread_alive</code> (whether the background thread is running).</p>"},{"location":"user-guide/advanced/states-streams/#properties","title":"Properties","text":"<p>The stream also exposes several read-only properties for quick status checks:</p> <pre><code>stream.yield_count       # Total states yielded so far\nstream.saved_count       # Total states saved to store\nstream.checkpoints_count # Total checkpoints created\nstream.is_consumed       # Whether the underlying generator is exhausted\n</code></pre>"},{"location":"user-guide/advanced/states-streams/#background-io","title":"Background I/O","text":"<p>When <code>background_io=True</code>, disk writes happen in a separate thread, allowing the simulation to continue while data is being written. This provides a 2 to 3x speedup when I/O is slower than the simulation itself. The simulation thread fills a queue; the I/O worker thread drains it.</p> <pre><code>with StateStream(\n    states=bores.run(model, config),\n    store=ZarrStore(\"run.zarr\"),\n    background_io=True,\n    max_queue_size=50,\n) as stream:\n    for state in stream:\n        analyze(state)\n</code></pre> <p>The <code>max_queue_size</code> parameter limits the number of batches waiting to be written. When the queue is full, the simulation thread blocks until the I/O worker drains an item. This back-pressure mechanism prevents unbounded memory growth when the simulation produces states faster than they can be written to disk. If the I/O worker encounters an error, the exception is re-raised on the next iteration of the simulation loop so you do not silently lose data.</p>"},{"location":"user-guide/advanced/states-streams/#selective-saving","title":"Selective Saving","text":"<p>You can filter which states are saved using a predicate function passed to the <code>save</code> parameter. All states are still yielded to your code, but only those matching the predicate are persisted.</p> <pre><code># Save every 10th state\nwith StateStream(\n    states=bores.run(model, config),\n    store=store,\n    save=lambda s: s.step % 10 == 0,\n) as stream:\n    for state in stream:\n        pass  # All states yielded, but only every 10th saved\n</code></pre> <p>You can also disable saving entirely by passing <code>save=False</code>. The stream will still iterate through all states but will not write anything to the store.</p>"},{"location":"user-guide/advanced/states-streams/#checkpointing","title":"Checkpointing","text":"<p>For long-running simulations, checkpointing saves the state at regular intervals to a separate store, enabling crash recovery. Checkpoints are written to a dedicated <code>checkpoint_store</code> independently of the main store.</p> <pre><code>with StateStream(\n    states=bores.run(model, config),\n    store=ZarrStore(\"full_run.zarr\"),\n    checkpoint_store=ZarrStore(\"checkpoints.zarr\"),\n    checkpoint_interval=100,\n) as stream:\n    for state in stream:\n        pass\n</code></pre> <p>If the simulation crashes at step 450, the checkpoint store contains the state at steps 100, 200, 300, and 400 (checkpointing starts at step 1, not step 0).</p>"},{"location":"user-guide/advanced/states-streams/#accessing-checkpoints","title":"Accessing Checkpoints","text":"<p>The stream provides methods for working with checkpoints:</p> <pre><code># List available checkpoint step numbers\navailable = stream.list_checkpoints()\nprint(f\"Checkpoints at steps: {available}\")\n\n# Load a specific checkpoint by step number\nstate_at_200 = stream.checkpoint(200)\n\n# Iterate over all checkpoints\nfor checkpoint_state in stream.checkpoints():\n    print(f\"Checkpoint at step {checkpoint_state.step}\")\n</code></pre>"},{"location":"user-guide/advanced/states-streams/#idiomatic-patterns","title":"Idiomatic Patterns","text":""},{"location":"user-guide/advanced/states-streams/#run-save-and-analyze","title":"Run, Save, and Analyze","text":"<p>The most common workflow is to run a simulation with streaming persistence, then analyze the saved results:</p> <pre><code>import bores\nfrom bores.stores import ZarrStore\nfrom bores.streams import StateStream\nfrom bores.analyses import ModelAnalyst\n\nstore = ZarrStore(\"simulation.zarr\")\nwith StateStream(\n    states=bores.run(model, config),\n    store=store,\n    background_io=True,\n) as stream:\n    stream.consume()  # Save everything, process nothing\n\n# Analyze saved results\nfrom bores.states import ModelState\nanalyst = ModelAnalyst(store.load(ModelState))\nprint(f\"Recovery factor: {analyst.oil_recovery_factor:.2%}\")\n</code></pre>"},{"location":"user-guide/advanced/states-streams/#monitor-during-simulation","title":"Monitor During Simulation","text":"<p>If you want to process states as they arrive while also saving them:</p> <pre><code>with StateStream(states=bores.run(model, config), store=store) as stream:\n    for state in stream:\n        if state.step % 10 == 0:\n            p = state.model.fluid_properties.pressure_grid.mean()\n            print(f\"Step {state.step}: P_avg = {p:.1f} psi\")\n</code></pre>"},{"location":"user-guide/advanced/states-streams/#early-stopping","title":"Early Stopping","text":"<p>Use <code>until()</code> or <code>while_()</code> to stop the simulation when a physical criterion is met:</p> <pre><code>with StateStream(states=bores.run(model, config), store=store) as stream:\n    # Stop when water cut exceeds 95%\n    final = None\n    for state in stream.until(\n        lambda s: (s.production.water.sum() / max(s.production.oil.sum() + s.production.water.sum(), 1e-10)) &gt; 0.95\n    ):\n        final = state\n</code></pre>"},{"location":"user-guide/advanced/states-streams/#sparse-replay","title":"Sparse Replay","text":"<p>When analyzing long simulations, load only the states you need:</p> <pre><code># Every 50th step for trend analysis\nanalyst = ModelAnalyst(stream.replay(steps=lambda s: s % 50 == 0))\n\n# First and last only for delta comparison\ninitial = next(stream.replay(indices=[0]))\nfinal = stream.last()\n</code></pre>"},{"location":"user-guide/advanced/states-streams/#get-just-the-final-state","title":"Get Just the Final State","text":"<p>When you only care about the end result:</p> <pre><code>stream = StateStream(states=bores.run(model, config), store=store)\nfinal_state = stream.last()\n</code></pre>"},{"location":"user-guide/simulation/precision/","title":"Floating-Point Precision","text":""},{"location":"user-guide/simulation/precision/#overview","title":"Overview","text":"<p>Floating-point precision determines how many significant digits your simulation carries through every calculation. BORES uses a global precision setting that affects all array allocations, PVT property computations, matrix assembly, and solver operations. The choice of precision involves a direct trade-off between computational speed (lower precision is faster) and numerical accuracy (higher precision reduces rounding errors).</p> <p>In reservoir simulation, precision matters because the pressure and saturation equations involve quantities that span many orders of magnitude. Pressure values are in the thousands of psi, permeabilities range from millidarcies to darcies, and fluid compressibilities are on the order of \\(10^{-6}\\) per psi. When these quantities are combined in transmissibility calculations, the intermediate values can lose significant digits if the precision is too low. However, for most engineering purposes, 32-bit precision provides more than adequate accuracy, and the 2x memory savings and faster computation make it the clear default choice.</p> <p>BORES defaults to 32-bit (single) precision, which is the standard for field-scale reservoir simulation. You should only consider higher precision when you encounter specific numerical issues such as material balance errors, solver convergence problems in ill-conditioned systems, or when matching against analytical solutions that require tighter tolerances.</p>"},{"location":"user-guide/simulation/precision/#precision-levels","title":"Precision Levels","text":"<p>BORES provides three precision levels through simple function calls:</p> <pre><code>import bores\n\nbores.use_32bit_precision()    # numpy.float32 (default)\nbores.use_64bit_precision()    # numpy.float64\nbores.use_128bit_precision()   # numpy.float128\n</code></pre> <p>These functions set the global precision for all subsequent BORES operations. Call them before building your reservoir model, as the precision affects every array that BORES creates from that point forward.</p>"},{"location":"user-guide/simulation/precision/#32-bit-precision-default","title":"32-bit Precision (Default)","text":"<pre><code>bores.use_32bit_precision()\n</code></pre> <p>32-bit floating-point numbers (IEEE 754 single precision) carry approximately 7 significant decimal digits with a range from \\(\\pm 1.2 \\times 10^{-38}\\) to \\(\\pm 3.4 \\times 10^{38}\\). This is the default and recommended setting for nearly all reservoir simulation work. It uses half the memory of 64-bit precision, which means faster array operations, better cache utilization, and the ability to run larger models in the same amount of RAM.</p> <p>For a typical 100,000-cell model, 32-bit precision uses roughly 400 KB per property grid versus 800 KB at 64-bit. The difference multiplies across the dozens of property grids maintained during simulation, making 32-bit models noticeably faster overall.</p>"},{"location":"user-guide/simulation/precision/#64-bit-precision","title":"64-bit Precision","text":"<pre><code>bores.use_64bit_precision()\n</code></pre> <p>64-bit floating-point numbers (IEEE 754 double precision) carry approximately 15 significant decimal digits with a range from \\(\\pm 2.2 \\times 10^{-308}\\) to \\(\\pm 1.8 \\times 10^{308}\\). This precision level is appropriate when you need higher accuracy or when the 32-bit solver shows convergence difficulties.</p> <p>Consider 64-bit precision when:</p> <ul> <li>You observe material balance errors growing over many time steps</li> <li>The iterative solver takes significantly more iterations than expected</li> <li>You are matching against an analytical solution or a commercial simulator that uses double precision</li> <li>Your model has extreme property contrasts (permeability ratios above \\(10^6\\), pressure differences above \\(10^4\\) psi)</li> <li>You are performing sensitivity studies where small numerical differences matter</li> </ul> <p>The performance penalty is typically 30 to 80% compared to 32-bit, depending on the problem size and the proportion of time spent in array operations versus solver iterations.</p>"},{"location":"user-guide/simulation/precision/#128-bit-precision","title":"128-bit Precision","text":"<pre><code>bores.use_128bit_precision()\n</code></pre> <p>128-bit extended precision carries approximately 18 to 33 significant digits depending on the platform (on most x86 systems, <code>numpy.float128</code> is actually 80-bit extended precision, not true IEEE 754 quad precision). This level is rarely needed in practice and is primarily useful for debugging numerical issues or for reference solutions.</p> <p>Platform Support</p> <p>Not all platforms support <code>numpy.float128</code>. On Windows, this type may not be available. On Linux and macOS with x86 processors, it typically maps to 80-bit extended precision (not true 128-bit). Check <code>numpy.finfo(numpy.float128)</code> to see the actual precision on your system. Additionally, most Numba-compiled functions do not support 128-bit types, so some performance-critical code paths may fall back to Python, resulting in significantly slower execution.</p>"},{"location":"user-guide/simulation/precision/#temporary-precision-with-context-manager","title":"Temporary Precision with Context Manager","text":"<p>The <code>with_precision()</code> context manager lets you temporarily change precision for a specific block of code without affecting the global setting. This is useful when you want to run most of your simulation at 32-bit but need higher precision for a specific operation.</p> <pre><code>from bores import with_precision\nimport numpy as np\n\nbores.use_32bit_precision()  # Global default\n\n# Build model at 32-bit precision\nmodel = bores.reservoir_model(...)\n\n# Run a specific analysis at 64-bit\nwith with_precision(np.float64):\n    # Everything inside this block uses float64\n    high_precision_result = some_analysis(model)\n\n# Back to float32 outside the block\n</code></pre> <p>The context manager is thread-safe because it uses Python's <code>ContextVar</code> mechanism. Each thread maintains its own precision setting, so changing precision in one thread does not affect other threads. This is important if you are running multiple simulations in parallel.</p>"},{"location":"user-guide/simulation/precision/#querying-the-current-precision","title":"Querying the Current Precision","text":"<p>You can check and inspect the current precision setting at any time:</p> <pre><code>from bores._precision import get_dtype, get_floating_point_info\n\n# Get the current dtype\ncurrent = get_dtype()\nprint(current)  # &lt;class 'numpy.float32'&gt;\n\n# Get detailed floating-point information\ninfo = get_floating_point_info()\nprint(f\"Precision: {info.precision} decimal digits\")\nprint(f\"Range: {info.min} to {info.max}\")\nprint(f\"Smallest difference: {info.eps}\")\n</code></pre> <p>The <code>get_floating_point_info()</code> function returns a <code>numpy.finfo</code> object with details about the current precision level, including the number of significant digits, the representable range, and the machine epsilon (the smallest number such that \\(1.0 + \\epsilon \\neq 1.0\\)).</p>"},{"location":"user-guide/simulation/precision/#choosing-the-right-precision","title":"Choosing the Right Precision","text":"<p>For the vast majority of reservoir simulation work, 32-bit precision is the right choice. Here is a decision guide:</p> Situation Recommendation Standard field-scale simulation 32-bit (default) Matching commercial simulator results 64-bit Extreme permeability contrasts (&gt; \\(10^6\\)) 64-bit Material balance errors accumulating Try 64-bit Solver taking many iterations (&gt; 100) Try 64-bit Debugging or reference solutions 128-bit (if available) Large models where memory matters 32-bit Maximum performance 32-bit <p>Start with 32-bit</p> <p>Always start with 32-bit precision. If you encounter numerical issues, switch to 64-bit and see if the problem resolves. If it does, the issue was precision-related. If it does not, the root cause is elsewhere (grid quality, time step size, solver configuration) and higher precision will not help.</p>"},{"location":"user-guide/simulation/precision/#impact-on-performance","title":"Impact on Performance","text":"<p>The table below shows approximate performance differences between precision levels for typical reservoir simulation operations:</p> Operation 32-bit 64-bit 128-bit Memory per property grid (100K cells) 400 KB 800 KB 1.6 MB Array arithmetic Baseline 1.3 to 1.5x slower 5 to 10x slower Sparse matrix solve Baseline 1.5 to 2.0x slower Not supported by most solvers Total simulation time Baseline 1.3 to 1.8x slower Much slower (if it works) <p>These numbers are approximate and depend on hardware, problem size, and the ratio of compute-bound to memory-bound operations. On modern CPUs with AVX2 or AVX-512 SIMD instructions, 32-bit operations can process twice as many values per instruction as 64-bit, making the difference particularly pronounced for array-heavy operations.</p>"},{"location":"user-guide/simulation/preconditioners/","title":"Preconditioners","text":""},{"location":"user-guide/simulation/preconditioners/#overview","title":"Overview","text":"<p>Iterative solvers like BiCGSTAB and GMRES work by repeatedly improving an approximate solution until the residual falls below the convergence tolerance. The number of iterations required depends on the condition number of the matrix: well-conditioned matrices converge quickly, while ill-conditioned matrices require many iterations or may not converge at all.</p> <p>A preconditioner transforms the linear system into an equivalent but better-conditioned system that converges faster. Instead of solving \\(A \\cdot x = b\\) directly, the solver works with \\(M^{-1} A \\cdot x = M^{-1} b\\), where \\(M\\) is the preconditioner. A good preconditioner \\(M\\) approximates \\(A\\) well enough that \\(M^{-1} A\\) is close to the identity matrix, but is much cheaper to apply than actually inverting \\(A\\).</p> <p>In reservoir simulation, preconditioners are essential because the pressure matrix becomes increasingly ill-conditioned as permeability contrasts increase, grids become finer, or wells create large source/sink terms. Without preconditioning, the solver may require hundreds or thousands of iterations, or fail to converge entirely.</p> <p>BORES provides several built-in preconditioners, selectable by name through the <code>Config</code>:</p> <pre><code>import bores\n\nconfig = bores.Config(\n    timer=timer,\n    rock_fluid_tables=rock_fluid,\n    wells=wells,\n    pressure_preconditioner=\"ilu\",\n    saturation_preconditioner=\"ilu\",\n)\n</code></pre>"},{"location":"user-guide/simulation/preconditioners/#available-preconditioners","title":"Available Preconditioners","text":"Preconditioner String Name Cost Effectiveness Best For ILU <code>\"ilu\"</code> Moderate Good General purpose (default) AMG <code>\"amg\"</code> High setup, low apply Very good Large, smooth problems CPR <code>\"cpr\"</code> High Excellent Difficult coupled systems Block Jacobi <code>\"block_jacobi\"</code> Low Moderate Parallel-friendly Diagonal <code>\"diagonal\"</code> Very low Weak Fast, simple scaling Polynomial <code>\"polynomial\"</code> Low Moderate Setup-free alternative"},{"location":"user-guide/simulation/preconditioners/#ilu-default","title":"ILU (Default)","text":"<p>ILU (Incomplete LU Factorization) is the default preconditioner and the most commonly used in reservoir simulation. It computes an approximate LU decomposition of the matrix, keeping only the entries that fall within the original sparsity pattern. This gives a good approximation of the matrix inverse at a fraction of the cost of a full factorization.</p> <pre><code>config = bores.Config(\n    timer=timer,\n    rock_fluid_tables=rock_fluid,\n    wells=wells,\n    pressure_preconditioner=\"ilu\",\n    saturation_preconditioner=\"ilu\",\n)\n</code></pre> <p>ILU works well for most reservoir simulation matrices. It typically reduces the iteration count by a factor of 5 to 20 compared to no preconditioning. Its main limitation is that it can struggle with highly anisotropic problems (very large \\(k_v/k_h\\) contrasts) or matrices with extreme coefficient ranges.</p>"},{"location":"user-guide/simulation/preconditioners/#amg","title":"AMG","text":"<p>AMG (Algebraic Multigrid) is a more powerful preconditioner that uses a hierarchy of progressively coarser approximations to accelerate convergence. It is particularly effective for pressure equations in large, smoothly varying grids.</p> <pre><code>config = bores.Config(\n    timer=timer,\n    rock_fluid_tables=rock_fluid,\n    wells=wells,\n    pressure_preconditioner=\"amg\",\n)\n</code></pre> <p>AMG has a higher setup cost than ILU (building the multigrid hierarchy takes time), but applying the preconditioner is very fast. This makes AMG advantageous for large problems where many solver iterations are needed. For small problems (&lt; 10,000 cells), the setup overhead may outweigh the iteration savings.</p> <p>AMG works best for the pressure equation, which has the elliptic character that multigrid exploits. It is less effective for the saturation transport equation, which is hyperbolic. A common pattern is to use AMG for pressure and ILU for saturation.</p>"},{"location":"user-guide/simulation/preconditioners/#cpr","title":"CPR","text":"<p>CPR (Constrained Pressure Residual) is a two-stage preconditioner designed specifically for coupled pressure-saturation systems. It first applies an AMG preconditioner to the pressure subsystem, then applies ILU to the full system. This combination is very effective for the fully implicit scheme where pressure and saturation are solved simultaneously.</p> <pre><code>config = bores.Config(\n    timer=timer,\n    rock_fluid_tables=rock_fluid,\n    wells=wells,\n    scheme=\"implicit\",\n    pressure_preconditioner=\"cpr\",\n)\n</code></pre> <p>CPR is the most expensive preconditioner per application, but it can dramatically reduce the number of Newton iterations needed for implicit convergence. Use it when the implicit scheme with ILU preconditioning shows slow or stalled convergence.</p>"},{"location":"user-guide/simulation/preconditioners/#block-jacobi","title":"Block Jacobi","text":"<p>Block Jacobi is a simple preconditioner that inverts diagonal blocks of the matrix independently. It is less effective than ILU but is naturally parallel (each block can be inverted independently) and has very low setup cost.</p> <pre><code>config = bores.Config(\n    timer=timer,\n    rock_fluid_tables=rock_fluid,\n    wells=wells,\n    pressure_preconditioner=\"block_jacobi\",\n)\n</code></pre>"},{"location":"user-guide/simulation/preconditioners/#diagonal","title":"Diagonal","text":"<p>The diagonal (Jacobi) preconditioner simply scales the system by the inverse of the diagonal entries: \\(M = \\text{diag}(A)\\). It is the cheapest preconditioner (both to build and to apply) but provides only modest improvement. Use it as a baseline or when you want the fastest possible preconditioner with minimal overhead.</p>"},{"location":"user-guide/simulation/preconditioners/#polynomial","title":"Polynomial","text":"<p>The polynomial preconditioner approximates \\(A^{-1}\\) using a truncated Neumann series (polynomial expansion). It requires no factorization, making it useful when the matrix changes frequently and factorization costs would be wasted.</p>"},{"location":"user-guide/simulation/preconditioners/#cached-preconditioners","title":"Cached Preconditioners","text":"<p>Building a preconditioner (especially ILU or AMG) is expensive, but in reservoir simulation the matrix structure stays constant and the coefficients change slowly between time steps. BORES provides <code>CachedPreconditionerFactory</code> to reuse a preconditioner across multiple time steps, rebuilding it only when needed.</p> <pre><code>from bores.diffusivity.base import CachedPreconditionerFactory\n\n# Cache ILU, rebuild every 10 steps or when matrix changes by &gt; 30%\ncached_ilu = CachedPreconditionerFactory(\n    factory=\"ilu\",\n    name=\"cached_ilu\",\n    update_frequency=10,\n    recompute_threshold=0.3,\n)\n\n# Register it for use in Config\ncached_ilu.register(override=True)\n\nconfig = bores.Config(\n    timer=timer,\n    rock_fluid_tables=rock_fluid,\n    wells=wells,\n    pressure_preconditioner=\"cached_ilu\",\n)\n</code></pre> <p>The <code>update_frequency</code> parameter controls how many time steps between forced rebuilds. The <code>recompute_threshold</code> is a relative norm threshold: if the matrix coefficients change by more than this fraction from the cached version, the preconditioner is rebuilt. Setting <code>update_frequency=0</code> disables frequency-based rebuilding, relying solely on the change threshold.</p> <p>Caching can save 20 to 40% of total simulation time for problems where the matrix changes slowly (most depletion and waterflood studies). For problems with rapid changes (gas injection, well events), use a lower <code>update_frequency</code> (3 to 5) to avoid using a stale preconditioner that slows convergence.</p> <p>Caching Strategy</p> <ul> <li>Depletion / waterflooding: <code>update_frequency=10</code>, <code>recompute_threshold=0.3</code></li> <li>Gas injection: <code>update_frequency=5</code>, <code>recompute_threshold=0.2</code></li> <li>Well events / schedules: <code>update_frequency=3</code>, <code>recompute_threshold=0.15</code></li> </ul>"},{"location":"user-guide/simulation/preconditioners/#custom-preconditioners","title":"Custom Preconditioners","text":"<p>You can register custom preconditioner factories using the <code>@preconditioner_factory</code> decorator:</p> <pre><code>from bores.diffusivity.base import preconditioner_factory\n\n@preconditioner_factory(name=\"my_precond\")\ndef my_preconditioner(A_csr):\n    # Build and return a LinearOperator that approximates A^-1\n    # A_csr is a scipy.sparse.csr_array or csr_matrix\n    ...\n\n# Use in Config\nconfig = bores.Config(\n    timer=timer,\n    rock_fluid_tables=rock_fluid,\n    wells=wells,\n    pressure_preconditioner=\"my_precond\",\n)\n</code></pre> <p>The factory function receives the sparse coefficient matrix and must return a <code>scipy.sparse.linalg.LinearOperator</code> that can be applied to a vector (the preconditioner solve step). You can list all registered preconditioner factories with <code>bores.diffusivity.base.list_preconditioner_factories()</code>.</p>"},{"location":"user-guide/simulation/preconditioners/#choosing-a-preconditioner","title":"Choosing a Preconditioner","text":"<p>For most simulations, the default <code>\"ilu\"</code> is the right choice. Consider switching when:</p> Situation Recommendation Default / starting point <code>\"ilu\"</code> Large grids (&gt; 100K cells) <code>\"amg\"</code> for pressure, <code>\"ilu\"</code> for saturation Fully implicit scheme <code>\"cpr\"</code> for pressure High permeability contrast <code>\"amg\"</code> or <code>\"cpr\"</code> Quick runs, small models <code>\"diagonal\"</code> or no preconditioner (<code>None</code>) Matrix changes frequently <code>CachedPreconditionerFactory</code> with <code>\"ilu\"</code> <p>You can disable preconditioning entirely by setting the preconditioner to <code>None</code>:</p> <pre><code>config = bores.Config(\n    timer=timer,\n    rock_fluid_tables=rock_fluid,\n    wells=wells,\n    pressure_preconditioner=None,    # No preconditioning\n    saturation_preconditioner=None,\n)\n</code></pre> <p>This is rarely a good idea for production runs, but can be useful for profiling to understand how much the preconditioner is helping.</p>"},{"location":"user-guide/simulation/schemes/","title":"Evolution Schemes","text":""},{"location":"user-guide/simulation/schemes/#overview","title":"Overview","text":"<p>An evolution scheme determines how the pressure and saturation equations are discretized and solved at each time step. The choice of scheme affects numerical stability, accuracy, computational cost, and the maximum time step size you can use. BORES supports three evolution schemes, each offering a different trade-off between these factors.</p> <p>In black-oil reservoir simulation, you are solving two coupled systems of equations: a pressure equation (derived from mass conservation and Darcy's law) and saturation transport equations (one for each mobile phase). These equations are coupled because pressure depends on fluid saturations (through compressibility and density) and saturations depend on pressure (through flow velocities). The evolution scheme defines how this coupling is handled at each time step.</p> <p>The scheme is set through the <code>scheme</code> parameter in the <code>Config</code>:</p> <pre><code>import bores\n\nconfig = bores.Config(\n    timer=timer,\n    rock_fluid_tables=rock_fluid,\n    wells=wells,\n    scheme=\"impes\",  # \"impes\", \"explicit\", or \"implicit\"\n)\n</code></pre>"},{"location":"user-guide/simulation/schemes/#impes-recommended-default","title":"IMPES (Recommended Default)","text":"<p>IMPES stands for **IM**plicit **P**ressure, **E**xplicit **S**aturation. It is the most widely used scheme in black-oil simulation and the recommended default in BORES.</p> <p>In IMPES, the pressure equation is solved implicitly (using a linear system solver) while the saturation equations are updated explicitly (using the pressure solution from the current step). This gives you the stability benefits of implicit pressure solving while keeping the saturation update simple and fast.</p> <pre><code>config = bores.Config(\n    timer=timer,\n    rock_fluid_tables=rock_fluid,\n    wells=wells,\n    scheme=\"impes\",\n)\n</code></pre> <p>The implicit pressure step assembles a sparse linear system \\(A \\cdot p = b\\) where \\(A\\) is the transmissibility matrix and \\(b\\) contains source terms (wells, boundary conditions) and accumulation terms. This system is solved using an iterative solver (BiCGSTAB by default) with a preconditioner (ILU by default). Because pressure is solved implicitly, there is no CFL stability limit on the pressure equation, which allows larger time steps.</p> <p>The explicit saturation step uses the pressure solution to compute phase velocities and then advances the saturations forward in time using a first-order upwind scheme. This step is fast (no linear system to solve) but is subject to a CFL stability condition that limits the maximum time step. If the time step is too large, the explicit saturation update can produce unphysical oscillations or negative saturations.</p> <p>IMPES is the best balance for most problems. It handles pressure diffusion (which is fast and long-range) implicitly for stability, while treating saturation transport (which is local and advective) explicitly for efficiency.</p> <p>When to Use IMPES</p> <p>IMPES is appropriate for the vast majority of black-oil simulations: primary depletion, waterflooding, gas injection, and miscible flooding. It is the default in BORES and in most commercial simulators. Only switch to another scheme if you encounter specific numerical issues that IMPES cannot handle.</p>"},{"location":"user-guide/simulation/schemes/#explicit","title":"Explicit","text":"<p>The fully explicit scheme treats both pressure and saturation explicitly. Both equations are advanced forward in time using the values from the previous time step, with no linear systems to solve.</p> <pre><code>config = bores.Config(\n    timer=timer,\n    rock_fluid_tables=rock_fluid,\n    wells=wells,\n    scheme=\"explicit\",\n)\n</code></pre> <p>The advantage of the explicit scheme is simplicity and low cost per time step. There are no sparse matrix assemblies, no linear system solves, and no preconditioners. Each step is essentially a series of element-wise array operations.</p> <p>The disadvantage is that the scheme is conditionally stable. Both the pressure and saturation CFL conditions must be satisfied, which often requires very small time steps. The pressure CFL condition is particularly restrictive because pressure diffuses rapidly across the grid. In practice, the explicit scheme often requires time steps 10 to 100 times smaller than IMPES to remain stable.</p> <p>The CFL thresholds can be tuned in the <code>Config</code>:</p> <pre><code>config = bores.Config(\n    timer=timer,\n    rock_fluid_tables=rock_fluid,\n    wells=wells,\n    scheme=\"explicit\",\n    pressure_cfl_threshold=0.9,     # Max pressure CFL number\n    saturation_cfl_threshold=0.6,   # Max saturation CFL number\n)\n</code></pre> <p>Lowering these thresholds increases stability at the cost of requiring even smaller time steps. Raising them improves performance but risks numerical instability.</p> <p>Explicit Stability</p> <p>The fully explicit scheme is useful for debugging, for very small models where the cost per step is negligible, or for educational purposes where you want to observe the CFL condition in action. For production simulations, IMPES is almost always a better choice because it allows much larger time steps while maintaining stability.</p>"},{"location":"user-guide/simulation/schemes/#implicit","title":"Implicit","text":"<p>The fully implicit scheme treats both pressure and saturation implicitly. Both equations are assembled into linear systems and solved using iterative solvers with preconditioners.</p> <pre><code>config = bores.Config(\n    timer=timer,\n    rock_fluid_tables=rock_fluid,\n    wells=wells,\n    scheme=\"implicit\",\n)\n</code></pre> <p>The fully implicit scheme is unconditionally stable, meaning there is no CFL limit on the time step size. You can take very large time steps without worrying about numerical oscillations or instabilities. This makes the implicit scheme attractive for problems where the explicit saturation CFL condition is very restrictive, such as fine-grid simulations, high-permeability contrasts, or simulations with strong capillary pressure effects.</p> <p>The cost of this stability is higher computational effort per time step. The implicit scheme must solve a larger linear system that couples pressure and saturation, and it typically requires Newton iterations to handle the nonlinearity. Each Newton iteration involves assembling and solving a Jacobian system, which is significantly more expensive than the simple explicit saturation update in IMPES.</p> <p>The implicit scheme is particularly useful when:</p> <ul> <li>Fine grids cause the IMPES saturation CFL to require impractically small time steps</li> <li>Strong capillary pressure creates fast local saturation changes</li> <li>High permeability contrasts (&gt;1000:1) cause stability issues with IMPES</li> <li>You want to take very large time steps and are willing to pay more per step</li> </ul> <p>You can control convergence behavior with the following <code>Config</code> parameters:</p> <pre><code>config = bores.Config(\n    timer=timer,\n    rock_fluid_tables=rock_fluid,\n    wells=wells,\n    scheme=\"implicit\",\n    pressure_convergence_tolerance=1e-6,    # Tighter for pressure\n    saturation_convergence_tolerance=1e-4,  # Relaxed for saturation\n    max_iterations=250,                      # Max solver iterations per step\n)\n</code></pre> <p>Implicit vs IMPES Cost</p> <p>A rough guideline: the implicit scheme costs 3 to 10 times more per time step than IMPES, but can use time steps 5 to 50 times larger. Whether implicit is faster overall depends on the specific problem. For most field-scale models with moderate grid resolution, IMPES wins. For fine-grid studies or problems with severe CFL restrictions, implicit can be faster.</p>"},{"location":"user-guide/simulation/schemes/#choosing-a-scheme","title":"Choosing a Scheme","text":"Feature IMPES Explicit Implicit Pressure solve Implicit Explicit Implicit Saturation solve Explicit Explicit Implicit Stability Conditionally stable (saturation CFL) Conditionally stable (both CFL) Unconditionally stable Cost per step Moderate Low High Max time step Moderate Small Large Best for Most problems Debugging, small models Fine grids, strong capillary Default Yes No No <p>For almost all reservoir simulation work, start with IMPES. If you encounter stability issues (oscillating saturations, frequent timestep rejections, negative saturations), try reducing the time step first. If that does not help, switch to the fully implicit scheme. The explicit scheme is primarily useful for educational purposes and very small, fast-running models.</p>"},{"location":"user-guide/simulation/schemes/#convergence-controls","title":"Convergence Controls","text":"<p>The <code>Config</code> provides several parameters that control how the solver behaves within each time step, regardless of scheme:</p> <pre><code>config = bores.Config(\n    timer=timer,\n    rock_fluid_tables=rock_fluid,\n    wells=wells,\n    scheme=\"impes\",\n\n    # Solver convergence\n    pressure_convergence_tolerance=1e-6,\n    saturation_convergence_tolerance=1e-4,\n    max_iterations=250,\n\n    # Saturation change limits (trigger timestep rejection if exceeded)\n    max_oil_saturation_change=0.5,\n    max_water_saturation_change=0.4,\n    max_gas_saturation_change=0.85,\n    max_pressure_change=100.0,         # psi per step\n\n    # CFL thresholds (explicit and IMPES saturation)\n    saturation_cfl_threshold=0.6,\n    pressure_cfl_threshold=0.9,\n\n    # Output control\n    output_frequency=1,                # Yield state every N steps\n    log_interval=5,                    # Log progress every N steps\n)\n</code></pre> <p>The <code>pressure_convergence_tolerance</code> controls when the iterative solver considers the pressure solution converged. A tighter tolerance (smaller number) gives more accurate pressure but requires more iterations. The default of <code>1e-6</code> is appropriate for most cases.</p> <p>The <code>saturation_convergence_tolerance</code> plays the same role for the implicit saturation solver. It can be more relaxed than the pressure tolerance because the saturation transport equation is typically better conditioned.</p> <p>The <code>max_iterations</code> parameter caps how many iterations the solver attempts before giving up. If the solver hits this limit, the time step is rejected and retried with a smaller step size. The default of 250 is generous; well-conditioned problems typically converge in 20 to 50 iterations.</p> <p>The saturation and pressure change limits (<code>max_oil_saturation_change</code>, <code>max_pressure_change</code>, etc.) are safety valves. If any cell's saturation or pressure changes by more than these limits in a single step, the step is rejected and retried with a smaller time step. This prevents large, potentially unphysical jumps in the solution. You can tighten these limits for more conservative behavior or relax them for faster simulations.</p>"},{"location":"user-guide/simulation/solvers/","title":"Solvers","text":""},{"location":"user-guide/simulation/solvers/#overview","title":"Overview","text":"<p>At each time step, the pressure equation (and in the implicit scheme, the saturation equation) is discretized into a sparse linear system \\(A \\cdot x = b\\), where \\(A\\) is a large, sparse matrix representing the transmissibilities between grid cells, \\(x\\) is the unknown (pressure or saturation), and \\(b\\) is the right-hand side containing source terms and accumulation. The solver is the algorithm that finds \\(x\\) given \\(A\\) and \\(b\\).</p> <p>BORES provides several iterative solvers from SciPy's sparse linear algebra library, plus a direct solver for small problems. You select the solver through the <code>pressure_solver</code> and <code>saturation_solver</code> parameters in the <code>Config</code>. The same solver types are available for both systems, but you can (and often should) use different solvers for pressure and saturation because they have different mathematical properties.</p> <pre><code>import bores\n\nconfig = bores.Config(\n    timer=timer,\n    rock_fluid_tables=rock_fluid,\n    wells=wells,\n    scheme=\"impes\",\n    pressure_solver=\"bicgstab\",      # Solver for pressure\n    saturation_solver=\"bicgstab\",    # Solver for saturation\n)\n</code></pre>"},{"location":"user-guide/simulation/solvers/#available-solvers","title":"Available Solvers","text":"Solver String Name Best For BiCGSTAB <code>\"bicgstab\"</code> General-purpose (default). Works well for non-symmetric systems. GMRES <code>\"gmres\"</code> Non-symmetric systems, especially with good preconditioners. LGMRES <code>\"lgmres\"</code> Like GMRES but with lower memory usage. Good for large systems. CG <code>\"cg\"</code> Symmetric positive definite systems only. Fastest when applicable. CGS <code>\"cgs\"</code> Non-symmetric systems. Sometimes faster than BiCGSTAB. TFQMR <code>\"tfqmr\"</code> Non-symmetric systems. Smooth convergence, good for stiff problems. Direct <code>\"direct\"</code> Small systems only. Exact solution (no iteration)."},{"location":"user-guide/simulation/solvers/#bicgstab-default","title":"BiCGSTAB (Default)","text":"<p>BiCGSTAB (Biconjugate Gradient Stabilized) is the default solver for both pressure and saturation. It works well for the non-symmetric matrices that arise in reservoir simulation (non-symmetry comes from upwinding in the saturation equation and from certain boundary conditions).</p> <pre><code>config = bores.Config(\n    timer=timer,\n    rock_fluid_tables=rock_fluid,\n    wells=wells,\n    pressure_solver=\"bicgstab\",\n    saturation_solver=\"bicgstab\",\n)\n</code></pre> <p>BiCGSTAB converges in a predictable number of iterations for well-conditioned systems and combines well with ILU or AMG preconditioners. It is a safe, reliable choice for most problems.</p>"},{"location":"user-guide/simulation/solvers/#gmres","title":"GMRES","text":"<p>GMRES (Generalized Minimal Residual) is an alternative that sometimes converges faster than BiCGSTAB, especially for highly non-symmetric systems. Its main disadvantage is memory usage: GMRES stores a history of all previous search directions, which grows linearly with the number of iterations. For very large systems (millions of unknowns), this memory cost can become significant.</p> <pre><code>config = bores.Config(\n    timer=timer,\n    rock_fluid_tables=rock_fluid,\n    wells=wells,\n    pressure_solver=\"gmres\",\n)\n</code></pre>"},{"location":"user-guide/simulation/solvers/#lgmres","title":"LGMRES","text":"<p>LGMRES is a variant of GMRES that uses a fixed-size memory window, making it more memory-efficient for large problems while retaining most of the convergence benefits of full GMRES.</p>"},{"location":"user-guide/simulation/solvers/#cg","title":"CG","text":"<p>CG (Conjugate Gradient) is the fastest solver for symmetric positive definite (SPD) matrices. The pressure matrix in single-phase flow is SPD, so CG is an excellent choice for pressure-only problems or depletion studies. However, in multiphase flow with upwinding or certain boundary conditions, the matrix may not be symmetric, causing CG to fail or diverge.</p> <pre><code># CG for pressure (works well for SPD pressure matrices)\nconfig = bores.Config(\n    timer=timer,\n    rock_fluid_tables=rock_fluid,\n    wells=wells,\n    pressure_solver=\"cg\",\n    saturation_solver=\"bicgstab\",  # Saturation matrix is not SPD\n)\n</code></pre> <p>CG Requires Symmetric Matrices</p> <p>Only use CG for the pressure solver, and only when you are confident the pressure matrix is symmetric positive definite. If the solver diverges or produces incorrect results, switch back to BiCGSTAB. The saturation transport matrix is almost never symmetric, so do not use CG for <code>saturation_solver</code>.</p>"},{"location":"user-guide/simulation/solvers/#direct-solver","title":"Direct Solver","text":"<p>The direct solver uses sparse LU factorization (via <code>spsolve</code>) to compute the exact solution. It requires no iteration and no convergence tolerance. The trade-off is that direct solvers have \\(O(N^{1.5})\\) to \\(O(N^2)\\) memory and time complexity for sparse matrices, making them impractical for large grids.</p> <pre><code># Direct solver for small models (&lt; 5000 cells)\nconfig = bores.Config(\n    timer=timer,\n    rock_fluid_tables=rock_fluid,\n    wells=wells,\n    pressure_solver=\"direct\",\n    saturation_solver=\"direct\",\n)\n</code></pre> <p>The direct solver is useful for small models (fewer than ~5,000 cells) where the overhead of iterative methods is not justified, for debugging (to verify that iterative solver issues are not causing errors), and as a reference solution to validate iterative solver accuracy.</p>"},{"location":"user-guide/simulation/solvers/#solver-chains","title":"Solver Chains","text":"<p>You can specify a list of solvers to try in sequence. If the first solver fails to converge, BORES automatically tries the next one. This provides a fallback mechanism for difficult problems.</p> <pre><code>config = bores.Config(\n    timer=timer,\n    rock_fluid_tables=rock_fluid,\n    wells=wells,\n    pressure_solver=[\"bicgstab\", \"gmres\", \"direct\"],\n    saturation_solver=[\"bicgstab\", \"tfqmr\"],\n)\n</code></pre> <p>In this example, BORES first tries BiCGSTAB for the pressure equation. If BiCGSTAB does not converge within <code>max_iterations</code>, it tries GMRES. If GMRES also fails, it falls back to the direct solver. This is particularly useful for simulations where the pressure matrix conditioning varies over time (e.g., when wells switch controls or when a gas front arrives at a producer).</p> <p>Solver chains add robustness at the cost of potentially longer solve times on difficult steps. For most simulations, a single solver (<code>\"bicgstab\"</code>) with a good preconditioner is sufficient.</p>"},{"location":"user-guide/simulation/solvers/#custom-solvers","title":"Custom Solvers","text":"<p>You can register custom solver functions using the <code>@solver_func</code> decorator. A custom solver must follow the SciPy solver interface:</p> <pre><code>from bores.diffusivity.base import solver_func\n\n@solver_func(name=\"my_custom_solver\")\ndef my_solver(A, b, x0=None, *, rtol=1e-6, atol=0.0, maxiter=None, M=None, callback=None):\n    # Your solver implementation here\n    # Must return the solution array x\n    ...\n\n# Then use it in Config\nconfig = bores.Config(\n    timer=timer,\n    rock_fluid_tables=rock_fluid,\n    wells=wells,\n    pressure_solver=\"my_custom_solver\",\n)\n</code></pre> <p>The <code>@solver_func</code> decorator registers your function in the global solver registry, making it available by name in the <code>Config</code>. You can list all registered solvers with <code>bores.diffusivity.base.list_solver_funcs()</code>.</p>"},{"location":"user-guide/simulation/solvers/#solver-tuning","title":"Solver Tuning","text":"<p>The key parameters that affect solver performance are:</p> <p><code>pressure_convergence_tolerance</code> (default: <code>1e-6</code>): The relative residual tolerance for the pressure solver. Tighter tolerances give more accurate pressure but require more iterations. For most simulations, <code>1e-6</code> is a good balance. If you notice pressure oscillations, try tightening to <code>1e-8</code>. If the solver is spending too many iterations, try relaxing to <code>1e-5</code>.</p> <p><code>saturation_convergence_tolerance</code> (default: <code>1e-4</code>): The tolerance for the saturation solver (implicit scheme only). Saturation transport is typically better conditioned than pressure, so a more relaxed tolerance is appropriate.</p> <p><code>max_iterations</code> (default: <code>250</code>): The maximum number of iterations before the solver gives up. Well-conditioned problems typically converge in 10 to 50 iterations. If you regularly hit the iteration limit, the problem is likely poorly conditioned and needs a better preconditioner rather than more iterations.</p> <pre><code>config = bores.Config(\n    timer=timer,\n    rock_fluid_tables=rock_fluid,\n    wells=wells,\n    pressure_solver=\"bicgstab\",\n    pressure_convergence_tolerance=1e-6,\n    max_iterations=250,\n)\n</code></pre> <p>Diagnosing Solver Issues</p> <p>If the solver consistently fails to converge:</p> <ol> <li>Try a stronger preconditioner (switch from <code>\"ilu\"</code> to <code>\"amg\"</code> or <code>\"cpr\"</code>)</li> <li>Switch to a different solver (<code>\"gmres\"</code> instead of <code>\"bicgstab\"</code>)</li> <li>Use 64-bit precision (<code>bores.use_64bit_precision()</code>) for better numerical conditioning</li> <li>Reduce the time step to produce a better-conditioned matrix</li> <li>Check your model for extreme property contrasts (permeability ratios &gt; 10,000:1)</li> </ol>"},{"location":"user-guide/simulation/timestep-control/","title":"Time Step Control","text":""},{"location":"user-guide/simulation/timestep-control/#overview","title":"Overview","text":"<p>Time step control determines how much simulated time the solver advances in each iteration. Choosing the right time step size is critical because steps that are too large cause numerical instability, oscillations, or outright divergence, while steps that are too small waste computational effort without improving accuracy.</p> <p>In explicit and IMPES schemes, time step size is constrained by the CFL (Courant-Friedrichs-Lewy) condition, which sets a physical limit on how far information can travel through the grid in a single step. If the time step allows a saturation or pressure front to cross more than one grid cell, the solution becomes unstable. Even in implicit schemes where unconditional stability is theoretically guaranteed, excessively large steps can cause the Newton solver to struggle or produce inaccurate solutions.</p> <p>BORES uses an adaptive time stepping system through the <code>Timer</code> class. Rather than requiring you to guess a fixed step size, the timer monitors CFL numbers, saturation changes, pressure changes, and solver performance to automatically grow the step size when conditions are smooth and shrink it when conditions become challenging. This adaptive approach typically uses 3 to 10 times fewer total steps than a fixed step size that is conservative enough to handle the worst case, while maintaining the same level of accuracy and stability.</p> <p>The adaptive system is particularly important in reservoir simulation because the physics changes dramatically during a run. Early time steps near wells and injection fronts require very small steps, while late-time depletion far from wells can use much larger steps. A fixed step size must accommodate the most demanding period, wasting effort during the easier periods.</p>"},{"location":"user-guide/simulation/timestep-control/#the-time-helper","title":"The <code>Time()</code> Helper","text":"<p>All timer parameters are specified in seconds, but thinking in seconds is inconvenient for reservoir simulation where durations range from hours to years. The <code>Time()</code> function converts human-readable time components into seconds:</p> <pre><code>import bores\n\n# Single component\none_day = bores.Time(days=1)           # 86400.0\nsix_hours = bores.Time(hours=6)        # 21600.0\nthree_years = bores.Time(years=3)      # ~94608000.0\n\n# Combined components\nmixed = bores.Time(days=1, hours=6)    # 108000.0\n</code></pre> <p><code>Time()</code> accepts any combination of <code>milliseconds</code>, <code>seconds</code>, <code>minutes</code>, <code>hours</code>, <code>days</code>, <code>weeks</code>, <code>months</code>, and <code>years</code>. Components are additive. One year is defined as 365.25 days (by default), and one month is one-twelfth of a year (approximately 30.4 days). These are engineering approximations, not calendar-accurate durations, and they are standard conventions in reservoir simulation.</p> <p>You can use <code>Time()</code> anywhere a duration in seconds is expected, including all <code>Timer</code> parameters and simulation analysis functions.</p>"},{"location":"user-guide/simulation/timestep-control/#configuring-the-timer","title":"Configuring the Timer","text":"<p>The <code>Timer</code> class controls all aspects of time stepping. At minimum, you must specify four parameters: the initial step size, the maximum and minimum allowed step sizes, and the total simulation time.</p> <pre><code>import bores\n\ntimer = bores.Timer(\n    initial_step_size=bores.Time(days=1),\n    max_step_size=bores.Time(days=10),\n    min_step_size=bores.Time(hours=1),\n    simulation_time=bores.Time(years=3),\n)\n</code></pre> <p>The initial step size is the starting point for the adaptive algorithm. It should be conservative enough that the first few steps succeed without rejection. A good starting point is 0.5 to 2 days for most problems. If you start too large, the timer will reject the first few steps and reduce the size automatically, but each rejection wastes a solver call.</p> <p>The maximum step size caps how large the timer can grow. Even when conditions are very smooth, you generally do not want steps larger than 10 to 30 days because the linearization errors in PVT property updates accumulate. The minimum step size sets a floor below which the timer will not go. If the timer hits this floor repeatedly, it raises a <code>TimingError</code> after <code>max_rejects</code> consecutive rejections (default 10), indicating that the problem may be poorly configured.</p>"},{"location":"user-guide/simulation/timestep-control/#full-timer-parameters","title":"Full Timer Parameters","text":"Parameter Default Description <code>initial_step_size</code> (required) Starting step size in seconds <code>max_step_size</code> (required) Upper bound on step size <code>min_step_size</code> (required) Lower bound on step size <code>simulation_time</code> (required) Total simulation duration <code>max_cfl_number</code> 0.9 Default CFL limit for adaptive adjustments <code>backoff_factor</code> 0.5 Multiplier when a step is rejected <code>aggressive_backoff_factor</code> 0.25 Multiplier for severe rejections <code>ramp_up_factor</code> <code>None</code> Optional growth multiplier after cooldown <code>max_steps</code> <code>None</code> Optional hard limit on total step count <code>max_rejects</code> 10 Maximum consecutive rejections before error <code>max_growth_per_step</code> 1.3 Maximum multiplicative growth per step (30%) <code>growth_cooldown_steps</code> 5 Successful steps required before ramp-up <code>cfl_safety_margin</code> 0.85 Safety factor applied to CFL targets <code>step_size_smoothing</code> 0.2 EMA smoothing factor (0 = none, 1 = max) <code>metrics_history_size</code> 10 Number of recent steps tracked for trends <code>failure_memory_window</code> 5 Number of recent failures remembered"},{"location":"user-guide/simulation/timestep-control/#adaptive-time-stepping","title":"Adaptive Time Stepping","text":"<p>The adaptive algorithm works by monitoring multiple criteria at each step and adjusting the next step size accordingly. The process has two phases: acceptance (where the step succeeded and we decide whether to grow) and rejection (where the step failed and we must shrink).</p>"},{"location":"user-guide/simulation/timestep-control/#step-acceptance","title":"Step Acceptance","text":"<p>When a step succeeds, the timer evaluates several adjustment factors:</p> <ol> <li> <p>CFL-based adjustment: If the CFL number is well below the threshold (utilization &lt; 70%), the timer allows growth. If the CFL is above 90% of the threshold, growth is suppressed. The <code>cfl_safety_margin</code> (default 0.85) targets a CFL below the absolute limit.</p> </li> <li> <p>Saturation change adjustment: The timer compares the maximum saturation change against the allowed limit (from <code>Config</code>). Low utilization (&lt; 30%) allows up to 30% growth, while high utilization (&gt; 95%) triggers a 15% reduction even though the step was accepted.</p> </li> <li> <p>Pressure change adjustment: Same logic as saturation, comparing actual pressure change against the allowed limit.</p> </li> <li> <p>Newton iteration adjustment: For implicit schemes, if the solver needed more than 10 iterations, the step size is reduced by 30%. If it converged in fewer than 4 iterations after several stable steps, a 20% growth is allowed.</p> </li> <li> <p>Performance trend analysis: The timer tracks the last 10 steps and detects concerning trends. If CFL numbers are consistently high or increasing, or if Newton iterations are consistently above 8, a performance factor below 1.0 further dampens growth.</p> </li> </ol> <p>All factors are multiplied together, then the result is capped by <code>max_growth_per_step</code> (default 1.3, meaning no more than 30% growth per step). The final value is smoothed through an exponential moving average controlled by <code>step_size_smoothing</code>, which prevents erratic oscillations in step size.</p>"},{"location":"user-guide/simulation/timestep-control/#step-rejection","title":"Step Rejection","text":"<p>When a step fails (CFL exceeded, saturation change too large, solver diverged), the timer uses intelligent backoff based on the specific failure cause:</p> Failure Cause Overshoot Ratio Backoff Factor Mild CFL violation (1.0 to 1.5x) &lt; 1.5 0.6 to 0.9 (proportional) Moderate CFL violation (1.5 to 2.0x) 1.5 to 2.0 0.5 Severe CFL violation (&gt; 2.0x) &gt; 2.0 0.3 Moderate saturation overshoot &lt; 2.0 0.5 to proportional Large saturation overshoot 2.0 to 3.0 0.4 Severe saturation overshoot &gt; 3.0 0.25 Newton solver struggling (&gt; 15 iterations) n/a 0.5 Newton solver failing (&gt; 20 iterations) n/a 0.3 <p>When multiple criteria are violated simultaneously, the timer uses the most conservative (smallest) backoff factor. If no specific failure information is available, it falls back to <code>backoff_factor</code> (0.5) or <code>aggressive_backoff_factor</code> (0.25).</p> <p>The timer also remembers recently failed step sizes and avoids proposing sizes near those values. If a proposed size is within 15% of a recently failed size, it is reduced by an additional 20%.</p>"},{"location":"user-guide/simulation/timestep-control/#constant-step-size-mode","title":"Constant Step Size Mode","text":"<p>If you set <code>initial_step_size</code>, <code>max_step_size</code>, and <code>min_step_size</code> to the same value, the timer automatically enters constant step size mode. In this mode, all adaptive logic is bypassed and every step uses the specified size:</p> <pre><code># Fixed 1-day steps\ntimer = bores.Timer(\n    initial_step_size=bores.Time(days=1),\n    max_step_size=bores.Time(days=1),\n    min_step_size=bores.Time(days=1),\n    simulation_time=bores.Time(years=1),\n)\n</code></pre> <p>Constant step size is rarely optimal, but it can be useful for debugging (to isolate whether time stepping is contributing to an issue) or for comparing against analytical solutions at specific time points.</p>"},{"location":"user-guide/simulation/timestep-control/#saturation-and-pressure-change-limits","title":"Saturation and Pressure Change Limits","text":"<p>The <code>Config</code> class provides per-phase saturation change limits and a pressure change limit that the timer uses to judge whether a step is acceptable. These limits are the primary mechanism for controlling accuracy in IMPES and explicit schemes.</p> <pre><code>config = bores.Config(\n    timer=timer,\n    rock_fluid_tables=rock_fluid,\n    wells=wells,\n    max_oil_saturation_change=0.5,      # Default\n    max_water_saturation_change=0.4,    # Default\n    max_gas_saturation_change=0.85,     # Default\n    max_pressure_change=100.0,          # Default, psi\n)\n</code></pre> <p>Each limit specifies the maximum absolute change allowed in a single time step. If any cell in the grid exceeds the limit, the step is rejected and the timer reduces the step size.</p> <p>These defaults are deliberately permissive to allow large time steps in the common case. Most reservoir simulations involve gradual, smooth changes where large steps are perfectly accurate. The defaults are designed so that the adaptive timer can take big steps during quiet periods and only restrict step size when the physics genuinely demands it. You should feel free to leave them at their defaults for most work and only tighten them if you observe specific issues.</p> <p>The gas saturation limit (0.85) is the most permissive because gas saturation fronts are inherently sharp and restricting them too aggressively forces very small time steps without proportional accuracy improvement. The water limit (0.4) is more conservative because water fronts tend to be smoother and more amenable to accurate large-step tracking. The oil limit (0.5) sits in the middle. The pressure change limit of 100 psi works well for typical reservoir pressures of 1,000 to 5,000 psi, representing roughly a 2 to 10% relative change.</p> <p>If you want tighter accuracy (for example, for validation studies or detailed front tracking), you can reduce these limits. If you want faster runs for screening purposes, you can relax them further. The simulation remains stable either way because the timer enforces the limits strictly; looser limits simply allow larger steps.</p>"},{"location":"user-guide/simulation/timestep-control/#adjusting-limits-by-scenario","title":"Adjusting Limits by Scenario","text":"Scenario Saturation Limits Pressure Limit Standard waterflood Defaults are fine 100 psi Gas injection Reduce water to 0.3 75 psi Low-pressure reservoir (&lt; 1000 psi) Defaults are fine 25 to 50 psi High-pressure reservoir (&gt; 5000 psi) Defaults are fine 150 to 200 psi Tight convergence / validation Reduce all by 30 to 50% 50 psi Fast screening runs Relax all by 50% or more 200 to 300 psi <p>Tighter limits improve accuracy but require more time steps. Looser limits improve performance at the cost of some accuracy in tracking sharp fronts. In most cases, the defaults provide a good balance between speed and accuracy. If you observe pressure oscillations or material balance errors, tighten the pressure limit first. If saturation fronts show non-physical overshoots, tighten the relevant saturation limit.</p>"},{"location":"user-guide/simulation/timestep-control/#cfl-thresholds","title":"CFL Thresholds","text":"<p>The CFL (Courant-Friedrichs-Lewy) number measures how far a wave front moves relative to the grid cell size in a single time step. A CFL number above 1.0 means the front crosses more than one cell per step, which causes instability in explicit methods.</p> <p>The <code>Config</code> provides separate CFL thresholds for pressure and saturation:</p> <pre><code>config = bores.Config(\n    timer=timer,\n    rock_fluid_tables=rock_fluid,\n    wells=wells,\n    saturation_cfl_threshold=0.6,   # Default\n    pressure_cfl_threshold=0.9,     # Default\n)\n</code></pre> <p>The saturation CFL threshold (0.6) is more conservative than the pressure threshold (0.9) because saturation transport is hyperbolic and more sensitive to CFL violations. The pressure equation is parabolic (or elliptic in incompressible limits) and tolerates higher CFL numbers.</p> <p>These thresholds interact with the timer's <code>max_cfl_number</code> (default 0.9) and <code>cfl_safety_margin</code> (default 0.85). The timer targets a CFL of <code>threshold * safety_margin</code>, so with defaults the effective target for saturation is approximately 0.51 and for pressure approximately 0.77.</p> <p>CFL and Scheme Selection</p> <p>CFL thresholds only affect the explicit and IMPES schemes. In the IMPES scheme, only the saturation CFL threshold applies (pressure is implicit). In the fully implicit scheme, CFL is not a stability constraint, but the saturation and pressure change limits still apply as accuracy controls.</p>"},{"location":"user-guide/simulation/timestep-control/#ramp-up-factor","title":"Ramp-Up Factor","text":"<p>The <code>ramp_up_factor</code> provides an additional multiplicative growth on top of the adaptive adjustments. It only activates after <code>growth_cooldown_steps</code> consecutive successful steps and only when all monitoring criteria (CFL, saturation change, pressure change) are below 70% of their limits.</p> <pre><code>timer = bores.Timer(\n    initial_step_size=bores.Time(days=0.5),\n    max_step_size=bores.Time(days=15),\n    min_step_size=bores.Time(hours=1),\n    simulation_time=bores.Time(years=5),\n    ramp_up_factor=1.2,              # 20% extra growth\n    growth_cooldown_steps=5,          # After 5 stable steps\n)\n</code></pre> <p>The ramp-up factor is useful when you want the simulation to reach large step sizes quickly after an initial transient period (for example, after well startup or injection rate changes). Without it, the timer grows conservatively based solely on the monitoring criteria. With a ramp-up factor of 1.2, the timer can grow up to 56% per step (1.3 max growth * 1.2 ramp-up), though this is still capped by <code>max_step_size</code>.</p> <p>Setting <code>ramp_up_factor</code> to <code>None</code> (the default) disables this feature entirely, relying solely on the adaptive criteria for growth.</p>"},{"location":"user-guide/simulation/timestep-control/#step-size-smoothing","title":"Step Size Smoothing","text":"<p>The <code>step_size_smoothing</code> parameter controls an exponential moving average (EMA) filter applied to the proposed step size. Without smoothing, the step size can oscillate between large and small values when the adaptive criteria give conflicting signals.</p> <p>The smoothing factor ranges from 0.0 (no smoothing, the proposed step is used directly) to 1.0 (maximum smoothing, the step size barely changes). The default of 0.2 provides light smoothing that prevents erratic oscillations while still allowing the step size to respond quickly to changing conditions.</p> <pre><code># No smoothing (responsive but potentially oscillatory)\ntimer = bores.Timer(\n    ...,\n    step_size_smoothing=0.0,\n)\n\n# Heavy smoothing (very stable but slow to adapt)\ntimer = bores.Timer(\n    ...,\n    step_size_smoothing=0.5,\n)\n</code></pre> <p>The EMA formula is: <code>ema = smoothing * ema_previous + (1 - smoothing) * proposed</code>. With the default of 0.2, each new step size is 80% the proposed value and 20% the previous EMA, giving the timer a short memory that damps fluctuations without introducing significant lag.</p>"},{"location":"user-guide/simulation/timestep-control/#timer-state-and-checkpointing","title":"Timer State and Checkpointing","text":"<p>The <code>Timer</code> tracks its complete internal state, including step count, elapsed time, recent performance metrics, and failed step size history. You can save and restore this state for simulation checkpointing:</p> <pre><code># Save timer state\ntimer_state = timer.dump_state()\n\n# Later, restore from saved state\nrestored_timer = bores.Timer.load_state(timer_state)\n</code></pre> <p>The <code>dump_state()</code> method returns a <code>TimerState</code> dictionary containing all configuration parameters and runtime state. The <code>load_state()</code> class method reconstructs a timer with the exact same state, allowing a simulation to resume from a checkpoint without losing the adaptive algorithm's learned behavior.</p> <p>This is particularly valuable for long-running simulations where you want to resume after a system interruption without restarting from the beginning. The restored timer will propose the same step size and use the same performance history as the original.</p>"},{"location":"user-guide/simulation/timestep-control/#recommended-configurations","title":"Recommended Configurations","text":""},{"location":"user-guide/simulation/timestep-control/#standard-waterflood","title":"Standard Waterflood","text":"<pre><code>timer = bores.Timer(\n    initial_step_size=bores.Time(days=1),\n    max_step_size=bores.Time(days=10),\n    min_step_size=bores.Time(hours=1),\n    simulation_time=bores.Time(years=3),\n)\n</code></pre> <p>Waterfloods have moderate dynamics with a fairly smooth saturation front. The default parameters work well for most waterflood scenarios.</p>"},{"location":"user-guide/simulation/timestep-control/#gas-injection","title":"Gas Injection","text":"<pre><code>timer = bores.Timer(\n    initial_step_size=bores.Time(days=0.5),\n    max_step_size=bores.Time(days=5),\n    min_step_size=bores.Time(hours=0.5),\n    simulation_time=bores.Time(years=3),\n)\n</code></pre> <p>Gas injection creates sharper fronts and higher velocities. Smaller initial and maximum step sizes prevent early rejections. The smaller minimum step size accommodates the sharp gas front arrival.</p>"},{"location":"user-guide/simulation/timestep-control/#primary-depletion","title":"Primary Depletion","text":"<pre><code>timer = bores.Timer(\n    initial_step_size=bores.Time(days=2),\n    max_step_size=bores.Time(days=30),\n    min_step_size=bores.Time(days=1),\n    simulation_time=bores.Time(years=10),\n)\n</code></pre> <p>Depletion has very smooth, gradual pressure decline with no injection fronts. Larger step sizes are appropriate because the physics changes slowly and uniformly across the grid.</p>"},{"location":"user-guide/simulation/timestep-control/#well-startup-rate-change","title":"Well Startup / Rate Change","text":"<pre><code>timer = bores.Timer(\n    initial_step_size=bores.Time(hours=6),\n    max_step_size=bores.Time(days=10),\n    min_step_size=bores.Time(minutes=30),\n    simulation_time=bores.Time(years=5),\n    ramp_up_factor=1.15,\n    growth_cooldown_steps=3,\n)\n</code></pre> <p>Well events cause rapid near-wellbore transients that need very small initial steps. The ramp-up factor with a short cooldown allows the timer to grow quickly once the transient passes.</p>"},{"location":"user-guide/simulation/timestep-control/#troubleshooting","title":"Troubleshooting","text":"<p>Maximum Rejections Exceeded</p> <p>If you see <code>TimingError: Maximum number of consecutive time step rejections exceeded</code>, the timer hit the minimum step size and still could not produce an acceptable step. Common causes:</p> <ul> <li>The minimum step size is too large for the problem dynamics. Try reducing it.</li> <li>Permeability contrast is extreme. Try a stronger preconditioner (AMG or CPR).</li> <li>Well rates are too high for the grid resolution. Reduce the rate or refine the grid near the well.</li> <li>Initial conditions are inconsistent (saturations do not sum to 1.0, pressure below bubble point without free gas).</li> </ul> <p>Step Size Stuck at Minimum</p> <p>If the timer repeatedly reports step sizes at or near the minimum, the adaptive algorithm is struggling. This usually indicates that the physics demands small steps throughout, not just during a transient. Consider relaxing the saturation or pressure change limits, using the implicit scheme (which allows larger steps), or coarsening the grid.</p>"},{"location":"user-guide/wells/basics/","title":"Well Basics","text":""},{"location":"user-guide/wells/basics/#overview","title":"Overview","text":"<p>Wells are the primary interface between the reservoir and the surface. They are the points where fluids enter or leave the simulation domain, and they drive the pressure and saturation changes that form the core of any reservoir simulation study. In BORES, wells are defined by their physical properties (location, radius, skin factor), the fluids they handle, and the control strategy that governs how they operate.</p> <p>BORES provides two well types: <code>ProductionWell</code> and <code>InjectionWell</code>. Production wells remove fluids from the reservoir (oil, water, and gas flow from the formation into the wellbore). Injection wells add fluids to the reservoir (water or gas is pumped from the surface into the formation). The direction of flow is determined by the pressure difference between the wellbore and the surrounding reservoir rock: fluid flows from high pressure to low pressure.</p> <p>Rather than constructing well objects directly, BORES provides factory functions (<code>bores.production_well()</code> and <code>bores.injection_well()</code>) that handle validation and default parameter computation. These factories wrap the <code>ProductionWell</code> and <code>InjectionWell</code> classes and ensure that all required fields are properly initialized.</p>"},{"location":"user-guide/wells/basics/#production-wells","title":"Production Wells","text":"<p>A production well removes fluids from the reservoir. You define it by specifying a name, the grid cells it perforates, the wellbore radius, the produced fluids, and the control strategy.</p> <pre><code>import bores\n\nproducer = bores.production_well(\n    well_name=\"PROD-1\",\n    perforating_intervals=[((10, 10, 0), (10, 10, 4))],\n    radius=0.25,  # ft\n    produced_fluids=[\n        bores.ProducedFluid(\n            name=\"Oil\",\n            phase=bores.FluidPhase.OIL,\n            specific_gravity=0.85,\n            molecular_weight=200.0,\n        ),\n        bores.ProducedFluid(\n            name=\"Water\",\n            phase=bores.FluidPhase.WATER,\n            specific_gravity=1.02,\n            molecular_weight=18.015,\n        ),\n        bores.ProducedFluid(\n            name=\"Gas\",\n            phase=bores.FluidPhase.GAS,\n            specific_gravity=0.65,\n            molecular_weight=16.04,\n        ),\n    ],\n    control=bores.PrimaryPhaseRateControl(\n        primary_phase=bores.FluidPhase.OIL,\n        primary_control=bores.AdaptiveBHPRateControl(\n            target_rate=-500.0,\n            target_phase=\"oil\",\n            bhp_limit=1000.0,\n        ),\n        secondary_clamp=bores.ProductionClamp(),\n    ),\n    skin_factor=2.0,\n)\n</code></pre> <p>The <code>produced_fluids</code> parameter takes a list of <code>ProducedFluid</code> objects, one for each phase that can flow into the wellbore. You must provide the fluid name, phase, specific gravity (relative to water for liquids, relative to air for gas), and molecular weight. The specific gravity and molecular weight are used by PVT correlations to compute formation volume factors, viscosities, and densities during the simulation.</p> <p>The <code>control</code> parameter specifies how the well operates. See Well Controls for details on the available control strategies.</p>"},{"location":"user-guide/wells/basics/#produced-fluids","title":"Produced Fluids","text":"<p>A <code>ProducedFluid</code> describes the properties of a fluid being produced by a well. It inherits from <code>WellFluid</code> and requires four parameters:</p> Parameter Units Description <code>name</code> string Human-readable name (e.g., \"Oil\", \"Water\", \"Gas\") <code>phase</code> <code>FluidPhase</code> Phase designation: <code>OIL</code>, <code>WATER</code>, or <code>GAS</code> <code>specific_gravity</code> dimensionless Gravity relative to reference (water for liquids, air for gas) <code>molecular_weight</code> g/mol Molecular weight of the fluid <p>In most simulations, you define all three produced fluids (oil, water, gas) for each production well, even if you expect only oil to flow initially. As the simulation progresses, water and gas may break through, and the well needs to know the properties of all phases that could be produced.</p>"},{"location":"user-guide/wells/basics/#injection-wells","title":"Injection Wells","text":"<p>An injection well adds fluids to the reservoir. You define it similarly to a production well, but instead of produced fluids, you specify a single <code>InjectedFluid</code> that describes the fluid being injected.</p> <pre><code>import bores\n\ninjector = bores.injection_well(\n    well_name=\"INJ-1\",\n    perforating_intervals=[((0, 0, 0), (0, 0, 4))],\n    radius=0.25,  # ft\n    injected_fluid=bores.InjectedFluid(\n        name=\"Water\",\n        phase=bores.FluidPhase.WATER,\n        specific_gravity=1.0,\n        molecular_weight=18.015,\n    ),\n    control=bores.ConstantRateControl(\n        target_rate=800.0,  # Positive = injection\n        bhp_limit=5000.0,   # Max injection pressure\n    ),\n)\n</code></pre> <p>Notice the sign convention: positive rates mean injection (fluid entering the reservoir), and negative rates mean production (fluid leaving the reservoir). This convention is consistent throughout the BORES library.</p>"},{"location":"user-guide/wells/basics/#injected-fluids","title":"Injected Fluids","text":"<p>An <code>InjectedFluid</code> describes the properties of the fluid being injected. It extends <code>WellFluid</code> with additional parameters for miscible flooding and property overrides:</p> Parameter Default Description <code>name</code> required Human-readable name (e.g., \"Water\", \"CO2\") <code>phase</code> required Must be <code>WATER</code> or <code>GAS</code> (oil injection is not supported) <code>specific_gravity</code> required Gravity relative to reference <code>molecular_weight</code> required Molecular weight (g/mol) <code>salinity</code> <code>None</code> Water salinity in ppm NaCl (for water injection) <code>is_miscible</code> <code>False</code> Whether this fluid is miscible with oil <code>todd_longstaff_omega</code> <code>0.67</code> Todd-Longstaff mixing parameter (0 to 1) <code>minimum_miscibility_pressure</code> <code>None</code> MMP in psi (required if miscible) <code>density</code> <code>None</code> Override density in lbm/ft3 (bypasses correlations) <code>viscosity</code> <code>None</code> Override viscosity in cP (bypasses correlations) <p>See Well Fluids for detailed guidance on configuring injected fluids, especially for CO2 and miscible gas injection.</p>"},{"location":"user-guide/wells/basics/#perforating-intervals","title":"Perforating Intervals","text":"<p>Perforating intervals define which grid cells the well penetrates. Each interval is a tuple of two coordinates: the start and end of the perforation in grid index space (i, j, k). A well can have multiple intervals, and each interval can span multiple cells.</p> <pre><code># Single interval: well penetrates cells (10, 10, 0) through (10, 10, 4)\n# This is a vertical well completing through all 5 layers at column (10, 10)\nperforating_intervals = [((10, 10, 0), (10, 10, 4))]\n\n# Multiple intervals: well is perforated in two separate zones\nperforating_intervals = [\n    ((10, 10, 0), (10, 10, 1)),  # Upper zone: layers 0-1\n    ((10, 10, 3), (10, 10, 4)),  # Lower zone: layers 3-4\n]\n</code></pre> <p>The coordinates use zero-based indexing, matching the NumPy array convention. The start coordinate must be within the grid, and the end coordinate must also be within the grid. BORES validates this when you build the simulation configuration.</p> <p>For a vertical well in a grid with shape <code>(nx, ny, nz)</code>, the x and y indices select the column position and the z range selects which layers are perforated. For horizontal wells, the x or y range spans multiple cells while z remains constant.</p>"},{"location":"user-guide/wells/basics/#well-orientation","title":"Well Orientation","text":"<p>BORES automatically detects the well orientation from the perforating intervals by finding the dominant axis of the perforation trajectory. A well that spans more cells in the z-direction is classified as vertical (Z-oriented), one that spans more in x is X-oriented, and so on. The orientation affects how the Peaceman well index is calculated.</p> <p>You can also set the orientation explicitly:</p> <pre><code>producer = bores.production_well(\n    well_name=\"HORIZ-1\",\n    perforating_intervals=[((5, 10, 3), (15, 10, 3))],\n    radius=0.25,\n    orientation=bores.Orientation.X,  # Horizontal well in x-direction\n    produced_fluids=[...],\n    control=control,\n)\n</code></pre>"},{"location":"user-guide/wells/basics/#well-index-and-the-peaceman-equation","title":"Well Index and the Peaceman Equation","text":"<p>The well index \\(WI\\) (also called the productivity index or connection transmissibility factor) controls how much fluid flows between the wellbore and the grid cell. It is computed using the Peaceman equation, which accounts for the wellbore radius, the effective drainage radius, the cell permeability, and the skin factor.</p> \\[WI = \\frac{k_{eff} \\cdot h}{\\ln(r_e / r_w) + s}\\] <p>where \\(k_{eff}\\) is the effective permeability in the plane perpendicular to the well, \\(h\\) is the cell thickness in the well direction, \\(r_e\\) is the effective drainage radius (computed from the cell dimensions and permeability anisotropy using the Peaceman formula), \\(r_w\\) is the wellbore radius, and \\(s\\) is the skin factor.</p> <p>BORES computes the well index automatically from the grid properties and well parameters. You do not need to calculate it manually. The well index determines how the flow rate relates to the pressure drawdown:</p> \\[q = WI \\cdot \\frac{k_{r\\alpha}}{\\mu_\\alpha B_\\alpha} \\cdot (P_{res} - P_{wf})\\] <p>where \\(P_{res}\\) is the reservoir pressure, \\(P_{wf}\\) is the flowing bottom-hole pressure, and the middle term is the phase mobility divided by the formation volume factor.</p>"},{"location":"user-guide/wells/basics/#skin-factor","title":"Skin Factor","text":"<p>The skin factor \\(s\\) is a dimensionless number that accounts for additional pressure drop (or reduction) near the wellbore that is not captured by the grid-scale permeability. Positive skin indicates formation damage (reduced near-wellbore permeability due to drilling mud invasion, completion damage, or scale buildup), which reduces productivity. Negative skin indicates stimulation (fracturing or acidizing that improves near-wellbore flow), which increases productivity.</p> Skin Factor Interpretation \\(s &lt; 0\\) Stimulated well (fractured or acidized) \\(s = 0\\) Undamaged well (ideal completion) \\(s = 1\\) to \\(5\\) Moderate damage \\(s &gt; 5\\) Severe damage <pre><code># Fractured well (stimulated)\nfractured = bores.production_well(\n    well_name=\"FRAC-1\",\n    perforating_intervals=[((10, 10, 0), (10, 10, 4))],\n    radius=0.25,\n    skin_factor=-2.0,  # Stimulated\n    produced_fluids=[...],\n    control=control,\n)\n\n# Damaged well\ndamaged = bores.production_well(\n    well_name=\"DAMAGED-1\",\n    perforating_intervals=[((10, 10, 0), (10, 10, 4))],\n    radius=0.25,\n    skin_factor=5.0,  # Damaged\n    produced_fluids=[...],\n    control=control,\n)\n</code></pre> <p>In history matching, the skin factor is often one of the first parameters adjusted because it directly affects well productivity without changing the regional rock properties. If a well produces less than expected from the grid permeability alone, a positive skin factor can account for the discrepancy.</p>"},{"location":"user-guide/wells/basics/#combining-wells","title":"Combining Wells","text":"<p>After creating individual wells, combine them into a <code>Wells</code> container using <code>bores.wells_()</code>:</p> <pre><code>import bores\n\nwells = bores.wells_(\n    producers=[producer],\n    injectors=[injector],\n)\n</code></pre> <p>The <code>Wells</code> object is then passed to the <code>Config</code> for simulation:</p> <pre><code>config = bores.Config(\n    timer=timer,\n    wells=wells,\n    rock_fluid_tables=rock_fluid,\n    scheme=\"impes\",\n)\n</code></pre> <p>You can include any number of producers and injectors. Wells are identified by their <code>name</code> attribute, which should be unique within each category (producers and injectors).</p>"},{"location":"user-guide/wells/basics/#shutting-in-and-opening-wells","title":"Shutting In and Opening Wells","text":"<p>During a simulation, you can shut in or open wells programmatically. A shut-in well has zero flow rate and no pressure interaction with the reservoir.</p> <pre><code># Shut in the well\nproducer.shut_in()\nassert producer.is_shut_in  # True\nassert not producer.is_open  # True\n\n# Re-open the well\nproducer.open()\nassert producer.is_open  # True\n</code></pre> <p>For time-dependent well operations (shutting in at a specific time, changing controls mid-simulation), use Well Schedules.</p>"},{"location":"user-guide/wells/basics/#duplicating-wells","title":"Duplicating Wells","text":"<p>You can create copies of a well with modified properties using the <code>duplicate()</code> method. This is useful for creating well patterns where multiple wells share the same configuration but differ in location or name.</p> <pre><code># Create a second producer at a different location\nprod_2 = producer.duplicate(\n    name=\"PROD-2\",\n    perforating_intervals=[((15, 15, 0), (15, 15, 4))],\n)\n</code></pre> <p>The <code>duplicate()</code> method uses <code>attrs.evolve()</code> internally, so it creates a shallow copy with the specified fields overridden. Any fields not listed in the keyword arguments retain their values from the original well.</p> <p>Well Naming Convention</p> <p>Use descriptive, unique names for your wells. Common conventions include \"PROD-1\", \"INJ-1\" for basic studies, or field-standard naming like \"A-01\", \"B-02\" for field models. The well name is used in logging, schedules, and post-processing, so clear naming saves debugging time.</p>"},{"location":"user-guide/wells/controls/","title":"Well Controls","text":""},{"location":"user-guide/wells/controls/#overview","title":"Overview","text":"<p>Well controls define the operating strategy for each well: how the simulator determines the flow rate and bottom-hole pressure at every timestep. The choice of control strategy has a major impact on simulation behavior because it determines the boundary condition at each well location.</p> <p>In real field operations, wells are typically controlled by one of two modes: constant rate (the operator sets a target production or injection rate, and the well delivers that rate as long as it physically can) or constant pressure (the operator sets a bottom-hole pressure, and the well produces or injects whatever rate the reservoir can deliver at that drawdown). Most production wells start under rate control and switch to pressure control when the reservoir can no longer sustain the target rate. BORES models this with the <code>AdaptiveBHPRateControl</code>, which automatically switches between rate and pressure modes.</p> <p>For production wells in three-phase simulation, a single-phase control is rarely sufficient because oil, water, and gas all flow simultaneously. The standard approach is to control the rate of one \"primary\" phase (usually oil) and let the other phases produce at whatever rate corresponds to the resulting bottom-hole pressure. BORES provides <code>PrimaryPhaseRateControl</code> for this purpose, and <code>MultiPhaseRateControl</code> for cases where you need separate controls for each phase.</p>"},{"location":"user-guide/wells/controls/#sign-convention","title":"Sign Convention","text":"<p>Throughout BORES, flow rates follow a consistent sign convention:</p> <ul> <li>Positive rates = injection (fluid entering the reservoir)</li> <li>Negative rates = production (fluid leaving the reservoir)</li> </ul> <p>This convention applies to all control types, all phase rates, and all flow rate outputs. When you specify <code>target_rate=-500.0</code>, you are requesting 500 STB/day of production. When you specify <code>target_rate=800.0</code>, you are requesting 800 STB/day (or SCF/day for gas) of injection.</p>"},{"location":"user-guide/wells/controls/#bhpcontrol","title":"BHPControl","text":"<p>The simplest control strategy: fix the bottom-hole pressure and let the flow rate be determined by Darcy's law. The rate depends on the pressure difference between the reservoir and the wellbore, the well index, and the phase mobility.</p> <pre><code>import bores\n\ncontrol = bores.BHPControl(\n    bhp=1500.0,  # psi\n)\n</code></pre> <p>At each timestep, the flow rate is computed as:</p> \\[q = WI \\cdot \\frac{k_{r\\alpha}}{\\mu_\\alpha B_\\alpha} \\cdot (P_{res} - P_{wf})\\] <p>If \\(P_{res} &gt; P_{wf}\\), the rate is negative (production). If \\(P_{res} &lt; P_{wf}\\), the rate is positive (injection). BHP control is most commonly used for injection wells where you want to maintain a constant injection pressure, or for production wells on artificial lift where the BHP is determined by the lift equipment.</p> Parameter Default Description <code>bhp</code> required Bottom-hole pressure in psi (must be positive) <code>target_phase</code> <code>None</code> If set, this control only applies to the specified phase <code>clamp</code> <code>None</code> Optional rate clamp to prevent backflow <p>BHP Control for Production</p> <p>When using BHP control for production, the production rate depends entirely on the reservoir pressure. As the reservoir depletes, the rate naturally declines. If reservoir pressure drops below the specified BHP, the well will stop producing (or even start injecting if no clamp is set). Always pair BHP production controls with a <code>ProductionClamp()</code> to prevent unintended injection.</p>"},{"location":"user-guide/wells/controls/#constantratecontrol","title":"ConstantRateControl","text":"<p>Maintains a target flow rate regardless of reservoir conditions, as long as a minimum BHP constraint is satisfied.</p> <pre><code>import bores\n\n# Production at 500 STB/day with 1000 psi minimum BHP\ncontrol = bores.ConstantRateControl(\n    target_rate=-500.0,    # STB/day (negative = production)\n    bhp_limit=1000.0,      # psi (minimum BHP for producers)\n)\n\n# Injection at 800 STB/day with 5000 psi maximum BHP\ncontrol = bores.ConstantRateControl(\n    target_rate=800.0,     # STB/day (positive = injection)\n    bhp_limit=5000.0,      # psi (maximum BHP for injectors)\n)\n</code></pre> <p>The <code>bhp_limit</code> has different meanings depending on the flow direction: for production wells, it is the minimum allowable BHP (the well cannot produce if the required BHP to achieve the target rate drops below this limit); for injection wells, it is the maximum allowable BHP (the well cannot inject if the required BHP exceeds this limit, which could indicate fracture risk).</p> Parameter Default Description <code>target_rate</code> required Target rate in STB/day or SCF/day (positive = injection, negative = production) <code>bhp_limit</code> <code>None</code> Minimum BHP for production, maximum BHP for injection (psi) <code>target_phase</code> <code>None</code> If set, this control only applies to the specified phase <code>clamp</code> <code>None</code> Optional rate clamp to prevent backflow"},{"location":"user-guide/wells/controls/#adaptivebhpratecontrol","title":"AdaptiveBHPRateControl","text":"<p>The most commonly used control for production wells. It operates at a constant target rate as long as the BHP stays above the limit, then automatically switches to BHP control when the rate is no longer achievable. This mimics the real behavior of production wells as reservoir pressure declines.</p> <pre><code>import bores\n\ncontrol = bores.AdaptiveBHPRateControl(\n    target_rate=-500.0,    # STB/day (production)\n    bhp_limit=1000.0,      # psi\n    target_phase=\"oil\",    # Only controls oil phase rate\n)\n</code></pre> <p>The adaptive behavior works as follows:</p> <ol> <li>At each timestep, the simulator computes the BHP required to deliver the target rate.</li> <li>If the required BHP is above the <code>bhp_limit</code>, the well operates in rate mode: it delivers the full target rate.</li> <li>If the required BHP would fall below the <code>bhp_limit</code>, the well switches to BHP mode: it produces at the BHP limit, and the rate declines below target.</li> </ol> <p>This is the industry-standard approach for modeling depletion-drive reservoirs where production rate is maintained as long as possible, then allowed to decline as pressure support diminishes.</p> Parameter Default Description <code>target_rate</code> required Target rate in STB/day or SCF/day <code>bhp_limit</code> required Switching pressure in psi <code>target_phase</code> <code>None</code> Phase this control applies to <code>clamp</code> <code>None</code> Optional rate clamp"},{"location":"user-guide/wells/controls/#primaryphaseratecontrol","title":"PrimaryPhaseRateControl","text":"<p>The recommended control for production wells in three-phase simulation. It fixes the rate of one \"primary\" phase (typically oil) and computes the BHP required to deliver that rate. All other phases (water and gas) then produce at whatever their natural Darcy rates are at the resulting BHP.</p> <p>This is the standard approach in reservoir simulation because it reflects how production wells actually operate: the operator controls oil production rate (or sometimes gas rate for gas wells), and water and gas are produced as byproducts. The water cut and gas-oil ratio are determined by the reservoir conditions, not by the well control.</p> <pre><code>import bores\n\ncontrol = bores.PrimaryPhaseRateControl(\n    primary_phase=bores.FluidPhase.OIL,\n    primary_control=bores.AdaptiveBHPRateControl(\n        target_rate=-500.0,\n        target_phase=\"oil\",\n        bhp_limit=1000.0,\n    ),\n    secondary_clamp=bores.ProductionClamp(),\n)\n</code></pre> <p>The <code>primary_phase</code> parameter specifies which phase drives the BHP calculation. The <code>primary_control</code> is any single-phase control (<code>ConstantRateControl</code> or <code>AdaptiveBHPRateControl</code>) applied to that phase. The <code>secondary_clamp</code> is an optional safety clamp applied to the non-primary phases to prevent unphysical behavior (like injection of water through a production well when reservoir pressure exceeds wellbore pressure in the water zone).</p> Parameter Default Description <code>primary_phase</code> required Phase whose rate is fixed (<code>OIL</code>, <code>GAS</code>, or <code>WATER</code>) <code>primary_control</code> required Rate control for the primary phase <code>secondary_clamp</code> <code>None</code> Optional clamp for non-primary phases"},{"location":"user-guide/wells/controls/#how-it-works","title":"How It Works","text":"<p>At each timestep, for each grid cell the well perforates:</p> <ol> <li>The primary phase control computes the BHP required to deliver the target oil rate (for example).</li> <li>That BHP is used for all phases. Water and gas rates are computed from Darcy's law at that BHP.</li> <li>If a <code>secondary_clamp</code> is set (recommended), any secondary phase that would flow in the wrong direction (e.g., water injection through a production well) is clamped to zero.</li> </ol> <p>This approach ensures physical consistency: all phases share the same wellbore pressure, and the total production rate is the sum of the individual phase rates at that pressure.</p> <p>Always Use PrimaryPhaseRateControl for Producers</p> <p>For production wells in three-phase simulations, always use <code>PrimaryPhaseRateControl</code> rather than a bare <code>AdaptiveBHPRateControl</code>. A bare <code>AdaptiveBHPRateControl</code> applies the same target rate to ALL phases independently, which is physically incorrect. With <code>PrimaryPhaseRateControl</code>, you control only the phase you care about and let the others flow naturally.</p>"},{"location":"user-guide/wells/controls/#multiphaseratecontrol","title":"MultiPhaseRateControl","text":"<p>For cases where you need explicit, independent control over each phase. This provides separate control objects for oil, gas, and water, each with their own target rates and BHP limits.</p> <pre><code>import bores\n\ncontrol = bores.MultiPhaseRateControl(\n    oil_control=bores.AdaptiveBHPRateControl(\n        target_rate=-500.0,\n        target_phase=\"oil\",\n        bhp_limit=1000.0,\n    ),\n    gas_control=bores.AdaptiveBHPRateControl(\n        target_rate=-200000.0,\n        target_phase=\"gas\",\n        bhp_limit=800.0,\n    ),\n    water_control=bores.BHPControl(\n        bhp=1000.0,\n        target_phase=\"water\",\n    ),\n)\n</code></pre> <p>Each phase operates under its own control independently. This is less physically realistic than <code>PrimaryPhaseRateControl</code> (because in reality, all phases share the same wellbore pressure), but it is useful for certain history-matching scenarios where you want to prescribe known production rates for each phase separately.</p> Parameter Default Description <code>oil_control</code> <code>None</code> Control for oil phase (set to <code>None</code> to exclude oil) <code>gas_control</code> <code>None</code> Control for gas phase (set to <code>None</code> to exclude gas) <code>water_control</code> <code>None</code> Control for water phase (set to <code>None</code> to exclude water) <p>When to Use MultiPhaseRateControl</p> <p>Use <code>MultiPhaseRateControl</code> when you have measured production data for each phase separately and want to replay those rates in a history-matching study. For predictive simulations, <code>PrimaryPhaseRateControl</code> is more physically meaningful because it lets the reservoir determine the water cut and GOR based on mobility and relative permeability.</p>"},{"location":"user-guide/wells/controls/#rate-clamps","title":"Rate Clamps","text":"<p>Rate clamps are safety mechanisms that prevent unphysical flow. They check the computed flow rate or BHP and clamp it if a condition is met.</p>"},{"location":"user-guide/wells/controls/#productionclamp","title":"ProductionClamp","text":"<p>Prevents injection through a production well. If the computed rate is positive (injection), it clamps the rate to zero. If the computed BHP exceeds reservoir pressure (which would drive injection), it clamps BHP to reservoir pressure.</p> <pre><code>import bores\n\nclamp = bores.ProductionClamp()\n\n# Use with any control\ncontrol = bores.BHPControl(bhp=1500.0, clamp=clamp)\n</code></pre>"},{"location":"user-guide/wells/controls/#injectionclamp","title":"InjectionClamp","text":"<p>Prevents production through an injection well. If the computed rate is negative (production), it clamps the rate to zero.</p> <pre><code>clamp = bores.InjectionClamp()\n\ncontrol = bores.ConstantRateControl(\n    target_rate=800.0,\n    bhp_limit=5000.0,\n    clamp=clamp,\n)\n</code></pre> <p>Always Use Clamps</p> <p>Rate clamps are strongly recommended for all wells. Without them, a production well can start injecting if reservoir pressure drops below the wellbore pressure, and an injection well can start producing if wellbore pressure drops below reservoir pressure. These scenarios are physically possible but rarely intended, and they can cause numerical instability.</p>"},{"location":"user-guide/wells/controls/#choosing-the-right-control","title":"Choosing the Right Control","text":"Scenario Recommended Control Production well (general case) <code>PrimaryPhaseRateControl</code> with <code>AdaptiveBHPRateControl</code> Gas production well <code>PrimaryPhaseRateControl</code> with <code>primary_phase=GAS</code> Water injection <code>ConstantRateControl</code> or <code>AdaptiveBHPRateControl</code> Gas injection <code>ConstantRateControl</code> or <code>AdaptiveBHPRateControl</code> Constant-pressure production <code>BHPControl</code> with <code>ProductionClamp</code> History matching (known rates per phase) <code>MultiPhaseRateControl</code> Artificial lift <code>BHPControl</code> (BHP set by lift equipment)"},{"location":"user-guide/wells/fluids/","title":"Well Fluids","text":""},{"location":"user-guide/wells/fluids/#overview","title":"Overview","text":"<p>Every well in BORES needs to know the properties of the fluids it handles. Production wells define <code>ProducedFluid</code> objects for each phase (oil, water, gas) that may flow into the wellbore. Injection wells define a single <code>InjectedFluid</code> object describing the fluid being pumped into the reservoir. These fluid objects provide the specific gravity and molecular weight needed to compute PVT properties (formation volume factors, viscosities, densities) at wellbore conditions.</p> <p>The distinction between produced and injected fluids matters because of how PVT properties are used. For production wells, the simulator looks up oil, water, and gas properties from the reservoir model's PVT grids. For injection wells, the fluid properties may differ significantly from the in-situ reservoir fluids, particularly for gas injection (where the injected gas may be CO2 or nitrogen with very different properties from the reservoir's solution gas).</p>"},{"location":"user-guide/wells/fluids/#producedfluid","title":"ProducedFluid","text":"<p>A <code>ProducedFluid</code> describes a fluid phase that flows from the reservoir into a production well. It is a simple data class with four required fields:</p> <pre><code>import bores\n\noil = bores.ProducedFluid(\n    name=\"Oil\",\n    phase=bores.FluidPhase.OIL,\n    specific_gravity=0.85,    # Oil gravity relative to water (~35 API)\n    molecular_weight=200.0,   # Average molecular weight (g/mol)\n)\n\nwater = bores.ProducedFluid(\n    name=\"Formation Water\",\n    phase=bores.FluidPhase.WATER,\n    specific_gravity=1.02,    # Slightly saline\n    molecular_weight=18.015,  # H2O\n)\n\ngas = bores.ProducedFluid(\n    name=\"Associated Gas\",\n    phase=bores.FluidPhase.GAS,\n    specific_gravity=0.65,    # Light hydrocarbon gas\n    molecular_weight=16.04,   # Close to methane\n)\n</code></pre> <p>For most simulations, the produced fluid properties should match the reservoir fluid properties you used when building the reservoir model. The specific gravity of oil should match the <code>oil_specific_gravity_grid</code> values, and the gas specific gravity should match the <code>gas_specific_gravity</code> parameter.</p> <p>A production well typically includes all three phases, even if you expect only one phase to be produced initially. During a waterflood, for example, water will eventually break through and the well needs water fluid properties to compute the water production rate correctly.</p>"},{"location":"user-guide/wells/fluids/#injectedfluid","title":"InjectedFluid","text":"<p>An <code>InjectedFluid</code> describes the fluid being pumped into an injection well. It extends the base <code>WellFluid</code> class with additional parameters for miscible flooding, salinity, and property overrides.</p>"},{"location":"user-guide/wells/fluids/#water-injection","title":"Water Injection","text":"<p>For water injection, the <code>InjectedFluid</code> is straightforward:</p> <pre><code>import bores\n\nwater_fluid = bores.InjectedFluid(\n    name=\"Injection Water\",\n    phase=bores.FluidPhase.WATER,\n    specific_gravity=1.0,     # Fresh water\n    molecular_weight=18.015,\n)\n</code></pre> <p>If you are injecting saline water (brine), specify the salinity:</p> <pre><code>brine_fluid = bores.InjectedFluid(\n    name=\"Seawater\",\n    phase=bores.FluidPhase.WATER,\n    specific_gravity=1.03,\n    molecular_weight=18.015,\n    salinity=35000.0,  # ppm NaCl\n)\n</code></pre> <p>The salinity affects water density and viscosity calculations. Seawater typically has about 35,000 ppm total dissolved solids, while formation brines can range from 10,000 to over 200,000 ppm.</p>"},{"location":"user-guide/wells/fluids/#hydrocarbon-gas-injection","title":"Hydrocarbon Gas Injection","text":"<p>For injecting hydrocarbon gas (methane, natural gas, or enriched gas), use standard gas properties:</p> <pre><code>import bores\n\nnatural_gas = bores.InjectedFluid(\n    name=\"Natural Gas\",\n    phase=bores.FluidPhase.GAS,\n    specific_gravity=0.70,\n    molecular_weight=20.0,\n)\n</code></pre> <p>The gas properties (compressibility factor, density, viscosity) are computed from correlations using the specific gravity and molecular weight. These correlations work well for hydrocarbon gases because they were developed from large datasets of natural gas measurements.</p>"},{"location":"user-guide/wells/fluids/#co2-injection","title":"CO2 Injection","text":"<p>CO2 injection requires special attention because CO2 is a non-ideal gas whose properties deviate significantly from the standard gas correlations used for hydrocarbon gases. At typical reservoir conditions (above 1100 psi and 90 degrees F), CO2 exists as a supercritical fluid with a density 5 to 10 times higher than what the gas correlations predict, and a viscosity 3 to 5 times higher.</p> <p>BORES provides density and viscosity override parameters on <code>InjectedFluid</code> to handle this:</p> <pre><code>import bores\n\nco2_fluid = bores.InjectedFluid(\n    name=\"CO2\",\n    phase=bores.FluidPhase.GAS,\n    specific_gravity=1.52,      # CO2 gravity relative to air\n    molecular_weight=44.01,     # CO2 molecular weight\n    density=35.0,               # lbm/ft3 - from EOS or lab data\n    viscosity=0.05,             # cP - from EOS or lab data\n)\n</code></pre> <p>When <code>density</code> or <code>viscosity</code> is set, BORES uses those values directly instead of computing them from correlations. This is critical for CO2 because the standard gas correlations (Lee-Gonzalez-Eakin for viscosity, Hall-Yarborough for Z-factor) were developed for hydrocarbon gases and produce grossly inaccurate results for CO2 at reservoir conditions.</p> <p>The density and viscosity values should come from equation-of-state calculations (using a tool like CoolProp, NIST REFPROP, or commercial PVT software) or from laboratory measurements at your specific reservoir temperature and pressure. As a rough guide for CO2 at typical reservoir conditions:</p> Condition Density (lbm/ft3) Viscosity (cP) 2000 psi, 150 degrees F ~30 ~0.04 3000 psi, 150 degrees F ~38 ~0.05 4000 psi, 200 degrees F ~35 ~0.06 5000 psi, 200 degrees F ~40 ~0.07 <p>Always Override CO2 Properties</p> <p>If you are simulating CO2 injection without setting <code>density</code> and <code>viscosity</code> on the <code>InjectedFluid</code>, the simulator will use standard gas correlations that can underpredict CO2 density by a factor of 5 or more. This leads to incorrect gravity segregation, incorrect injection volumes, and unreliable recovery predictions. Always provide measured or EOS-computed properties for CO2.</p>"},{"location":"user-guide/wells/fluids/#miscible-gas-injection","title":"Miscible Gas Injection","text":"<p>For miscible flooding (CO2 or enriched gas that mixes with oil above the minimum miscibility pressure), set <code>is_miscible=True</code> and provide the MMP and Todd-Longstaff mixing parameter:</p> <pre><code>import bores\n\nco2_miscible = bores.InjectedFluid(\n    name=\"CO2\",\n    phase=bores.FluidPhase.GAS,\n    specific_gravity=1.52,\n    molecular_weight=44.01,\n    density=35.0,\n    viscosity=0.05,\n    is_miscible=True,\n    minimum_miscibility_pressure=1200.0,  # psi\n    todd_longstaff_omega=0.67,            # Mixing parameter (0-1)\n    miscibility_transition_width=500.0,   # Pressure range for smooth transition\n)\n</code></pre> <p>The <code>minimum_miscibility_pressure</code> (MMP) is the pressure above which the injected gas develops first-contact or multi-contact miscibility with the reservoir oil. Below the MMP, the gas displaces oil immiscibly with high residual oil saturation. Above the MMP, the displacement approaches piston-like efficiency with near-zero residual oil.</p> <p>The <code>todd_longstaff_omega</code> parameter controls the degree of mixing between solvent and oil at the sub-grid scale. A value of 1.0 means complete mixing (the solvent and oil are fully miscible within each grid cell), while 0.0 means no mixing (the fluids remain segregated). The default value of 0.67 is the most commonly used in industry. See Miscible Flooding for detailed physics.</p> <p>The <code>miscibility_transition_width</code> controls the pressure range over which miscibility transitions from immiscible to fully miscible. BORES uses a smooth hyperbolic tangent transition centered at the MMP, with the width controlling how abrupt the transition is. A width of 0 gives a sharp step change; values of 300-500 psi give a gradual transition that is more numerically stable.</p> <p>Miscibility Requirements</p> <p>When <code>is_miscible=True</code>, the following conditions must be met:</p> <ul> <li>The phase must be <code>GAS</code> (miscible water injection is not supported)</li> <li><code>minimum_miscibility_pressure</code> must be provided</li> <li><code>todd_longstaff_omega</code> must be provided (defaults to 0.67 if not specified)</li> </ul>"},{"location":"user-guide/wells/fluids/#nitrogen-injection","title":"Nitrogen Injection","text":"<p>Nitrogen is sometimes used for pressure maintenance or immiscible gas injection. Like CO2, its properties differ from hydrocarbon gas, but the deviation is less severe:</p> <pre><code>import bores\n\nn2_fluid = bores.InjectedFluid(\n    name=\"Nitrogen\",\n    phase=bores.FluidPhase.GAS,\n    specific_gravity=0.967,     # N2 gravity relative to air\n    molecular_weight=28.013,    # N2 molecular weight\n)\n</code></pre> <p>For nitrogen, the standard gas correlations are reasonably accurate because nitrogen is closer to ideal gas behavior than CO2. However, for high-pressure applications (above 5000 psi), you may want to provide density and viscosity overrides from EOS calculations for improved accuracy.</p>"},{"location":"user-guide/wells/fluids/#common-fluid-property-values","title":"Common Fluid Property Values","text":"Fluid Phase Specific Gravity Molecular Weight Light oil (35 API) OIL 0.85 180-220 Medium oil (25 API) OIL 0.90 250-350 Heavy oil (15 API) OIL 0.97 400-600 Fresh water WATER 1.00 18.015 Seawater WATER 1.03 18.015 Formation brine WATER 1.05-1.15 18.015 Methane GAS 0.553 16.04 Natural gas (typical) GAS 0.60-0.75 17-25 CO2 GAS 1.52 44.01 Nitrogen GAS 0.967 28.013 H2S GAS 1.18 34.08"},{"location":"user-guide/wells/patterns/","title":"Well Patterns","text":""},{"location":"user-guide/wells/patterns/#overview","title":"Overview","text":"<p>Well placement is one of the most important decisions in field development planning. The arrangement of production and injection wells (the \"well pattern\") controls sweep efficiency, injection support, and ultimately recovery factor. BORES does not have a dedicated pattern generation function, but the <code>duplicate()</code> method and the factory functions make it straightforward to build common patterns programmatically.</p> <p>This page demonstrates how to construct industry-standard well patterns and provides guidance on choosing the right pattern for different reservoir geometries and recovery mechanisms.</p>"},{"location":"user-guide/wells/patterns/#five-spot-pattern","title":"Five-Spot Pattern","text":"<p>The five-spot is the most common waterflood pattern. It places four producers at the corners of a square with one injector at the center. In a repeated five-spot, each injector is shared by four producers, giving a 1:1 injection-to-production well ratio.</p> <pre><code>import bores\n\ngrid_shape = (30, 30, 5)\n\n# Define common produced fluids\nproduced_fluids = [\n    bores.ProducedFluid(name=\"Oil\", phase=bores.FluidPhase.OIL, specific_gravity=0.85, molecular_weight=200.0),\n    bores.ProducedFluid(name=\"Water\", phase=bores.FluidPhase.WATER, specific_gravity=1.0, molecular_weight=18.015),\n    bores.ProducedFluid(name=\"Gas\", phase=bores.FluidPhase.GAS, specific_gravity=0.65, molecular_weight=16.04),\n]\n\n# Production control\nprod_control = bores.PrimaryPhaseRateControl(\n    primary_phase=bores.FluidPhase.OIL,\n    primary_control=bores.AdaptiveBHPRateControl(\n        target_rate=-300.0,\n        target_phase=\"oil\",\n        bhp_limit=1000.0,\n    ),\n    secondary_clamp=bores.ProductionClamp(),\n)\n\n# Four corner producers\ncorners = [(5, 5), (5, 25), (25, 5), (25, 25)]\nproducers = []\nfor i, (x, y) in enumerate(corners):\n    producers.append(bores.production_well(\n        well_name=f\"PROD-{i+1}\",\n        perforating_intervals=[((x, y, 0), (x, y, 4))],\n        radius=0.25,\n        produced_fluids=produced_fluids,\n        control=prod_control,\n    ))\n\n# Center injector\ninjector = bores.injection_well(\n    well_name=\"INJ-1\",\n    perforating_intervals=[((15, 15, 0), (15, 15, 4))],\n    radius=0.25,\n    injected_fluid=bores.InjectedFluid(\n        name=\"Water\",\n        phase=bores.FluidPhase.WATER,\n        specific_gravity=1.0,\n        molecular_weight=18.015,\n    ),\n    control=bores.ConstantRateControl(\n        target_rate=1200.0,\n        bhp_limit=5000.0,\n    ),\n)\n\nwells = bores.wells_(producers=producers, injectors=[injector])\n</code></pre> <p>The five-spot pattern provides uniform sweep in homogeneous, isotropic reservoirs. In anisotropic reservoirs (where permeability differs between x and y directions), the pattern may need to be elongated in the low-permeability direction to maintain symmetric sweep.</p>"},{"location":"user-guide/wells/patterns/#line-drive-pattern","title":"Line Drive Pattern","text":"<p>A line drive places producers and injectors in alternating parallel rows. This pattern is simpler to operate than a five-spot and works well for elongated reservoirs or when directional permeability favors flow in one direction.</p> <pre><code>import bores\n\ngrid_shape = (40, 20, 5)\n\n# Row of producers at x=30\nproducers = []\nfor j in range(2, 18, 4):  # y = 2, 6, 10, 14\n    producers.append(bores.production_well(\n        well_name=f\"PROD-{len(producers)+1}\",\n        perforating_intervals=[((30, j, 0), (30, j, 4))],\n        radius=0.25,\n        produced_fluids=produced_fluids,  # From earlier\n        control=prod_control,\n    ))\n\n# Row of injectors at x=10\ninjectors = []\nfor j in range(2, 18, 4):\n    injectors.append(bores.injection_well(\n        well_name=f\"INJ-{len(injectors)+1}\",\n        perforating_intervals=[((10, j, 0), (10, j, 4))],\n        radius=0.25,\n        injected_fluid=bores.InjectedFluid(\n            name=\"Water\",\n            phase=bores.FluidPhase.WATER,\n            specific_gravity=1.0,\n            molecular_weight=18.015,\n        ),\n        control=bores.ConstantRateControl(target_rate=600.0, bhp_limit=5000.0),\n    ))\n\nwells = bores.wells_(producers=producers, injectors=injectors)\n</code></pre>"},{"location":"user-guide/wells/patterns/#peripheral-flood","title":"Peripheral Flood","text":"<p>A peripheral flood places injectors around the edges of the reservoir and producers in the interior. This pattern is common for maintaining pressure support from the periphery, mimicking natural aquifer drive.</p> <pre><code>import bores\n\ngrid_shape = (30, 30, 5)\n\n# Edge injectors\nedge_positions = [\n    (0, 15), (15, 0), (29, 15), (15, 29),  # Mid-edge\n    (0, 0), (0, 29), (29, 0), (29, 29),     # Corners\n]\ninjectors = []\nfor i, (x, y) in enumerate(edge_positions):\n    injectors.append(bores.injection_well(\n        well_name=f\"INJ-{i+1}\",\n        perforating_intervals=[((x, y, 0), (x, y, 4))],\n        radius=0.25,\n        injected_fluid=bores.InjectedFluid(\n            name=\"Water\", phase=bores.FluidPhase.WATER,\n            specific_gravity=1.0, molecular_weight=18.015,\n        ),\n        control=bores.ConstantRateControl(target_rate=400.0, bhp_limit=5000.0),\n    ))\n\n# Interior producers\ninterior_positions = [(10, 10), (10, 20), (20, 10), (20, 20), (15, 15)]\nproducers = []\nfor i, (x, y) in enumerate(interior_positions):\n    producers.append(bores.production_well(\n        well_name=f\"PROD-{i+1}\",\n        perforating_intervals=[((x, y, 0), (x, y, 4))],\n        radius=0.25,\n        produced_fluids=produced_fluids,\n        control=prod_control,\n    ))\n\nwells = bores.wells_(producers=producers, injectors=injectors)\n</code></pre>"},{"location":"user-guide/wells/patterns/#using-duplicate-for-patterns","title":"Using duplicate() for Patterns","text":"<p>The <code>duplicate()</code> method makes it easy to create well arrays from a template:</p> <pre><code>import bores\n\n# Define a template producer\ntemplate = bores.production_well(\n    well_name=\"template\",\n    perforating_intervals=[((0, 0, 0), (0, 0, 4))],\n    radius=0.25,\n    produced_fluids=produced_fluids,\n    control=prod_control,\n    skin_factor=2.0,\n)\n\n# Create a grid of producers\nproducers = []\nfor ix in range(5, 26, 10):\n    for iy in range(5, 26, 10):\n        producers.append(template.duplicate(\n            name=f\"PROD-{ix}-{iy}\",\n            perforating_intervals=[((ix, iy, 0), (ix, iy, 4))],\n        ))\n</code></pre> <p>All duplicated wells share the same control, skin factor, radius, and fluid properties as the template. Only the name and location differ.</p>"},{"location":"user-guide/wells/patterns/#choosing-a-pattern","title":"Choosing a Pattern","text":"Pattern Best For Typical Recovery (waterflood) Five-spot Homogeneous, isotropic reservoirs 30-45% Line drive Anisotropic reservoirs, elongated structures 25-40% Peripheral flood Edge-water drive, maintaining pressure 30-50% Single well (depletion) Primary recovery, testing 10-25% <p>The pattern choice depends on the reservoir geometry, permeability anisotropy, fluid properties (viscosity ratio), and economic constraints (number of wells). For initial studies, the five-spot is a robust default. For history matching or field-specific work, use the actual well locations from the field data.</p> <p>Visualize Well Locations</p> <p>After building your wells, visualize their locations on the grid using <code>bores.plotly3d.DataVisualizer</code> to verify they are in the correct positions. Well placement errors (off-by-one in grid indices, wells outside the grid) are among the most common setup mistakes and are instantly visible in a 3D plot.</p>"},{"location":"user-guide/wells/schedules/","title":"Well Schedules","text":""},{"location":"user-guide/wells/schedules/#overview","title":"Overview","text":"<p>Real reservoir operations change over time. Wells are drilled and brought on-stream at different dates, production rates are adjusted based on facility constraints, injectors are converted from producers after waterflood initiation, and wells are shut in for workovers or when they reach economic limits. BORES models these time-dependent changes through the well scheduling system.</p> <p>The scheduling system is built on two primitives: predicates (conditions that determine when an event fires) and actions (modifications that are applied to the well when the event fires). These are combined into <code>WellEvent</code> objects, collected into <code>WellSchedule</code> containers, and then organized by well name in <code>WellSchedules</code>. The simulator checks the schedule at every timestep and applies any events whose predicates evaluate to true.</p> <p>This event-driven approach is more flexible than a simple time-step table because predicates can depend on simulation state (pressure, saturation, production rates), not just time. This lets you model conditional operations like \"shut in the producer when water cut exceeds 95%\" or \"increase injection rate when reservoir pressure drops below 2500 psi.\"</p>"},{"location":"user-guide/wells/schedules/#wellevent-predicate-action","title":"WellEvent: Predicate + Action","text":"<p>A <code>WellEvent</code> combines a predicate (when to trigger) with an action (what to do). At each timestep, the simulator calls the predicate with the well and the current model state. If the predicate returns <code>True</code>, the action is executed.</p> <pre><code>import bores\n\nevent = bores.WellEvent(\n    predicate=bores.time_predicate(time_step=50),\n    action=bores.update_well(\n        control=bores.PrimaryPhaseRateControl(\n            primary_phase=bores.FluidPhase.OIL,\n            primary_control=bores.AdaptiveBHPRateControl(\n                target_rate=-200.0,\n                target_phase=\"oil\",\n                bhp_limit=800.0,\n            ),\n            secondary_clamp=bores.ProductionClamp(),\n        ),\n    ),\n)\n</code></pre> <p>This event triggers at timestep 50 and reduces the oil production target from whatever it was before to 200 STB/day.</p>"},{"location":"user-guide/wells/schedules/#built-in-predicates","title":"Built-in Predicates","text":""},{"location":"user-guide/wells/schedules/#time_predicate","title":"time_predicate","text":"<p>The most common predicate triggers at a specific timestep or simulation time:</p> <pre><code>import bores\n\n# Trigger at timestep 100\npred = bores.time_predicate(time_step=100)\n\n# Trigger at simulation time 365.0 days\npred = bores.time_predicate(time=bores.Time(days=365.0))\n</code></pre> <p>You can specify either <code>time_step</code> (integer, zero-based timestep counter) or <code>time</code> (float, simulation time in seconds). If the simulation time exceeds the specified value during a timestep, the predicate fires.</p>"},{"location":"user-guide/wells/schedules/#custom-predicates","title":"Custom Predicates","text":"<p>You can write any function that accepts a well and a model state and returns a boolean. Register it with the <code>@event_predicate</code> decorator so it can be serialized:</p> <pre><code>import bores\n\n@bores.event_predicate\ndef high_water_cut(well, state):\n    \"\"\"Trigger when water cut exceeds 90%.\"\"\"\n    water_rate = abs(state.well_results.get(well.name, {}).get(\"water_rate\", 0.0))\n    oil_rate = abs(state.well_results.get(well.name, {}).get(\"oil_rate\", 1e-10))\n    water_cut = water_rate / (water_rate + oil_rate)\n    return water_cut &gt; 0.90\n\n@bores.event_predicate\ndef low_pressure(well, state):\n    \"\"\"Trigger when average pressure drops below 2000 psi.\"\"\"\n    avg_pressure = state.pressure_grid.mean()\n    return avg_pressure &lt; 2000.0\n</code></pre> <p>Registered predicates are serializable, meaning they can be saved and loaded as part of a <code>Config</code>. This is important for reproducibility.</p>"},{"location":"user-guide/wells/schedules/#built-in-actions","title":"Built-in Actions","text":""},{"location":"user-guide/wells/schedules/#update_well","title":"update_well","text":"<p>The <code>update_well</code> function creates an action that modifies well properties. You can change the control, skin factor, active status, or fluid properties:</p> <pre><code>import bores\n\n# Change control strategy\nchange_rate = bores.update_well(\n    control=bores.PrimaryPhaseRateControl(\n        primary_phase=bores.FluidPhase.OIL,\n        primary_control=bores.AdaptiveBHPRateControl(\n            target_rate=-100.0,\n            target_phase=\"oil\",\n            bhp_limit=500.0,\n        ),\n        secondary_clamp=bores.ProductionClamp(),\n    ),\n)\n\n# Shut in the well\nshut_in_well = bores.update_well(is_active=False)\n\n# Re-open the well\nopen_well = bores.update_well(is_active=True)\n\n# Change skin factor (after workover)\nworkover_done = bores.update_well(skin_factor=-1.0)\n\n# Change injected fluid\nswitch_fluid = bores.update_well(\n    injected_fluid=bores.InjectedFluid(\n        name=\"CO2\",\n        phase=bores.FluidPhase.GAS,\n        specific_gravity=1.52,\n        molecular_weight=44.01,\n        density=35.0,\n        viscosity=0.05,\n    ),\n)\n</code></pre> <p>You can pass any combination of parameters. Only the specified parameters are updated; all others remain unchanged.</p>"},{"location":"user-guide/wells/schedules/#custom-actions","title":"Custom Actions","text":"<p>Like predicates, you can write custom action functions and register them:</p> <pre><code>import bores\n\n@bores.event_action\ndef reduce_rate_by_half(well, state):\n    \"\"\"Reduce the well's target rate by 50%.\"\"\"\n    current_control = well.control\n    if hasattr(current_control, 'primary_control'):\n        current_rate = current_control.primary_control.target_rate\n        new_control = bores.PrimaryPhaseRateControl(\n            primary_phase=current_control.primary_phase,\n            primary_control=bores.AdaptiveBHPRateControl(\n                target_rate=current_rate * 0.5,\n                target_phase=current_control.primary_control.target_phase,\n                bhp_limit=current_control.primary_control.bhp_limit,\n            ),\n            secondary_clamp=current_control.secondary_clamp,\n        )\n        well.control = new_control\n</code></pre>"},{"location":"user-guide/wells/schedules/#building-schedules","title":"Building Schedules","text":""},{"location":"user-guide/wells/schedules/#single-well-schedule","title":"Single Well Schedule","text":"<p>A <code>WellSchedule</code> collects events for a single well. Events are identified by string IDs:</p> <pre><code>import bores\n\nschedule = bores.WellSchedule()\n\n# Add events\nschedule.add(\"rate_reduction\", bores.WellEvent(\n    predicate=bores.time_predicate(time_step=50),\n    action=bores.update_well(\n        control=bores.PrimaryPhaseRateControl(\n            primary_phase=bores.FluidPhase.OIL,\n            primary_control=bores.AdaptiveBHPRateControl(\n                target_rate=-200.0,\n                target_phase=\"oil\",\n                bhp_limit=800.0,\n            ),\n            secondary_clamp=bores.ProductionClamp(),\n        ),\n    ),\n))\n\nschedule.add(\"shut_in\", bores.WellEvent(\n    predicate=bores.time_predicate(time=730.0),  # After 2 years\n    action=bores.update_well(is_active=False),\n))\n</code></pre>"},{"location":"user-guide/wells/schedules/#multi-well-schedules","title":"Multi-Well Schedules","text":"<p>A <code>WellSchedules</code> object organizes schedules for all wells by name:</p> <pre><code>import bores\n\nschedules = bores.WellSchedules()\n\n# Add schedule for a production well\nprod_schedule = bores.WellSchedule()\nprod_schedule.add(\"reduce_rate\", bores.WellEvent(\n    predicate=bores.time_predicate(time_step=100),\n    action=bores.update_well(\n        control=bores.PrimaryPhaseRateControl(\n            primary_phase=bores.FluidPhase.OIL,\n            primary_control=bores.AdaptiveBHPRateControl(\n                target_rate=-200.0,\n                target_phase=\"oil\",\n                bhp_limit=800.0,\n            ),\n            secondary_clamp=bores.ProductionClamp(),\n        ),\n    ),\n))\nschedules.add(\"PROD-1\", prod_schedule)\n\n# Add schedule for an injection well\ninj_schedule = bores.WellSchedule()\ninj_schedule.add(\"increase_rate\", bores.WellEvent(\n    predicate=bores.time_predicate(time_step=100),\n    action=bores.update_well(\n        control=bores.ConstantRateControl(\n            target_rate=1200.0,\n            bhp_limit=5000.0,\n        ),\n    ),\n))\nschedules.add(\"INJ-1\", inj_schedule)\n</code></pre> <p>Pass the schedules to the <code>Config</code>:</p> <pre><code>config = bores.Config(\n    timer=timer,\n    wells=wells,\n    well_schedules=schedules,\n    rock_fluid_tables=rock_fluid,\n    scheme=\"impes\",\n)\n</code></pre>"},{"location":"user-guide/wells/schedules/#composing-predicates","title":"Composing Predicates","text":"<p>The <code>EventPredicate</code> class supports logical composition using Python operators:</p> <pre><code>import bores\n\n# Create individual predicates\nafter_year_one = bores.EventPredicate.from_func(\n    bores.time_predicate(time=365.0)\n)\n\n# Combine with AND\ncombined = bores.EventPredicate.all_of(\n    bores.time_predicate(time=365.0),\n    low_pressure,  # Custom predicate from earlier\n)\n\n# Combine with OR\neither = bores.EventPredicate.any_of(\n    high_water_cut,\n    bores.time_predicate(time=1825.0),  # 5 years\n)\n</code></pre> <p>Composed predicates are fully serializable.</p>"},{"location":"user-guide/wells/schedules/#composing-actions","title":"Composing Actions","text":"<p>Similarly, you can chain multiple actions together:</p> <pre><code>import bores\n\n# Execute both actions when the event triggers\ncombined_action = bores.EventAction.sequence(\n    bores.update_well(skin_factor=-2.0),       # Workover\n    bores.update_well(\n        control=bores.PrimaryPhaseRateControl(\n            primary_phase=bores.FluidPhase.OIL,\n            primary_control=bores.AdaptiveBHPRateControl(\n                target_rate=-800.0,\n                target_phase=\"oil\",\n                bhp_limit=1200.0,\n            ),\n            secondary_clamp=bores.ProductionClamp(),\n        ),\n    ),\n)\n</code></pre>"},{"location":"user-guide/wells/schedules/#removing-events","title":"Removing Events","text":"<p>You can remove events from a schedule by their ID:</p> <pre><code>schedule.remove(\"rate_reduction\")\n</code></pre> <p>This is useful for dynamically modifying schedules between simulation restarts.</p> <p>Event Naming Convention</p> <p>Use descriptive event IDs that indicate what happens and when. Examples: \"reduce_rate_year_2\", \"shut_in_high_wc\", \"convert_to_injector_phase_2\". Good naming makes it easy to find and modify events later.</p>"},{"location":"visualization/","title":"Visualization","text":"<p>BORES includes a built-in visualization system based on Plotly for creating interactive plots of simulation results. The system covers three levels of visualization: 1D time series plots for production histories and performance metrics, 2D maps for spatial property distributions across reservoir layers, and 3D volume renderings for full-field property visualization with well overlays.</p> <p>All visualization is handled through <code>DataVisualizer</code> classes, one for each dimensionality. Each visualizer uses a registry of renderers that map plot types to rendering strategies. You pass in your data (typically from a <code>ModelState</code>) and get back a Plotly <code>Figure</code> object that you can display interactively, save as an image, or embed in a report.</p> <p>The visualization modules are designed to work directly with BORES data structures. The 3D visualizer accepts <code>ModelState</code> or <code>ReservoirModel</code> objects and can extract any registered property by name. The 1D and 2D visualizers work with numpy arrays, which you extract from states yourself. This gives you full control over data selection and transformation while keeping the plotting API clean.</p>"},{"location":"visualization/#visualization-modules","title":"Visualization Modules","text":"Module Import Use Case 1D Series <code>bores.visualization.plotly1d</code> Production rates, pressure decline, recovery factors 2D Maps <code>bores.visualization.plotly2d</code> Layer slices, areal distributions, cross-sections 3D Volumes <code>bores.visualization.plotly3d</code> Full-field properties, isosurfaces, well locations Base <code>bores.visualization.base</code> Color schemes, property registry, plot merging"},{"location":"visualization/#quick-start","title":"Quick Start","text":"<pre><code>import bores\nfrom bores.visualization import plotly1d, plotly2d, plotly3d\n\n# Run a simulation\nstates = list(bores.run(model, config))\n\n# 1D: Plot pressure decline over time\nimport numpy as np\ntime_pressure = np.column_stack([\n    [s.time_in_days for s in states],\n    [s.model.fluid_properties.pressure_grid.mean() for s in states],\n])\nviz1d = plotly1d.DataVisualizer()\nfig = viz1d.make_plot(time_pressure, x_label=\"Time (days)\", y_label=\"Pressure (psi)\")\nfig.show()\n\n# 2D: Heatmap of oil saturation in a layer\nstate = states[-1]\nSo_layer = state.model.fluid_properties.oil_saturation_grid[:, :, 0]\nviz2d = plotly2d.DataVisualizer()\nfig = viz2d.make_plot(So_layer, plot_type=\"heatmap\")\nfig.show()\n\n# 3D: Volume rendering of pressure\nviz3d = plotly3d.DataVisualizer()\nfig = viz3d.make_plot(state, \"pressure\")\nfig.show()\n</code></pre>"},{"location":"visualization/#color-schemes","title":"Color Schemes","text":"<p>BORES provides colorblind-friendly color schemes through the <code>ColorScheme</code> enum. The default schemes are chosen to be perceptually uniform and accessible:</p> Scheme Type Best For <code>VIRIDIS</code> Sequential Pressure, permeability (recommended default) <code>CIVIDIS</code> Sequential Oil saturation, porosity (colorblind-optimized) <code>PLASMA</code> Sequential Density, concentration <code>INFERNO</code> Sequential Temperature, viscosity <code>MAGMA</code> Sequential Gas saturation <code>RdBu</code> Diverging Pressure changes, saturation differences <code>RdYlBu</code> Diverging Multi-value diverging data <p>The <code>ColorbarPresets</code> class provides pre-configured colorbar settings for common reservoir properties with appropriate scales and formatting.</p>"},{"location":"visualization/#property-registry","title":"Property Registry","text":"<p>The 3D visualizer uses a <code>PropertyRegistry</code> that maps property names to metadata including display names, units, color schemes, and scaling options. When you call <code>viz3d.make_plot(state, \"pressure\")</code>, the registry looks up the property metadata to determine how to label, scale, and color the visualization.</p> <p>You can access the registry directly:</p> <pre><code>from bores.visualization.base import property_registry\n\n# List all registered properties\nfor name, meta in property_registry.items():\n    print(f\"{name}: {meta.display_name} ({meta.unit})\")\n</code></pre> <p>Properties with <code>log_scale=True</code> (like viscosity and compressibility) are automatically log-transformed for visualization while showing the original physical values in hover text and colorbar labels.</p>"},{"location":"visualization/#merging-plots","title":"Merging Plots","text":"<p>The <code>merge_plots()</code> function combines multiple Plotly figures into a single subplot grid. This is useful for creating multi-panel comparison views:</p> <pre><code>from bores.visualization.base import merge_plots\n\nfig_pressure = viz3d.make_plot(state, \"pressure\")\nfig_oil_sat = viz3d.make_plot(state, \"oil_saturation\")\nfig_water_sat = viz3d.make_plot(state, \"water_saturation\")\n\ncombined = merge_plots(\n    fig_pressure, fig_oil_sat, fig_water_sat,\n    cols=3,\n    subplot_titles=[\"Pressure\", \"Oil Saturation\", \"Water Saturation\"],\n    title=\"Reservoir State at Final Time Step\",\n)\ncombined.show()\n</code></pre>"},{"location":"visualization/#exporting-images","title":"Exporting Images","text":"<p>Configure image export settings globally with <code>image_config()</code>:</p> <pre><code>from bores.visualization.base import image_config\n\n# Set default export format and resolution\nimage_config(fmt=\"png\", scale=3)\n\n# Save a figure\nfig.write_image(\"pressure_map.png\")\n</code></pre>"},{"location":"visualization/#environment-configuration","title":"Environment Configuration","text":"<p>Performance limits and styling defaults can be customized through environment variables. Set these before importing BORES:</p> <pre><code>export BORES_MAX_VOLUME_CELLS=2000000      # Max cells for 3D volume rendering\nexport BORES_COLORBAR_THICKNESS=20         # Colorbar thickness in pixels\nexport BORES_RECOMMENDED_VOLUME_CELLS=512000  # Target cells after auto-coarsening\n</code></pre> <p>To see the current configuration:</p> <pre><code>from bores.visualization.config import get_config_summary\nprint(get_config_summary())\n</code></pre>"},{"location":"visualization/1d-plots/","title":"1D Time Series Plots","text":""},{"location":"visualization/1d-plots/#overview","title":"Overview","text":"<p>The 1D visualization module creates line plots, bar charts, scatter plots, and tornado diagrams from series data. These are the standard tools for analyzing production histories, pressure decline curves, recovery factors, and sensitivity results. The module lives in <code>bores.visualization.plotly1d</code> and centers on the <code>DataVisualizer</code> class.</p> <p>Every plot method returns a Plotly <code>Figure</code> object. You can display it interactively with <code>.show()</code>, save it as HTML with <code>.write_html()</code>, or export it as a static image with <code>.write_image()</code>. The figures are fully interactive: you can zoom, pan, hover for data values, and toggle individual series in the legend.</p> <p>The 1D visualizer does not take <code>ModelState</code> objects directly. Instead, you extract the data you want from your states as numpy arrays and pass those arrays to the visualizer. This gives you full control over what to plot and how to prepare the data (averaging, unit conversion, filtering by well or region) before visualization.</p>"},{"location":"visualization/1d-plots/#data-formats","title":"Data Formats","text":"<p>The visualizer accepts three data formats through the <code>SeriesData</code> type:</p> <p>Single series as a (n, 2) array:</p> <pre><code>import numpy as np\n\n# Each row is (x, y)\ntime_pressure = np.column_stack([\n    [s.time_in_days for s in states],\n    [s.model.fluid_properties.pressure_grid.mean() for s in states],\n])\n</code></pre> <p>Multiple series as a list of arrays:</p> <pre><code># Each array is (n, 2)\noil_series = np.column_stack([time_days, avg_oil_sat])\nwater_series = np.column_stack([time_days, avg_water_sat])\ngas_series = np.column_stack([time_days, avg_gas_sat])\n\ndata = [oil_series, water_series, gas_series]\n</code></pre> <p>Named series as a dictionary:</p> <pre><code>data = {\n    \"Oil Saturation\": oil_series,\n    \"Water Saturation\": water_series,\n    \"Gas Saturation\": gas_series,\n}\n</code></pre> <p>When you pass a dictionary, the keys become the legend labels. When you pass a list, names default to \"Series 1\", \"Series 2\", etc., unless you provide <code>series_names</code> in the render call.</p>"},{"location":"visualization/1d-plots/#creating-plots","title":"Creating Plots","text":""},{"location":"visualization/1d-plots/#datavisualizer","title":"<code>DataVisualizer</code>","text":"<p>The <code>DataVisualizer</code> class is the main entry point for 1D plotting. Create one with optional configuration:</p> <pre><code>from bores.visualization.plotly1d import DataVisualizer, PlotConfig\n\n# Default configuration\nviz = DataVisualizer()\n\n# Custom configuration\nviz = DataVisualizer(config=PlotConfig(\n    width=1000,\n    height=500,\n    line_width=3.0,\n    font_size=14,\n    show_legend=True,\n    legend_position=\"top\",\n))\n</code></pre>"},{"location":"visualization/1d-plots/#make_plot","title":"<code>make_plot</code>","text":"<p>The <code>make_plot()</code> method creates a single plot:</p> <pre><code>fig = viz.make_plot(\n    data,\n    plot_type=\"line\",\n    x_label=\"Time (days)\",\n    y_label=\"Average Pressure (psi)\",\n    title=\"Reservoir Pressure Decline\",\n)\nfig.show()\n</code></pre> <p>The <code>plot_type</code> parameter accepts either a <code>PlotType</code> enum value or a string. Available types are <code>\"line\"</code>, <code>\"bar\"</code>, <code>\"scatter\"</code>, and <code>\"tornado\"</code>.</p>"},{"location":"visualization/1d-plots/#make_plots-subplots","title":"<code>make_plots</code> (Subplots)","text":"<p>The <code>make_plots()</code> method creates a grid of subplots from multiple datasets:</p> <pre><code>fig = viz.make_plots(\n    data_list=[time_pressure, time_oil_sat, time_water_sat],\n    plot_types=\"line\",\n    rows=3,\n    cols=1,\n    subplot_titles=[\"Pressure\", \"Oil Saturation\", \"Water Saturation\"],\n    shared_xaxes=True,\n)\nfig.show()\n</code></pre> <p>You can mix plot types across subplots by passing a list of types:</p> <pre><code>fig = viz.make_plots(\n    data_list=[production_data, sensitivity_data],\n    plot_types=[\"line\", \"tornado\"],\n    rows=1,\n    cols=2,\n)\n</code></pre>"},{"location":"visualization/1d-plots/#make_series_plot-convenience-function","title":"<code>make_series_plot</code> (Convenience Function)","text":"<p>For quick one-off line plots, the module provides a standalone function:</p> <pre><code>from bores.visualization.plotly1d import make_series_plot\n\nfig = make_series_plot(\n    data,\n    title=\"Oil Production Rate\",\n    x_label=\"Time (days)\",\n    y_label=\"Rate (STB/day)\",\n)\n</code></pre> <p>This creates a <code>LineRenderer</code> with default configuration and renders the data. It is equivalent to creating a <code>DataVisualizer</code> and calling <code>make_plot()</code> with <code>plot_type=\"line\"</code>.</p>"},{"location":"visualization/1d-plots/#plot-types","title":"Plot Types","text":""},{"location":"visualization/1d-plots/#line-plots","title":"Line Plots","text":"<p>Line plots are the default and most common type. They connect data points with continuous lines, making them ideal for time series data.</p> <pre><code>import numpy as np\n\ntime_days = np.array([s.time_in_days for s in states])\navg_pressure = np.array([s.model.fluid_properties.pressure_grid.mean() for s in states])\n\ndata = {\n    \"Average Pressure\": np.column_stack([time_days, avg_pressure]),\n}\nfig = viz.make_plot(data, plot_type=\"line\", x_label=\"Time (days)\", y_label=\"Pressure (psi)\")\n</code></pre> <p>You can plot multiple series on the same axes by including them all in the data dictionary or list.</p>"},{"location":"visualization/1d-plots/#bar-charts","title":"Bar Charts","text":"<p>Bar charts display discrete or categorical data. They are useful for comparing values across categories, such as production by well or recovery factor by scenario.</p> <pre><code># Recovery factors by scenario\nscenarios = np.array([1, 2, 3, 4])\nrecovery = np.array([0.25, 0.32, 0.41, 0.38])\ndata = np.column_stack([scenarios, recovery])\n\nfig = viz.make_plot(\n    data,\n    plot_type=\"bar\",\n    x_label=\"Scenario\",\n    y_label=\"Recovery Factor\",\n    series_names=[\"Recovery Factor\"],\n)\n</code></pre>"},{"location":"visualization/1d-plots/#scatter-plots","title":"Scatter Plots","text":"<p>Scatter plots show individual data points without connecting lines. They support optional trendline fitting. Use them for cross-plots like permeability vs. porosity or rate vs. pressure drawdown.</p> <pre><code>fig = viz.make_plot(\n    data,\n    plot_type=\"scatter\",\n    x_label=\"Porosity (fraction)\",\n    y_label=\"Permeability (mD)\",\n)\n</code></pre>"},{"location":"visualization/1d-plots/#tornado-plots","title":"Tornado Plots","text":"<p>Tornado plots display sensitivity analysis results as horizontal bars, showing the impact of parameter variations on a target metric. Each parameter has two bars: one for the low case and one for the high case, centered on the base case value.</p> <pre><code># Each row: [parameter_index, low_delta, high_delta]\nsensitivity_data = np.array([\n    [1, -50, 80],     # Permeability: base - 50, base + 80\n    [2, -30, 25],     # Porosity\n    [3, -20, 15],     # Water saturation\n    [4, -10, 12],     # Oil viscosity\n])\nfig = viz.make_plot(\n    sensitivity_data,\n    plot_type=\"tornado\",\n    series_names=[\"Permeability\", \"Porosity\", \"Sw\", \"Viscosity\"],\n)\n</code></pre>"},{"location":"visualization/1d-plots/#configuration-reference","title":"Configuration Reference","text":"<p>The <code>PlotConfig</code> class controls all visual aspects of 1D plots:</p> Parameter Default Description <code>width</code> 800 Figure width in pixels <code>height</code> 600 Figure height in pixels <code>title</code> <code>None</code> Default title for plots <code>show_legend</code> <code>True</code> Whether to display legend <code>legend_position</code> <code>\"right\"</code> Legend position: top, bottom, left, right <code>line_width</code> 2.0 Default line width <code>marker_size</code> 8 Default marker size <code>opacity</code> 0.8 Default opacity for plot elements <code>font_family</code> <code>\"Arial, sans-serif\"</code> Font family <code>font_size</code> 12 Default font size <code>title_font_size</code> 16 Title font size <code>show_grid</code> <code>True</code> Whether to show grid lines <code>show_hover</code> <code>True</code> Whether to show hover information <code>hover_mode</code> <code>\"x unified\"</code> Hover interaction mode <code>background_color</code> <code>\"white\"</code> Figure background color <code>plot_background_color</code> <code>\"white\"</code> Plot area background color"},{"location":"visualization/1d-plots/#common-workflows","title":"Common Workflows","text":""},{"location":"visualization/1d-plots/#production-rate-over-time","title":"Production Rate Over Time","text":"<pre><code>import numpy as np\nfrom bores.visualization.plotly1d import DataVisualizer\n\nviz = DataVisualizer()\nstates = list(bores.run(model, config))\n\ntime_days = np.array([s.time_in_days for s in states])\noil_rate = np.array([s.production.oil.sum() for s in states])\nwater_rate = np.array([s.production.water.sum() for s in states])\n\ndata = {\n    \"Oil Rate\": np.column_stack([time_days, oil_rate]),\n    \"Water Rate\": np.column_stack([time_days, water_rate]),\n}\nfig = viz.make_plot(data, x_label=\"Time (days)\", y_label=\"Rate (ft3/day)\")\nfig.show()\n</code></pre>"},{"location":"visualization/1d-plots/#pressure-and-saturation-dashboard","title":"Pressure and Saturation Dashboard","text":"<pre><code>avg_pressure = np.array([s.model.fluid_properties.pressure_grid.mean() for s in states])\navg_So = np.array([s.model.fluid_properties.oil_saturation_grid.mean() for s in states])\navg_Sw = np.array([s.model.fluid_properties.water_saturation_grid.mean() for s in states])\n\nfig = viz.make_plots(\n    data_list=[\n        np.column_stack([time_days, avg_pressure]),\n        {\n            \"Oil\": np.column_stack([time_days, avg_So]),\n            \"Water\": np.column_stack([time_days, avg_Sw]),\n        },\n    ],\n    plot_types=\"line\",\n    rows=2,\n    cols=1,\n    subplot_titles=[\"Average Pressure (psi)\", \"Average Saturations\"],\n    shared_xaxes=True,\n)\nfig.show()\n</code></pre>"},{"location":"visualization/2d-maps/","title":"2D Spatial Maps","text":""},{"location":"visualization/2d-maps/#overview","title":"Overview","text":"<p>The 2D visualization module creates spatial maps of reservoir properties on two-dimensional grids. Heatmaps, contour maps, scatter plots, cross-section line plots, and 3D surface plots all take 2D numpy arrays and render them as interactive Plotly figures. These are the standard tools for examining property distributions across a reservoir slice: pressure maps, saturation fronts, permeability fields, and fluid contact movements.</p> <p>The module lives in <code>bores.visualization.plotly2d</code> and centers on the <code>DataVisualizer</code> class. Unlike the 1D module (which works with time series), the 2D module works with grid data where each element represents a cell in the simulation grid. Every plot method returns a Plotly <code>Figure</code> object that you can display interactively with <code>.show()</code>, save as HTML with <code>.write_html()</code>, or export as a static image with <code>.write_image()</code>.</p> <p>All 2D visualizations support property metadata through the <code>PropertyMeta</code> class. Metadata controls the colorbar label, display name in hover text, unit string, log-scale transformation, and default color scheme. You can pass metadata explicitly or let the visualizer create default metadata automatically. When you use the <code>PropertyRegistry</code> (covered in the overview), the metadata is pre-configured for common reservoir properties like pressure, saturation, permeability, and porosity.</p> <p>The 2D visualizer expects raw 2D numpy arrays, not <code>ModelState</code> objects. You extract the property grid you want from your simulation state and pass it to the visualizer. This separation gives you full control over data preparation, including slicing 3D grids to get 2D cross-sections, applying unit conversions, or computing derived quantities before visualization.</p>"},{"location":"visualization/2d-maps/#data-input","title":"Data Input","text":"<p>The 2D visualizer works with 2D numpy arrays. Each array represents a spatial grid where rows correspond to the y-axis and columns correspond to the x-axis. The array shape <code>(ny, nx)</code> follows numpy's row-major convention: <code>data[i, j]</code> refers to row <code>i</code> (y-direction) and column <code>j</code> (x-direction).</p> <pre><code>import numpy as np\n\n# Extract a 2D slice from a 3D simulation state\n# For a 3D grid with shape (nz, ny, nx), take a horizontal slice at layer k=2\npressure_slice = states[-1].model.fluid_properties.pressure_grid[2, :, :]\n\n# Or extract the full 2D grid from a 2D simulation\npressure_grid = states[-1].model.fluid_properties.pressure_grid\n</code></pre> <p>If you do not provide coordinate arrays, the visualizer uses integer indices (0, 1, 2, ...) for both axes. To map grid cells to physical coordinates, pass <code>x_coords</code> and <code>y_coords</code> arrays:</p> <pre><code># Physical coordinates in feet\ndx = 100.0  # cell width\ndy = 100.0  # cell height\nnx, ny = 20, 15\nx_coords = np.arange(nx) * dx + dx / 2  # cell centers\ny_coords = np.arange(ny) * dy + dy / 2\n</code></pre>"},{"location":"visualization/2d-maps/#property-metadata","title":"Property Metadata","text":"<p>The <code>PropertyMeta</code> class controls how a property is displayed. It sets the plot title, unit string, whether to apply a log-scale transformation, and the default color scheme. You can create metadata manually or retrieve it from the <code>PropertyRegistry</code>.</p> <pre><code>from bores.visualization.base import PropertyMeta, ColorScheme\n\n# Manual metadata\npressure_meta = PropertyMeta(\n    name=\"pressure_grid\",\n    display_name=\"Pressure\",\n    unit=\"psi\",\n    log_scale=False,\n    color_scheme=ColorScheme.VIRIDIS,\n)\n\n# For permeability (log-scale is often appropriate)\nperm_meta = PropertyMeta(\n    name=\"permeability_x\",\n    display_name=\"Permeability (x)\",\n    unit=\"mD\",\n    log_scale=True,\n    color_scheme=ColorScheme.PLASMA,\n)\n</code></pre> <p>When <code>log_scale</code> is <code>True</code>, the visualizer applies a base-10 logarithm to the data before mapping it to colors. Hover text still shows the original (un-logged) values. This is useful for permeability, which can span several orders of magnitude across a reservoir.</p> <p>If you do not pass metadata, the visualizer creates a default <code>PropertyMeta</code> with <code>display_name=\"Data\"</code>, no unit, no log scale, and viridis color scheme. For quick exploration this is fine, but for publication-quality figures you should always provide metadata with meaningful labels and units.</p>"},{"location":"visualization/2d-maps/#creating-plots","title":"Creating Plots","text":""},{"location":"visualization/2d-maps/#datavisualizer","title":"DataVisualizer","text":"<p>The <code>DataVisualizer</code> class is the main entry point for 2D plotting. Create one with optional configuration:</p> <pre><code>from bores.visualization.plotly2d import DataVisualizer, PlotConfig\n\n# Default configuration\nviz = DataVisualizer()\n\n# Custom configuration\nviz = DataVisualizer(config=PlotConfig(\n    width=1000,\n    height=800,\n    color_scheme=\"plasma\",\n    contour_levels=25,\n    show_colorbar=True,\n    font_size=14,\n))\n</code></pre>"},{"location":"visualization/2d-maps/#make_plot","title":"<code>make_plot</code>","text":"<p>The <code>make_plot()</code> method creates a single 2D plot:</p> <pre><code>fig = viz.make_plot(\n    data=pressure_grid,\n    plot_type=\"heatmap\",\n    metadata=pressure_meta,\n    x_coords=x_coords,\n    y_coords=y_coords,\n    x_label=\"X (ft)\",\n    y_label=\"Y (ft)\",\n    title=\"Reservoir Pressure at t = 365 days\",\n)\nfig.show()\n</code></pre> <p>The <code>plot_type</code> parameter accepts either a <code>PlotType</code> enum value or a string. Available types are <code>\"heatmap\"</code>, <code>\"contour\"</code>, <code>\"contour_filled\"</code>, <code>\"scatter\"</code>, <code>\"line\"</code>, and <code>\"surface\"</code>.</p> <p>The method also accepts optional <code>width</code> and <code>height</code> parameters that override the config values for this specific plot. You can pass an existing <code>figure</code> to add the plot as an additional trace to an existing figure.</p>"},{"location":"visualization/2d-maps/#make_plots-subplots","title":"<code>make_plots</code> (Subplots)","text":"<p>The <code>make_plots()</code> method creates a grid of subplots from multiple datasets:</p> <pre><code>oil_sat = states[-1].model.fluid_properties.oil_saturation_grid\nwater_sat = states[-1].model.fluid_properties.water_saturation_grid\npressure = states[-1].model.fluid_properties.pressure_grid\n\nfig = viz.make_plots(\n    data_list=[pressure, oil_sat, water_sat],\n    plot_types=\"heatmap\",\n    rows=1,\n    cols=3,\n    subplot_titles=[\"Pressure (psi)\", \"Oil Saturation\", \"Water Saturation\"],\n    shared_xaxes=True,\n    shared_yaxes=True,\n    x_coords=x_coords,\n    y_coords=y_coords,\n    x_label=\"X (ft)\",\n    y_label=\"Y (ft)\",\n)\nfig.show()\n</code></pre> <p>You can mix plot types across subplots by passing a list of types:</p> <pre><code>fig = viz.make_plots(\n    data_list=[pressure, pressure],\n    plot_types=[\"heatmap\", \"contour\"],\n    rows=1,\n    cols=2,\n    subplot_titles=[\"Pressure Heatmap\", \"Pressure Contours\"],\n)\n</code></pre> <p>You can control spacing between subplots with <code>vertical_spacing</code> and <code>horizontal_spacing</code> (both as fractions from 0.0 to 1.0). The <code>metadata_list</code> parameter accepts a sequence of <code>PropertyMeta</code> objects, one per subplot.</p>"},{"location":"visualization/2d-maps/#plot-types","title":"Plot Types","text":""},{"location":"visualization/2d-maps/#heatmaps","title":"Heatmaps","text":"<p>Heatmaps are the default and most common 2D plot type. They display a color-coded grid where each cell is colored according to its value. The color mapping is continuous, with a colorbar showing the value-to-color correspondence.</p> <pre><code>from bores.visualization.plotly2d import DataVisualizer\nfrom bores.visualization.base import PropertyMeta, ColorScheme\n\nviz = DataVisualizer()\n\npressure_meta = PropertyMeta(\n    name=\"pressure_grid\",\n    display_name=\"Pressure\",\n    unit=\"psi\",\n    log_scale=False,\n    color_scheme=ColorScheme.VIRIDIS,\n)\n\nfig = viz.make_plot(\n    data=pressure_grid,\n    plot_type=\"heatmap\",\n    metadata=pressure_meta,\n    x_label=\"X (ft)\",\n    y_label=\"Y (ft)\",\n)\nfig.show()\n</code></pre> <p>Heatmaps support optional <code>cmin</code> and <code>cmax</code> keyword arguments that fix the color range. This is useful when comparing multiple snapshots of the same property across different time steps, where you want a consistent color scale:</p> <pre><code># Fix color range for consistent comparison across timesteps\nfig = viz.make_plot(\n    data=pressure_grid,\n    plot_type=\"heatmap\",\n    metadata=pressure_meta,\n    cmin=1500.0,\n    cmax=3000.0,\n)\n</code></pre> <p>Hover text shows the x-coordinate, y-coordinate, property name, value, and unit for each cell.</p>"},{"location":"visualization/2d-maps/#contour-maps","title":"Contour Maps","text":"<p>Contour maps draw isolines connecting points of equal value. They are the standard way to visualize pressure fields, fluid contacts, and saturation fronts in reservoir engineering. The <code>\"contour\"</code> type draws line contours, while <code>\"contour_filled\"</code> fills the regions between contour lines with color.</p> <pre><code># Line contours\nfig = viz.make_plot(\n    data=pressure_grid,\n    plot_type=\"contour\",\n    metadata=pressure_meta,\n    x_label=\"X (ft)\",\n    y_label=\"Y (ft)\",\n    contour_levels=15,\n)\n\n# Filled contours\nfig = viz.make_plot(\n    data=pressure_grid,\n    plot_type=\"contour_filled\",\n    metadata=pressure_meta,\n    x_label=\"X (ft)\",\n    y_label=\"Y (ft)\",\n    contour_levels=20,\n)\n</code></pre> <p>The <code>contour_levels</code> keyword argument controls how many contour lines to draw. It defaults to 20 if not specified (or to the value set in <code>PlotConfig</code>). Contour lines are automatically labeled with their values. You can also pass <code>cmin</code> and <code>cmax</code> to control the range of contour levels.</p> <p>Filled contours are particularly useful for saturation maps where you want to see the flood front as a continuous color field rather than discrete isolines. Line contours work better for pressure maps where you want to see the pressure gradient direction (perpendicular to the isolines).</p>"},{"location":"visualization/2d-maps/#scatter-plots","title":"Scatter Plots","text":"<p>Scatter plots display individual grid cells as markers, colored by their value. They are useful for sparse data or for highlighting cells that meet a threshold condition. The scatter renderer filters out cells below a threshold value, so only cells of interest appear on the plot.</p> <pre><code># Show only cells where oil saturation &gt; 0.3\nfig = viz.make_plot(\n    data=oil_saturation_grid,\n    plot_type=\"scatter\",\n    metadata=oil_sat_meta,\n    x_label=\"X (ft)\",\n    y_label=\"Y (ft)\",\n    threshold=0.3,\n    marker_size=10,\n)\n</code></pre> <p>The <code>threshold</code> parameter (default 0.0) sets the minimum value for a cell to be included. The <code>marker_size</code> parameter controls the size of the scatter markers. Markers are colored according to the value, using the same color scale as heatmaps.</p> <p>Scatter plots are useful for visualizing well locations overlaid on a property map, or for showing the spatial distribution of high-permeability channels in a heterogeneous reservoir.</p>"},{"location":"visualization/2d-maps/#cross-section-line-plots","title":"Cross-Section Line Plots","text":"<p>Line plots extract 1D cross-sections from a 2D grid and display them as line charts. This is useful for examining how a property varies along a specific row or column of the grid. You can plot horizontal cross-sections (constant y, varying x), vertical cross-sections (constant x, varying y), or both.</p> <pre><code># Horizontal cross-section at row index 5\nfig = viz.make_plot(\n    data=pressure_grid,\n    plot_type=\"line\",\n    metadata=pressure_meta,\n    x_coords=x_coords,\n    y_coords=y_coords,\n    x_label=\"Distance (ft)\",\n    y_label=\"Pressure (psi)\",\n    line_mode=\"horizontal\",\n    line_indices=[5],\n)\n\n# Both horizontal and vertical cross-sections\nfig = viz.make_plot(\n    data=pressure_grid,\n    plot_type=\"line\",\n    metadata=pressure_meta,\n    line_mode=\"both\",\n    line_indices=[5, 10],  # row 5 for horizontal, column 10 for vertical\n)\n</code></pre> <p>The <code>line_mode</code> parameter accepts <code>\"horizontal\"</code>, <code>\"vertical\"</code>, or <code>\"both\"</code>. The <code>line_indices</code> parameter specifies which row/column indices to extract. When <code>line_mode</code> is <code>\"both\"</code>, the first index is used for the horizontal cross-section and the second for the vertical. If <code>line_indices</code> is not provided, the visualizer defaults to the middle row and column.</p> <p>Cross-section line plots are valuable for comparing analytical solutions against simulation results along a 1D profile, or for examining pressure drawdown from a well.</p>"},{"location":"visualization/2d-maps/#3d-surface-plots","title":"3D Surface Plots","text":"<p>Surface plots render a 2D grid as a 3D surface where the z-height represents the property value. This gives an intuitive sense of spatial gradients and peaks that can be harder to see in flat 2D maps.</p> <pre><code>fig = viz.make_plot(\n    data=pressure_grid,\n    plot_type=\"surface\",\n    metadata=pressure_meta,\n    x_coords=x_coords,\n    y_coords=y_coords,\n    x_label=\"X (ft)\",\n    y_label=\"Y (ft)\",\n)\nfig.show()\n</code></pre> <p>The surface is colored according to the z-values using the same color scheme as heatmaps. You can pass <code>cmin</code> and <code>cmax</code> to fix the color range. The resulting figure is fully interactive: you can rotate, zoom, and pan the 3D view.</p> <p>Surface plots work best for smooth, continuous properties like pressure. For discontinuous properties like saturation near a flood front, heatmaps or filled contours are usually more informative.</p>"},{"location":"visualization/2d-maps/#configuration-reference","title":"Configuration Reference","text":"<p>The <code>PlotConfig</code> class controls all visual aspects of 2D plots:</p> Parameter Default Description <code>width</code> 800 Figure width in pixels <code>height</code> 600 Figure height in pixels <code>show_colorbar</code> <code>True</code> Whether to display color scale bar <code>title</code> <code>None</code> Default title for plots <code>color_scheme</code> <code>\"viridis\"</code> Default colorscale name <code>opacity</code> 0.8 Default opacity for plot elements <code>show_grid</code> <code>True</code> Whether to show grid lines <code>grid_color</code> <code>\"lightgray\"</code> Color of grid lines <code>axis_line_color</code> <code>\"black\"</code> Color of axis lines <code>axis_line_width</code> 1.0 Width of axis lines <code>font_family</code> <code>\"Arial, sans-serif\"</code> Font family <code>font_size</code> 12 Default font size <code>title_font_size</code> 16 Title font size <code>axis_title_font_size</code> 14 Axis title font size <code>colorbar_thickness</code> 20 Colorbar thickness in pixels <code>colorbar_len</code> 0.8 Colorbar length as fraction of plot height <code>contour_line_width</code> 1.5 Default contour line width <code>contour_levels</code> 20 Default number of contour levels <code>scatter_marker_size</code> 6 Default scatter marker size <code>line_width</code> 2.0 Default line width <code>margin_left</code> 80 Left margin in pixels <code>margin_right</code> 80 Right margin in pixels <code>margin_top</code> 80 Top margin in pixels <code>margin_bottom</code> 80 Bottom margin in pixels <code>plot_bgcolor</code> <code>\"#f8f9fa\"</code> Background color of plot area <code>paper_bgcolor</code> <code>\"#ffffff\"</code> Background color of entire figure"},{"location":"visualization/2d-maps/#common-workflows","title":"Common Workflows","text":""},{"location":"visualization/2d-maps/#comparing-timesteps","title":"Comparing Timesteps","text":"<p>To compare a property across multiple timesteps, create a subplot grid with consistent color ranges:</p> <pre><code>import numpy as np\nfrom bores.visualization.plotly2d import DataVisualizer\nfrom bores.visualization.base import PropertyMeta, ColorScheme\n\nviz = DataVisualizer()\nstates = list(bores.run(model, config))\n\npressure_meta = PropertyMeta(\n    name=\"pressure_grid\",\n    display_name=\"Pressure\",\n    unit=\"psi\",\n    log_scale=False,\n    color_scheme=ColorScheme.VIRIDIS,\n)\n\n# Select snapshots at day 0, 365, and 730\nsnapshots = [states[0], states[len(states)//2], states[-1]]\npressure_grids = [s.model.fluid_properties.pressure_grid for s in snapshots]\ntitles = [f\"Day {s.time_in_days:.0f}\" for s in snapshots]\n\nfig = viz.make_plots(\n    data_list=pressure_grids,\n    plot_types=\"heatmap\",\n    metadata_list=[pressure_meta] * 3,\n    rows=1,\n    cols=3,\n    subplot_titles=titles,\n    shared_yaxes=True,\n)\nfig.show()\n</code></pre>"},{"location":"visualization/2d-maps/#waterflood-front-tracking","title":"Waterflood Front Tracking","text":"<p>Visualize the water saturation front advancing through the reservoir:</p> <pre><code>water_sat_meta = PropertyMeta(\n    name=\"water_saturation_grid\",\n    display_name=\"Water Saturation\",\n    unit=\"fraction\",\n    log_scale=False,\n    color_scheme=ColorScheme.VIRIDIS,\n)\n\n# Final water saturation as filled contour\nfinal_water_sat = states[-1].model.fluid_properties.water_saturation_grid\n\nfig = viz.make_plot(\n    data=final_water_sat,\n    plot_type=\"contour_filled\",\n    metadata=water_sat_meta,\n    x_label=\"X (ft)\",\n    y_label=\"Y (ft)\",\n    title=\"Water Saturation Front\",\n    contour_levels=15,\n    cmin=0.0,\n    cmax=1.0,\n)\nfig.show()\n</code></pre>"},{"location":"visualization/2d-maps/#permeability-field-log-scale","title":"Permeability Field (Log Scale)","text":"<p>Display a heterogeneous permeability field on a logarithmic color scale:</p> <pre><code>perm_meta = PropertyMeta(\n    name=\"permeability_x\",\n    display_name=\"Permeability\",\n    unit=\"mD\",\n    log_scale=True,\n    color_scheme=ColorScheme.PLASMA,\n)\n\nperm_grid = states[0].model.rock_properties.absolute_permeability.x[0, :, :]  # top layer\n\nfig = viz.make_plot(\n    data=perm_grid,\n    plot_type=\"heatmap\",\n    metadata=perm_meta,\n    x_label=\"X (ft)\",\n    y_label=\"Y (ft)\",\n    title=\"Permeability Distribution (Top Layer)\",\n)\nfig.show()\n</code></pre>"},{"location":"visualization/2d-maps/#pressure-surface-with-cross-section","title":"Pressure Surface with Cross-Section","text":"<p>Combine a 3D surface view with a cross-section line plot:</p> <pre><code>viz = DataVisualizer(config=PlotConfig(width=1200, height=500))\n\n# Surface plot\nfig_surface = viz.make_plot(\n    data=pressure_grid,\n    plot_type=\"surface\",\n    metadata=pressure_meta,\n    x_coords=x_coords,\n    y_coords=y_coords,\n    x_label=\"X (ft)\",\n    y_label=\"Y (ft)\",\n    title=\"Pressure Surface\",\n)\nfig_surface.show()\n\n# Cross-section at the middle row\nfig_line = viz.make_plot(\n    data=pressure_grid,\n    plot_type=\"line\",\n    metadata=pressure_meta,\n    x_coords=x_coords,\n    y_coords=y_coords,\n    x_label=\"Distance (ft)\",\n    line_mode=\"horizontal\",\n    line_indices=[pressure_grid.shape[0] // 2],\n    title=\"Pressure Cross-Section (Middle Row)\",\n)\nfig_line.show()\n</code></pre>"},{"location":"visualization/3d-rendering/","title":"3D Volume Rendering","text":""},{"location":"visualization/3d-rendering/#overview","title":"Overview","text":"<p>The 3D visualization module renders reservoir simulation data as interactive three-dimensional volumes, isosurfaces, scatter plots, and cell block displays. These visualizations let you inspect the full spatial structure of a reservoir: pressure gradients, saturation fronts, permeability heterogeneity, and well placement in all three dimensions simultaneously.</p> <p>The module lives in <code>bores.visualization.plotly3d</code> and centers on the <code>DataVisualizer</code> class. Unlike the 2D module (which takes raw numpy arrays), the 3D module can work directly with <code>ModelState</code> and <code>ReservoirModel</code> objects. When you pass a model state and a property name, the visualizer extracts the 3D grid data, looks up the property metadata from the <code>PropertyRegistry</code>, maps physical coordinates from the depth grid, and renders the result with appropriate labels and color scales. You can also pass raw 3D numpy arrays for custom data.</p> <p>Every plot method returns a Plotly <code>Figure</code> object with full 3D interactivity. You can rotate, zoom, pan, and hover for cell-level data values. The figures support well overlays, data slicing, custom labels, and animated sequences showing property evolution over time.</p> <p>3D rendering is computationally more demanding than 2D maps. BORES includes configurable cell count limits (set through environment variables) to prevent browser crashes on large grids. For very large models, you can use the slicing feature to render a subvolume, or reduce resolution with grid coarsening before visualization.</p>"},{"location":"visualization/3d-rendering/#data-sources","title":"Data Sources","text":"<p>The 3D visualizer accepts three types of input:</p> <p><code>ModelState</code> (recommended for simulation results):</p> <pre><code>from bores.visualization.plotly3d import DataVisualizer\n\nviz = DataVisualizer()\n\n# Plot pressure from a simulation state\nstates = list(bores.run(model, config))\nfig = viz.make_plot(states[-1], property=\"pressure\")\nfig.show()\n</code></pre> <p>When you pass a <code>ModelState</code>, the visualizer uses the <code>PropertyRegistry</code> to look up metadata for the named property. It also extracts the cell dimensions and depth grid from the model to compute physical coordinates for hover text and labels. The <code>property</code> parameter is a registry key such as <code>\"pressure\"</code>, <code>\"oil_saturation\"</code>, <code>\"water_saturation\"</code>, <code>\"gas_saturation\"</code>, <code>\"permeability\"</code>, or any other registered property.</p> <p><code>ReservoirModel</code> (for initial conditions):</p> <pre><code># Plot initial permeability distribution\nfig = viz.make_plot(model, property=\"permeability\")\nfig.show()\n</code></pre> <p>This works the same as <code>ModelState</code> but uses the model directly. Useful for inspecting the static reservoir description before running a simulation.</p> <p>Raw 3D numpy array (for custom data):</p> <pre><code>import numpy as np\n\ncustom_data = np.random.rand(20, 15, 5)\nfig = viz.make_plot(custom_data)\nfig.show()\n\n# With a registered property name for metadata\nfig = viz.make_plot(custom_data, property=\"pressure\")\nfig.show()\n</code></pre> <p>When you pass a raw array, the visualizer creates generic metadata unless you provide a <code>property</code> name that matches a registry entry. Physical coordinates are not available for raw arrays, so hover text shows cell indices instead of distances in feet.</p>"},{"location":"visualization/3d-rendering/#creating-plots","title":"Creating Plots","text":""},{"location":"visualization/3d-rendering/#datavisualizer","title":"<code>DataVisualizer</code>","text":"<p>The <code>DataVisualizer</code> class is the main entry point for 3D rendering. Create one with optional configuration and property registry:</p> <pre><code>from bores.visualization.plotly3d import DataVisualizer, PlotConfig, PlotType\nfrom bores.visualization.base import ColorScheme\n\n# Default configuration\nviz = DataVisualizer()\n\n# Custom configuration\nviz = DataVisualizer(config=PlotConfig(\n    width=1400,\n    height=1000,\n    plot_type=PlotType.VOLUME,\n    color_scheme=ColorScheme.PLASMA,\n    opacity=0.7,\n    show_colorbar=True,\n    show_axes=True,\n))\n</code></pre> <p>The <code>PlotConfig</code> for 3D plots has additional parameters not found in the 2D config, including camera position, lighting, opacity scaling, cell outline styling, and aspect mode. These are covered in the Configuration Reference section below.</p>"},{"location":"visualization/3d-rendering/#make_plot","title":"<code>make_plot</code>","text":"<p>The <code>make_plot()</code> method creates a single 3D visualization:</p> <pre><code>fig = viz.make_plot(\n    source=states[-1],\n    property=\"pressure\",\n    plot_type=\"volume\",\n    title=\"Reservoir Pressure at Day 365\",\n    width=1200,\n    height=900,\n)\nfig.show()\n</code></pre> <p>The <code>plot_type</code> parameter accepts either a <code>PlotType</code> enum value or a string. Available types are <code>\"volume\"</code>, <code>\"isosurface\"</code>, <code>\"scatter_3d\"</code>, and <code>\"cell_blocks\"</code>.</p> <p>The <code>source</code> parameter accepts a <code>ModelState</code>, <code>ReservoirModel</code>, or raw 3D numpy array. When using a <code>ModelState</code> or <code>ReservoirModel</code>, the <code>property</code> parameter is required and must match a key in the <code>PropertyRegistry</code>. When using a raw array, <code>property</code> is optional.</p>"},{"location":"visualization/3d-rendering/#animate","title":"<code>animate</code>","text":"<p>The <code>animate()</code> method creates an animated sequence showing a property changing over time:</p> <pre><code>states = list(bores.run(model, config))\n\nfig = viz.animate(\n    sequence=states,\n    property=\"oil_saturation\",\n    plot_type=\"volume\",\n    frame_duration=200,\n    step_size=5,\n    title=\"Oil Saturation Evolution\",\n)\nfig.show()\n</code></pre> <p>The <code>sequence</code> parameter accepts a list of <code>ModelState</code> objects, <code>ReservoirModel</code> objects, or raw 3D arrays. The <code>frame_duration</code> parameter sets how many milliseconds each frame is displayed. The <code>step_size</code> parameter lets you skip frames for performance (1 means every frame, 5 means every fifth frame).</p> <p>The animation automatically computes consistent color ranges (<code>cmin</code> and <code>cmax</code>) across all frames so the color mapping stays constant. The resulting figure includes play/pause controls and a time slider.</p>"},{"location":"visualization/3d-rendering/#plot-types","title":"Plot Types","text":""},{"location":"visualization/3d-rendering/#volume-rendering","title":"Volume Rendering","text":"<p>Volume rendering displays a continuous 3D scalar field where each cell is colored according to its value and the opacity varies to reveal internal structure. This is the default plot type and the most versatile for examining reservoir properties.</p> <pre><code>fig = viz.make_plot(\n    states[-1],\n    property=\"pressure\",\n    plot_type=\"volume\",\n)\nfig.show()\n</code></pre> <p>Volume rendering works well for smooth, continuous properties like pressure and temperature. For properties with sharp boundaries (like saturation fronts), isosurface or cell block plots may be more informative.</p> <p>You can control opacity scaling through the <code>PlotConfig</code> to emphasize high or low values:</p> <pre><code>viz = DataVisualizer(config=PlotConfig(\n    use_opacity_scaling=True,\n    opacity_scale_values=[\n        [0.0, 0.1],   # Low values are nearly transparent\n        [0.5, 0.5],   # Mid values are semi-transparent\n        [1.0, 1.0],   # High values are fully opaque\n    ],\n))\n</code></pre>"},{"location":"visualization/3d-rendering/#isosurface","title":"Isosurface","text":"<p>Isosurface plots draw 3D surfaces at specific value thresholds within the data. They are the 3D equivalent of contour lines: each surface connects all points where the property equals a specific value.</p> <pre><code>fig = viz.make_plot(\n    states[-1],\n    property=\"oil_saturation\",\n    plot_type=\"isosurface\",\n)\nfig.show()\n</code></pre> <p>Isosurfaces are particularly useful for visualizing flood fronts (where water saturation crosses a threshold), gas-oil contacts, and pressure isobars. They give a clear picture of the 3D geometry of these interfaces.</p>"},{"location":"visualization/3d-rendering/#3d-scatter","title":"3D Scatter","text":"<p>Scatter plots display individual cells as markers in 3D space. Each marker is positioned at the cell center and colored according to the property value. This is useful for sparse data or for highlighting cells that meet specific criteria.</p> <pre><code>fig = viz.make_plot(\n    states[-1],\n    property=\"water_saturation\",\n    plot_type=\"scatter_3d\",\n)\nfig.show()\n</code></pre> <p>Scatter plots are lighter weight than volume rendering, making them a good choice for quick exploration of large grids where full volume rendering would be slow.</p>"},{"location":"visualization/3d-rendering/#cell-blocks","title":"Cell Blocks","text":"<p>Cell block plots render each reservoir cell as a 3D box, creating a voxel-style visualization. This gives an accurate representation of the grid geometry, especially for models with variable cell sizes or non-uniform layering.</p> <pre><code>viz = DataVisualizer(config=PlotConfig(\n    show_cell_outlines=True,\n    cell_outline_color=\"#404040\",\n    cell_outline_width=1.0,\n))\n\nfig = viz.make_plot(\n    states[-1],\n    property=\"permeability\",\n    plot_type=\"cell_blocks\",\n)\nfig.show()\n</code></pre> <p>The <code>show_cell_outlines</code> option draws wireframe edges around each cell, making individual cells visually distinct. This is useful for verifying grid construction and identifying thin layers or small cells. Cell block plots are the most computationally expensive plot type, so they work best for small to medium grids.</p>"},{"location":"visualization/3d-rendering/#data-slicing","title":"Data Slicing","text":"<p>For large 3D grids, you often want to examine a subvolume rather than the entire reservoir. The <code>make_plot()</code> method supports slicing along any combination of the x, y, and z axes. Slicing reduces the data volume while preserving the 3D structure of the result.</p> <p>Each slice parameter accepts an integer (single index), a tuple (range), a Python <code>slice</code> object, or <code>None</code> (full dimension):</p> <pre><code># Single layer at z-index 2 (maintains 3D structure as a thin slab)\nfig = viz.make_plot(states[-1], \"pressure\", z_slice=2)\n\n# Range of cells in x-direction\nfig = viz.make_plot(states[-1], \"pressure\", x_slice=(10, 20))\n\n# Corner section\nfig = viz.make_plot(\n    states[-1],\n    \"oil_saturation\",\n    x_slice=(0, 25),\n    y_slice=(0, 25),\n    z_slice=(0, 10),\n)\n\n# Every 2nd cell in x using a slice object\nfig = viz.make_plot(states[-1], \"pressure\", x_slice=slice(0, 50, 2))\n</code></pre> <p>When you slice the data, the plot title is automatically updated to show which portion of the grid is displayed (for example, \"X[10:20], Z[0:5]\"). The depth grid is sliced to match, so physical coordinates remain correct in hover text.</p> <p>Slicing is essential for inspecting cross-sections through a 3D model. For example, slicing at a single z-index gives you a plan view of one layer, while slicing at a single x-index gives you a vertical cross-section.</p>"},{"location":"visualization/3d-rendering/#well-visualization","title":"Well Visualization","text":"<p>When working with <code>ModelState</code> data, you can overlay well trajectories on the 3D plot. Wells are rendered as colored tubes with optional surface markers and perforation highlights:</p> <pre><code>fig = viz.make_plot(\n    states[-1],\n    \"pressure\",\n    show_wells=True,\n)\nfig.show()\n</code></pre> <p>The well visualization uses color coding to distinguish well types:</p> <ul> <li>Injection wells: red (default <code>#ff4444</code>)</li> <li>Production wells: green (default <code>#44dd44</code>)</li> <li>Shut-in wells: gray (default <code>#888888</code>)</li> </ul> <p>You can customize the well appearance through keyword arguments:</p> <pre><code>fig = viz.make_plot(\n    states[-1],\n    \"oil_saturation\",\n    show_wells=True,\n    injection_color=\"#ff6b6b\",\n    production_color=\"#51cf66\",\n    shut_in_color=\"#aaaaaa\",\n    wellbore_width=8.0,\n    show_surface_marker=True,\n    show_perforations=True,\n    surface_marker_size=2.0,\n)\n</code></pre> <p>The <code>WellKwargs</code> TypedDict defines all available well visualization options:</p> Parameter Default Description <code>show_wellbore</code> <code>True</code> Show wellbore trajectory as colored tube <code>show_surface_marker</code> <code>True</code> Show arrow at surface location <code>show_perforations</code> <code>False</code> Highlight perforated intervals <code>injection_color</code> <code>\"#ff4444\"</code> Color for injection wells <code>production_color</code> <code>\"#44dd44\"</code> Color for production wells <code>shut_in_color</code> <code>\"#888888\"</code> Color for shut-in wells <code>wellbore_width</code> 15.0 Width of wellbore line in pixels <code>surface_marker_size</code> 2.0 Size scaling factor for surface markers <p>Well visualization only works when <code>source</code> is a <code>ModelState</code> with active wells. When you pass a raw array or a <code>ReservoirModel</code>, the <code>show_wells</code> parameter is ignored.</p>"},{"location":"visualization/3d-rendering/#labels","title":"Labels","text":"<p>Labels are text annotations placed at specific 3D coordinates on the plot. They can display cell values, physical coordinates, property names, and custom text. Labels are useful for annotating specific cells of interest, well locations, or reference points.</p>"},{"location":"visualization/3d-rendering/#creating-labels","title":"Creating Labels","text":"<p>A <code>Label</code> is positioned using a <code>LabelCoordinate</code> (grid indices) and displays text from a customizable template:</p> <pre><code>from bores.visualization.plotly3d import Label, Labels, LabelCoordinate\n\n# Create a label at cell (5, 10, 2)\nlabel = Label(\n    position=LabelCoordinate(x=5, y=10, z=2),\n    text_template=\"Pressure: {formatted_value} {unit}\",\n    font_size=12,\n    font_color=\"#333333\",\n    background_color=\"rgba(240, 240, 240, 0.9)\",\n)\n</code></pre> <p>The text template supports these format variables:</p> Variable Description <code>{x_index}</code>, <code>{y_index}</code>, <code>{z_index}</code> Cell grid indices <code>{x_physical}</code>, <code>{y_physical}</code>, <code>{z_physical}</code> Physical coordinates in feet <code>{value}</code> Raw data value at the cell <code>{formatted_value}</code> Formatted value (handles log scale) <code>{property_name}</code> Property display name from metadata <code>{unit}</code> Property unit from metadata <code>{name}</code> Label name (if assigned)"},{"location":"visualization/3d-rendering/#label-collections","title":"Label Collections","text":"<p>The <code>Labels</code> class manages collections of labels and provides convenience methods for batch creation:</p> <pre><code>labels = Labels()\n\n# Add individual labels\nlabels.add(Label(\n    position=LabelCoordinate(x=5, y=10, z=0),\n    text_template=\"Injector: {formatted_value} {unit}\",\n    name=\"INJ-1\",\n))\n\n# Add labels at regular grid intervals\nlabels.add_grid_labels(\n    data_shape=(20, 15, 5),\n    spacing=(10, 10, 5),\n    template=\"({x_index}, {y_index}, {z_index})\",\n)\n\n# Add labels at grid corners\nlabels.add_boundary_labels(\n    data_shape=(20, 15, 5),\n    template=\"Corner ({x_index}, {y_index}, {z_index})\",\n)\n\n# Add labels at well positions\nlabels.add_well_labels(\n    well_positions=[(5, 10, 0), (15, 10, 0)],\n    well_names=[\"INJ-1\", \"PROD-1\"],\n)\n\n# Pass to make_plot\nfig = viz.make_plot(states[-1], \"pressure\", labels=labels)\n</code></pre> <p>Labels are rendered as Plotly 3D annotations with arrows pointing to their position. When cell dimensions and depth grids are available (from <code>ModelState</code> source), label positions are converted to physical coordinates automatically.</p> <p>You can toggle all labels on or off through the <code>PlotConfig.show_labels</code> flag.</p>"},{"location":"visualization/3d-rendering/#configuration-reference","title":"Configuration Reference","text":"<p>The <code>PlotConfig</code> class for 3D plots provides extensive control over rendering:</p> Parameter Default Description <code>width</code> 1200 Figure width in pixels <code>height</code> 960 Figure height in pixels <code>plot_type</code> <code>VOLUME</code> Default plot type <code>color_scheme</code> <code>VIRIDIS</code> Default color scheme <code>opacity</code> 0.85 Default opacity (0.0 to 1.0) <code>show_colorbar</code> <code>True</code> Display color scale bar <code>show_axes</code> <code>True</code> Display 3D axis labels and grid <code>title</code> <code>\"\"</code> Default plot title <code>show_cell_outlines</code> <code>False</code> Show wireframe around cells (cell blocks) <code>cell_outline_color</code> <code>\"#404040\"</code> Color for cell outlines <code>cell_outline_width</code> 1.0 Width of cell outline wireframes <code>use_opacity_scaling</code> <code>False</code> Data-driven opacity scaling <code>opacity_scale_values</code> <code>[[0,0.8],[0.5,0.9],[1,1.0]]</code> Opacity scale mapping <code>aspect_mode</code> <code>None</code> Aspect mode: <code>\"cube\"</code>, <code>\"data\"</code>, or <code>\"auto\"</code> <code>paper_bgcolor</code> <code>\"#ffffff\"</code> Background color of figure <code>scene_bgcolor</code> <code>\"#f8f9fa\"</code> Background color of 3D scene <code>show_labels</code> <code>True</code> Global toggle for labels"},{"location":"visualization/3d-rendering/#camera-position","title":"Camera Position","text":"<p>The camera position controls the initial viewing angle. It is specified as a <code>CameraPosition</code> TypedDict with three components:</p> <pre><code>from bores.visualization.plotly3d import PlotConfig, CameraPosition\n\nconfig = PlotConfig(\n    camera_position=CameraPosition(\n        eye={\"x\": 2.2, \"y\": 2.2, \"z\": 1.8},     # Camera location\n        center={\"x\": 0.0, \"y\": 0.0, \"z\": 0.0},   # Look-at point\n        up={\"x\": 0.0, \"y\": 0.0, \"z\": 1.0},        # Up direction\n    ),\n)\n</code></pre> <p>The <code>eye</code> vector sets where the camera is positioned in 3D space. Larger values move the camera further away. The <code>center</code> vector sets the point the camera looks at. The <code>up</code> vector defines which direction is \"up\" in the view.</p>"},{"location":"visualization/3d-rendering/#lighting","title":"Lighting","text":"<p>Lighting controls how surfaces are shaded in the 3D scene. The <code>Lighting</code> TypedDict provides physically-based parameters:</p> <pre><code>from bores.visualization.plotly3d import PlotConfig, Lighting\n\nconfig = PlotConfig(\n    lighting=Lighting(\n        ambient=0.5,      # Background illumination\n        diffuse=0.8,      # Surface scattering\n        specular=0.2,     # Shiny highlights\n        roughness=0.5,    # Surface roughness\n        fresnel=0.2,      # Edge reflections\n    ),\n)\n</code></pre> <p>Higher <code>ambient</code> values make the scene brighter overall. Higher <code>specular</code> values create shinier surfaces. Higher <code>roughness</code> values make surfaces appear more matte. The defaults provide good results for most reservoir visualizations.</p>"},{"location":"visualization/3d-rendering/#common-workflows","title":"Common Workflows","text":""},{"location":"visualization/3d-rendering/#pressure-and-saturation-dashboard","title":"Pressure and Saturation Dashboard","text":"<p>Create multiple 3D views of different properties:</p> <pre><code>from bores.visualization.plotly3d import DataVisualizer, PlotConfig\nfrom bores.visualization.base import merge_plots\n\nviz = DataVisualizer()\nstates = list(bores.run(model, config))\nfinal_state = states[-1]\n\nfig_pressure = viz.make_plot(final_state, \"pressure\", title=\"Pressure (psi)\")\nfig_oil_sat = viz.make_plot(final_state, \"oil_saturation\", title=\"Oil Saturation\")\nfig_water_sat = viz.make_plot(final_state, \"water_saturation\", title=\"Water Saturation\")\n\n# Display each individually\nfig_pressure.show()\nfig_oil_sat.show()\nfig_water_sat.show()\n</code></pre>"},{"location":"visualization/3d-rendering/#cross-section-inspection","title":"Cross-Section Inspection","text":"<p>Use slicing to examine vertical and horizontal cross-sections:</p> <pre><code>viz = DataVisualizer()\n\n# Plan view (single layer)\nfig_plan = viz.make_plot(\n    states[-1],\n    \"pressure\",\n    z_slice=0,\n    title=\"Top Layer Pressure\",\n)\n\n# Vertical cross-section (single row in y)\nfig_xsec = viz.make_plot(\n    states[-1],\n    \"pressure\",\n    y_slice=states[-1].model.grid_shape[1] // 2,\n    title=\"Vertical Cross-Section (Center)\",\n)\n\nfig_plan.show()\nfig_xsec.show()\n</code></pre>"},{"location":"visualization/3d-rendering/#animated-saturation-front","title":"Animated Saturation Front","text":"<p>Track the waterflood front advancing through the reservoir:</p> <pre><code>viz = DataVisualizer(config=PlotConfig(\n    use_opacity_scaling=True,\n    opacity_scale_values=[\n        [0.0, 0.0],   # Dry cells are transparent\n        [0.3, 0.3],   # Partially swept cells semi-transparent\n        [0.8, 0.8],   # Mostly swept cells visible\n        [1.0, 1.0],   # Fully swept cells opaque\n    ],\n))\n\nstates = list(bores.run(model, config))\n\nfig = viz.animate(\n    sequence=states,\n    property=\"water_saturation\",\n    plot_type=\"volume\",\n    frame_duration=300,\n    step_size=10,\n    title=\"Waterflood Front Progression\",\n)\nfig.show()\n</code></pre>"},{"location":"visualization/3d-rendering/#wells-with-property-overlay","title":"Wells with Property Overlay","text":"<p>Visualize well placement in the context of the reservoir property distribution:</p> <pre><code>viz = DataVisualizer(config=PlotConfig(\n    opacity=0.5,  # Make reservoir semi-transparent to see wells\n))\n\nfig = viz.make_plot(\n    states[-1],\n    \"oil_saturation\",\n    show_wells=True,\n    injection_color=\"#4488ff\",\n    production_color=\"#ff8844\",\n    wellbore_width=10.0,\n    show_perforations=True,\n    title=\"Oil Saturation with Well Layout\",\n)\nfig.show()\n</code></pre>"},{"location":"visualization/3d-rendering/#performance-considerations","title":"Performance Considerations","text":"<p>3D rendering can be resource-intensive for large grids. BORES includes built-in safeguards through environment variable configuration:</p> <ul> <li><code>BORES_MAX_VOLUME_CELLS_3D</code>: Maximum total cells allowed for volume rendering (prevents browser crashes)</li> <li><code>BORES_RECOMMENDED_VOLUME_CELLS_3D</code>: Recommended cell count for smooth interactivity</li> </ul> <p>When the grid exceeds these limits, the visualizer logs a warning. To handle large grids, you have several options:</p> <ol> <li>Slice the data to render only the region of interest</li> <li>Use scatter plots instead of volume rendering (lighter weight)</li> <li>Increase step_size for animations (render fewer frames)</li> <li>Coarsen the grid before visualization using <code>bores.grids.base.coarsen_grid()</code></li> </ol> <p>For publication-quality static images, you can export at high resolution using <code>.write_image()</code> without performance concerns, since the rendering is done once rather than interactively.</p>"}]}